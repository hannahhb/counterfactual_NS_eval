=== Example 0 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is red.
Charlie is blue.
Charlie is nice.
Charlie is red.
Charlie is round.
Charlie is white.
Erin is cold.
Harry is blue.
Harry is nice.
Harry is round.
Harry is white.
White, red things are blue.
Red things are white.
Blue things are round.
If something is blue then it is nice.
If something is green and white then it is cold.
All nice things are green.
If something is white and green then it is red.
If Erin is white and Erin is nice then Erin is green.
</PREMISES>
<CONCLUSION>
Harry is round.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is red.
FOL: Red(Anne)
TEXT: Charlie is blue.
FOL: Blue(Charlie)
TEXT: Charlie is nice.
FOL: Nice(Charlie)
TEXT: Charlie is red.
FOL: Red(Charlie)
TEXT: Charlie is round.
FOL: Round(Charlie)
TEXT: Charlie is white.
FOL: White(Charlie)
TEXT: Erin is cold.
FOL: Cold(Erin)
TEXT: Harry is blue.
FOL: Blue(Harry)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: Harry is round.
FOL: Round(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: White, red things are blue.
FOL: all x. (White(x) & Red(x) -> Blue(x))
TEXT: Red things are white.
FOL: all x. (Red(x) -> White(x))
TEXT: Blue things are round.
FOL: all x. (Blue(x) -> Round(x))
TEXT: If something is blue then it is nice.
FOL: all x. (Blue(x) -> Nice(x))
TEXT: If something is green and white then it is cold.
FOL: all x. (Green(x) & White(x) -> Cold(x))
TEXT: All nice things are green.
FOL: all x. (Nice(x) -> Green(x))
TEXT: If something is white and green then it is red.
FOL: all x. (White(x) & Green(x) -> Red(x))
TEXT: If Erin is white and Erin is nice then Erin is green.
FOL: (White(Erin) & Nice(Erin) -> Green(Erin))
TEXT: Harry is round.
FOL: Round(Harry)
</EVALUATE>
Processed: True

Generation 2:
TEXT: Anne is red.
FOL: Red(Anne)
TEXT: Charlie is blue.
FOL: Blue(Charlie)
TEXT: Charlie is nice.
FOL: Nice(Charlie)
TEXT: Charlie is red.
FOL: Red(Charlie)
TEXT: Charlie is round.
FOL: Round(Charlie)
TEXT: Charlie is white.
FOL: White(Charlie)
TEXT: Erin is cold.
FOL: Cold(Erin)
TEXT: Harry is blue.
FOL: Blue(Harry)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: Harry is round.
FOL: Round(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: White, red things are blue.
FOL: all x. (Red(x) & White(x) -> Blue(x))
TEXT: Red things are white.
FOL: all x. (Red(x) -> White(x))
TEXT: Blue things are round.
FOL: all x. (Blue(x) -> Round(x))
TEXT: If something is blue then it is nice.
FOL: all x. (Blue(x) -> Nice(x))
TEXT: If something is green and white then it is cold.
FOL: all x. (Green(x) & White(x) -> Cold(x))
TEXT: All nice things are green.
FOL: all x. (Nice(x) -> Green(x))
TEXT: If something is white and green then it is red.
FOL: all x. (White(x) & Green(x) -> Red(x))
TEXT: If Erin is white and Erin is nice then Erin is green.
FOL: (White(Erin) & Nice(Erin) -> Green(Erin))
TEXT: Harry is round.
FOL: Round(Harry)
</EVALUATE>
Processed: True

Generation 3:
TEXT: Anne is red.
FOL: Red(Anne)
TEXT: Charlie is blue.
FOL: Blue(Charlie)
TEXT: Charlie is nice.
FOL: Nice(Charlie)
TEXT: Charlie is red.
FOL: Red(Charlie)
TEXT: Charlie is round.
FOL: Round(Charlie)
TEXT: Charlie is white.
FOL: White(Charlie)
TEXT: Erin is cold.
FOL: Cold(Erin)
TEXT: Harry is blue.
FOL: Blue(Harry)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: Harry is round.
FOL: Round(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: White, red things are blue.
FOL: all x. (White(x) & Red(x) -> Blue(x))
TEXT: Red things are white.
FOL: all x. (Red(x) -> White(x))
TEXT: Blue things are round.
FOL: all x. (Blue(x) -> Round(x))
TEXT: If something is blue then it is nice.
FOL: all x. (Blue(x) -> Nice(x))
TEXT: If something is green and white then it is cold.
FOL: all x. (Green(x) & White(x) -> Cold(x))
TEXT: All nice things are green.
FOL: all x. (Nice(x) -> Green(x))
TEXT: If something is white and green then it is red.
FOL: all x. (White(x) & Green(x) -> Red(x))
TEXT: If Erin is white and Erin is nice then Erin is green.
FOL: (White(Erin) & Nice(Erin) -> Green(Erin))
TEXT: Harry is round.
FOL: Round(Harry)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 1 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle is red.
The bald eagle needs the cat.
The bald eagle visits the cat.
The cat is cold.
The cat is nice.
The cat is young.
The cow needs the bald eagle.
The cow needs the tiger.
The cow sees the bald eagle.
The tiger sees the bald eagle.
The tiger sees the cat.
The tiger visits the cat.
If someone is cold then they visit the cow.
If someone visits the tiger then they see the bald eagle.
If someone is young and they visit the cow then the cow is cold.
If someone is round then they visit the bald eagle.
If someone visits the cow then they are round.
If someone visits the cat and the cat needs the cow then they need the cow.
Round people are nice.
If someone sees the cat then they need the bald eagle.
</PREMISES>
<CONCLUSION>
The cat visits the tiger.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle is red.
FOL: Color(baldEagle, Red)
TEXT: The bald eagle needs the cat.
FOL: Needs(baldEagle, cat)
TEXT: The bald eagle visits the cat.
FOL: Visits(baldEagle, cat)
TEXT: The cat is cold.
FOL: IsCold(cat)
TEXT: The cat is nice.
FOL: IsNice(cat)
TEXT: The cat is young.
FOL: IsYoung(cat)
TEXT: The cow needs the bald eagle.
FOL: Needs(cow, baldEagle)
TEXT: The cow needs the tiger.
FOL: Needs(cow, tiger)
TEXT: The cow sees the bald eagle.
FOL: Sees(cow, baldEagle)
TEXT: The tiger sees the bald eagle.
FOL: Sees(tiger, baldEagle)
TEXT: The tiger sees the cat.
FOL: Sees(tiger, cat)
TEXT: The tiger visits the cat.
FOL: Visits(tiger, cat)
TEXT: If someone is cold then they visit the cow.
FOL: all x. (IsCold(x) -> Visits(x, cow))
TEXT: If someone visits the tiger then they see the bald eagle.
FOL: all x. (Visits(x, tiger) -> Sees(x, baldEagle))
TEXT: If someone is young and they visit the cow then the cow is cold.
FOL: all x. ((IsYoung(x) & Visits(x, cow)) -> IsCold(cow))
TEXT: If someone is round then they visit the bald eagle.
FOL: all x. (IsRound(x) -> Visits(x, baldEagle))
TEXT: If someone visits the cow then they are round.
FOL: all x. (Visits(x, cow) -> IsRound(x))
TEXT: If someone visits the cat and the cat needs the cow then they need the cow.
FOL: all x. ((Visits(x, cat) & Needs(cat, cow)) -> Needs(x, cow))
TEXT: Round people are nice.
FOL: all x. (IsRound(x) -> IsNice(x))
TEXT: If someone sees the cat then they need the bald eagle.
FOL: all x. (Sees(x, cat) -> Needs(x, baldEagle))
TEXT: The cat visits the tiger.
FOL: Visits(cat, tiger)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: The bald eagle is red.
FOL: Red(BaldEagle)
TEXT: The bald eagle needs the cat.
FOL: Needs(BaldEagle, Cat)
TEXT: The bald eagle visits the cat.
FOL: Visits(BaldEagle, Cat)
TEXT: The cat is cold.
FOL: Cold(Cat)
TEXT: The cat is nice.
FOL: Nice(Cat)
TEXT: The cat is young.
FOL: Young(Cat)
TEXT: The cow needs the bald eagle.
FOL: Needs(Cow, BaldEagle)
TEXT: The cow needs the tiger.
FOL: Needs(Cow, Tiger)
TEXT: The cow sees the bald eagle.
FOL: Sees(Cow, BaldEagle)
TEXT: The tiger sees the bald eagle.
FOL: Sees(Tiger, BaldEagle)
TEXT: The tiger sees the cat.
FOL: Sees(Tiger, Cat)
TEXT: The tiger visits the cat.
FOL: Visits(Tiger, Cat)
TEXT: If someone is cold then they visit the cow.
FOL: all x. (Cold(x) -> Visits(x, Cow))
TEXT: If someone visits the tiger then they see the bald eagle.
FOL: all x. (Visits(x, Tiger) -> Sees(x, BaldEagle))
TEXT: If someone is young and they visit the cow then the cow is cold.
FOL: all x. ((Young(x) & Visits(x, Cow)) -> Cold(Cow))
TEXT: If someone is round then they visit the bald eagle.
FOL: all x. (Round(x) -> Visits(x, BaldEagle))
TEXT: If someone visits the cow then they are round.
FOL: all x. (Visits(x, Cow) -> Round(x))
TEXT: If someone visits the cat and the cat needs the cow then they need the cow.
FOL: all x. ((Visits(x, Cat) & Needs(Cat, Cow)) -> Needs(x, Cow))
TEXT: Round people are nice.
FOL: all x. (Round(x) -> Nice(x))
TEXT: If someone sees the cat then they need the bald eagle.
FOL: all x. (Sees(x, Cat) -> Needs(x, BaldEagle))
TEXT: The cat visits the tiger.
FOL: Visits(Cat, Tiger)
Processed: Uncertain

Generation 3:
TEXT: The bald eagle is red.
FOL: Red(BaldEagle)
TEXT: The bald eagle needs the cat.
FOL: Needs(BaldEagle, Cat)
TEXT: The bald eagle visits the cat.
FOL: Visits(BaldEagle, Cat)
TEXT: The cat is cold.
FOL: Cold(Cat)
TEXT: The cat is nice.
FOL: Nice(Cat)
TEXT: The cat is young.
FOL: Young(Cat)
TEXT: The cow needs the bald eagle.
FOL: Needs(Cow, BaldEagle)
TEXT: The cow needs the tiger.
FOL: Needs(Cow, Tiger)
TEXT: The cow sees the bald eagle.
FOL: Sees(Cow, BaldEagle)
TEXT: The tiger sees the bald eagle.
FOL: Sees(Tiger, BaldEagle)
TEXT: The tiger sees the cat.
FOL: Sees(Tiger, Cat)
TEXT: The tiger visits the cat.
FOL: Visits(Tiger, Cat)
TEXT: If someone is cold then they visit the cow.
FOL: all x. (Cold(x) -> Visits(x, Cow))
TEXT: If someone visits the tiger then they see the bald eagle.
FOL: all x. (Visits(x, Tiger) -> Sees(x, BaldEagle))
TEXT: If someone is young and they visit the cow then the cow is cold.
FOL: all x. (Young(x) & Visits(x, Cow) -> Cold(Cow))
TEXT: If someone is round then they visit the bald eagle.
FOL: all x. (Round(x) -> Visits(x, BaldEagle))
TEXT: If someone visits the cow then they are round.
FOL: all x. (Visits(x, Cow) -> Round(x))
TEXT: If someone visits the cat and the cat needs the cow then they need the cow.
FOL: all x. (Visits(x, Cat) & Needs(Cat, Cow) -> Needs(x, Cow))
TEXT: Round people are nice.
FOL: all x. (Round(x) -> Nice(x))
TEXT: If someone sees the cat then they need the bald eagle.
FOL: all x. (Sees(x, Cat) -> Needs(x, BaldEagle))
TEXT: The cat visits the tiger.
FOL: Visits(Cat, Tiger)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 2 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bear eats the cat.
The cat chases the squirrel.
The cat is big.
The cat is round.
The cat likes the squirrel.
The lion chases the squirrel.
The lion eats the cat.
The lion eats the squirrel.
The squirrel eats the lion.
The squirrel is not big.
The squirrel is not round.
If something chases the lion then it does not like the lion.
If the lion eats the bear then the bear is big.
If something is big then it chases the lion.
If something chases the lion then the lion eats the bear.
If something eats the squirrel then it likes the cat.
All green things are cold.
</PREMISES>
<CONCLUSION>
The lion chases the squirrel.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bear eats the cat.
FOL: Eats(Bear, Cat)

TEXT: The cat chases the squirrel.
FOL: Chases(Cat, Squirrel)

TEXT: The cat is big.
FOL: Big(Cat)

TEXT: The cat is round.
FOL: Round(Cat)

TEXT: The cat likes the squirrel.
FOL: Likes(Cat, Squirrel)

TEXT: The lion chases the squirrel.
FOL: Chases(Lion, Squirrel)

TEXT: The lion eats the cat.
FOL: Eats(Lion, Cat)

TEXT: The lion eats the squirrel.
FOL: Eats(Lion, Squirrel)

TEXT: The squirrel eats the lion.
FOL: Eats(Squirrel, Lion)

TEXT: The squirrel is not big.
FOL: -Big(Squirrel)

TEXT: The squirrel is not round.
FOL: -Round(Squirrel)

TEXT: If something chases the lion then it does not like the lion.
FOL: all x. (Chases(x, Lion) -> -Likes(x, Lion))

TEXT: If the lion eats the bear then the bear is big.
FOL: (Eats(Lion, Bear) -> Big(Bear))

TEXT: If something is big then it chases the lion.
FOL: all x. (Big(x) -> Chases(x, Lion))

TEXT: If something chases the lion then the lion eats the bear.
FOL: all x. (Chases(x, Lion) -> Eats(Lion, Bear))

TEXT: If something eats the squirrel then it likes the cat.
FOL: all x. (Eats(x, Squirrel) -> Likes(x, Cat))

TEXT: All green things are cold.
FOL: all x. (Green(x) -> Cold(x))

TEXT: The lion chases the squirrel.
FOL: Chases(Lion, Squirrel)
Processed: True

Generation 2:
TEXT: The bear eats the cat.
FOL: Eats(Bear, Cat)

TEXT: The cat chases the squirrel.
FOL: Chases(Cat, Squirrel)

TEXT: The cat is big.
FOL: Big(Cat)

TEXT: The cat is round.
FOL: Round(Cat)

TEXT: The cat likes the squirrel.
FOL: Likes(Cat, Squirrel)

TEXT: The lion chases the squirrel.
FOL: Chases(Lion, Squirrel)

TEXT: The lion eats the cat.
FOL: Eats(Lion, Cat)

TEXT: The lion eats the squirrel.
FOL: Eats(Lion, Squirrel)

TEXT: The squirrel eats the lion.
FOL: Eats(Squirrel, Lion)

TEXT: The squirrel is not big.
FOL: -Big(Squirrel)

TEXT: The squirrel is not round.
FOL: -Round(Squirrel)

TEXT: If something chases the lion then it does not like the lion.
FOL: all x. (Chases(x, Lion) -> -Likes(x, Lion))

TEXT: If the lion eats the bear then the bear is big.
FOL: (Eats(Lion, Bear) -> Big(Bear))

TEXT: If something is big then it chases the lion.
FOL: all x. (Big(x) -> Chases(x, Lion))

TEXT: If something chases the lion then the lion eats the bear.
FOL: all x. (Chases(x, Lion) -> Eats(Lion, Bear))

TEXT: If something eats the squirrel then it likes the cat.
FOL: all x. (Eats(x, Squirrel) -> Likes(x, Cat))

TEXT: All green things are cold.
FOL: all x. (Green(x) -> Cold(x))

TEXT: The lion chases the squirrel.
FOL: Chases(Lion, Squirrel)
Processed: True

Generation 3:
TEXT: The bear eats the cat.
FOL: Eats(Bear, Cat)

TEXT: The cat chases the squirrel.
FOL: Chases(Cat, Squirrel)

TEXT: The cat is big.
FOL: Big(Cat)

TEXT: The cat is round.
FOL: Round(Cat)

TEXT: The cat likes the squirrel.
FOL: Likes(Cat, Squirrel)

TEXT: The lion chases the squirrel.
FOL: Chases(Lion, Squirrel)

TEXT: The lion eats the cat.
FOL: Eats(Lion, Cat)

TEXT: The lion eats the squirrel.
FOL: Eats(Lion, Squirrel)

TEXT: The squirrel eats the lion.
FOL: Eats(Squirrel, Lion)

TEXT: The squirrel is not big.
FOL: -Big(Squirrel)

TEXT: The squirrel is not round.
FOL: -Round(Squirrel)

TEXT: If something chases the lion then it does not like the lion.
FOL: all x. (Chases(x, Lion) -> -Likes(x, Lion))

TEXT: If the lion eats the bear then the bear is big.
FOL: (Eats(Lion, Bear) -> Big(Bear))

TEXT: If something is big then it chases the lion.
FOL: all x. (Big(x) -> Chases(x, Lion))

TEXT: If something chases the lion then the lion eats the bear.
FOL: all x. (Chases(x, Lion) -> Eats(Lion, Bear))

TEXT: If something eats the squirrel then it likes the cat.
FOL: all x. (Eats(x, Squirrel) -> Likes(x, Cat))

TEXT: All green things are cold.
FOL: all x. (Green(x) -> Cold(x))

TEXT: The lion chases the squirrel.
FOL: Chases(Lion, Squirrel)
Processed: True

Reference: True
========================================

=== Example 3 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle is round.
The bald eagle needs the tiger.
The bald eagle visits the tiger.
The bear eats the bald eagle.
The bear is nice.
The bear needs the bald eagle.
The rabbit eats the bald eagle.
The rabbit is big.
The rabbit is nice.
The rabbit does not need the bald eagle.
The rabbit needs the bear.
The rabbit needs the tiger.
The rabbit does not visit the bald eagle.
The tiger needs the rabbit.
If something eats the tiger and it is round then the tiger eats the bear.
If something needs the tiger then it is red.
If something eats the bald eagle then it is red.
If something eats the rabbit then it eats the tiger.
If something is round and it does not need the bald eagle then it eats the rabbit.
If something needs the bear and it is young then it needs the tiger.
If something is red and it eats the bald eagle then it is round.
If something is red and it eats the rabbit then it visits the bear.
</PREMISES>
<CONCLUSION>
The tiger eats the tiger.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle is round.
FOL: Round(BaldEagle)
TEXT: The bald eagle needs the tiger.
FOL: Needs(BaldEagle, Tiger)
TEXT: The bald eagle visits the tiger.
FOL: Visits(BaldEagle, Tiger)
TEXT: The bear eats the bald eagle.
FOL: Eats(Bear, BaldEagle)
TEXT: The bear is nice.
FOL: Nice(Bear)
TEXT: The bear needs the bald eagle.
FOL: Needs(Bear, BaldEagle)
TEXT: The rabbit eats the bald eagle.
FOL: Eats(Rabbit, BaldEagle)
TEXT: The rabbit is big.
FOL: Big(Rabbit)
TEXT: The rabbit is nice.
FOL: Nice(Rabbit)
TEXT: The rabbit does not need the bald eagle.
FOL: -Needs(Rabbit, BaldEagle)
TEXT: The rabbit needs the bear.
FOL: Needs(Rabbit, Bear)
TEXT: The rabbit needs the tiger.
FOL: Needs(Rabbit, Tiger)
TEXT: The rabbit does not visit the bald eagle.
FOL: -Visits(Rabbit, BaldEagle)
TEXT: The tiger needs the rabbit.
FOL: Needs(Tiger, Rabbit)
TEXT: If something eats the tiger and it is round then the tiger eats the bear.
FOL: all x. ((Eats(x, Tiger) & Round(x)) -> Eats(Tiger, Bear))
TEXT: If something needs the tiger then it is red.
FOL: all x. (Needs(x, Tiger) -> Red(x))
TEXT: If something eats the bald eagle then it is red.
FOL: all x. (Eats(x, BaldEagle) -> Red(x))
TEXT: If something eats the rabbit then it eats the tiger.
FOL: all x. (Eats(x, Rabbit) -> Eats(x, Tiger))
TEXT: If something is round and it does not need the bald eagle then it eats the rabbit.
FOL: all x. ((Round(x) & -Needs(x, BaldEagle)) -> Eats(x, Rabbit))
TEXT: If something needs the bear and it is young then it needs the tiger.
FOL: all x. ((Needs(x, Bear) & Young(x)) -> Needs(x, Tiger))
TEXT: If something is red and it eats the bald eagle then it is round.
FOL: all x. ((Red(x) & Eats(x, BaldEagle)) -> Round(x))
TEXT: If something is red and it eats the rabbit then it visits the bear.
FOL: all x. ((Red(x) & Eats(x, Rabbit)) -> Visits(x, Bear))
TEXT: The tiger eats the tiger.
FOL: Eats(Tiger, Tiger)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: The bald eagle is round.
FOL: Round(BaldEagle)

TEXT: The bald eagle needs the tiger.
FOL: Needs(BaldEagle, Tiger)

TEXT: The bald eagle visits the tiger.
FOL: Visits(BaldEagle, Tiger)

TEXT: The bear eats the bald eagle.
FOL: Eats(Bear, BaldEagle)

TEXT: The bear is nice.
FOL: Nice(Bear)

TEXT: The bear needs the bald eagle.
FOL: Needs(Bear, BaldEagle)

TEXT: The rabbit eats the bald eagle.
FOL: Eats(Rabbit, BaldEagle)

TEXT: The rabbit is big.
FOL: Big(Rabbit)

TEXT: The rabbit is nice.
FOL: Nice(Rabbit)

TEXT: The rabbit does not need the bald eagle.
FOL: -Needs(Rabbit, BaldEagle)

TEXT: The rabbit needs the bear.
FOL: Needs(Rabbit, Bear)

TEXT: The rabbit needs the tiger.
FOL: Needs(Rabbit, Tiger)

TEXT: The rabbit does not visit the bald eagle.
FOL: -Visits(Rabbit, BaldEagle)

TEXT: The tiger needs the rabbit.
FOL: Needs(Tiger, Rabbit)

TEXT: If something eats the tiger and it is round then the tiger eats the bear.
FOL: all x. ((Eats(x, Tiger) & Round(x)) -> Eats(Tiger, Bear))

TEXT: If something needs the tiger then it is red.
FOL: all x. (Needs(x, Tiger) -> Red(x))

TEXT: If something eats the bald eagle then it is red.
FOL: all x. (Eats(x, BaldEagle) -> Red(x))

TEXT: If something eats the rabbit then it eats the tiger.
FOL: all x. (Eats(x, Rabbit) -> Eats(x, Tiger))

TEXT: If something is round and it does not need the bald eagle then it eats the rabbit.
FOL: all x. ((Round(x) & -Needs(x, BaldEagle)) -> Eats(x, Rabbit))

TEXT: If something needs the bear and it is young then it needs the tiger.
FOL: all x. ((Needs(x, Bear) & Young(x)) -> Needs(x, Tiger))

TEXT: If something is red and it eats the bald eagle then it is round.
FOL: all x. ((Red(x) & Eats(x, BaldEagle)) -> Round(x))

TEXT: If something is red and it eats the rabbit then it visits the bear.
FOL: all x. ((Red(x) & Eats(x, Rabbit)) -> Visits(x, Bear))

TEXT: The tiger eats the tiger.
FOL: Eats(Tiger, Tiger)
Processed: Uncertain

Generation 3:
TEXT: The bald eagle is round.
FOL: Round(BaldEagle)

TEXT: The bald eagle needs the tiger.
FOL: Needs(BaldEagle, Tiger)

TEXT: The bald eagle visits the tiger.
FOL: Visits(BaldEagle, Tiger)

TEXT: The bear eats the bald eagle.
FOL: Eats(Bear, BaldEagle)

TEXT: The bear is nice.
FOL: Nice(Bear)

TEXT: The bear needs the bald eagle.
FOL: Needs(Bear, BaldEagle)

TEXT: The rabbit eats the bald eagle.
FOL: Eats(Rabbit, BaldEagle)

TEXT: The rabbit is big.
FOL: Big(Rabbit)

TEXT: The rabbit is nice.
FOL: Nice(Rabbit)

TEXT: The rabbit does not need the bald eagle.
FOL: -Needs(Rabbit, BaldEagle)

TEXT: The rabbit needs the bear.
FOL: Needs(Rabbit, Bear)

TEXT: The rabbit needs the tiger.
FOL: Needs(Rabbit, Tiger)

TEXT: The rabbit does not visit the bald eagle.
FOL: -Visits(Rabbit, BaldEagle)

TEXT: The tiger needs the rabbit.
FOL: Needs(Tiger, Rabbit)

TEXT: If something eats the tiger and it is round then the tiger eats the bear.
FOL: all x. (Eats(x, Tiger) & Round(x) -> Eats(Tiger, Bear))

TEXT: If something needs the tiger then it is red.
FOL: all x. (Needs(x, Tiger) -> Red(x))

TEXT: If something eats the bald eagle then it is red.
FOL: all x. (Eats(x, BaldEagle) -> Red(x))

TEXT: If something eats the rabbit then it eats the tiger.
FOL: all x. (Eats(x, Rabbit) -> Eats(x, Tiger))

TEXT: If something is round and it does not need the bald eagle then it eats the rabbit.
FOL: all x. (Round(x) & -Needs(x, BaldEagle) -> Eats(x, Rabbit))

TEXT: If something needs the bear and it is young then it needs the tiger.
FOL: all x. (Needs(x, Bear) & Young(x) -> Needs(x, Tiger))

TEXT: If something is red and it eats the bald eagle then it is round.
FOL: all x. (Red(x) & Eats(x, BaldEagle) -> Round(x))

TEXT: If something is red and it eats the rabbit then it visits the bear.
FOL: all x. (Red(x) & Eats(x, Rabbit) -> Visits(x, Bear))

TEXT: The tiger eats the tiger.
FOL: Eats(Tiger, Tiger)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 4 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bear is nice.
The bear is red.
The bear does not need the mouse.
The cat chases the bear.
The cat chases the mouse.
The lion eats the bear.
The lion eats the cat.
The lion needs the bear.
The lion needs the cat.
The mouse eats the lion.
If someone eats the mouse then the mouse chases the bear.
If the mouse chases the bear then the bear eats the cat.
If someone needs the cat and the cat is red then they eat the bear.
If someone chases the bear then they do not eat the bear.
If someone is nice then they do not eat the bear.
If someone eats the cat then they do not chase the cat.
If someone chases the lion and they need the lion then they do not eat the mouse.
If someone needs the lion then they eat the mouse.
If someone chases the bear then the bear needs the lion.
</PREMISES>
<CONCLUSION>
The lion does not eat the mouse.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bear is nice.
FOL: Nice(Bear)
TEXT: The bear is red.
FOL: Red(Bear)
TEXT: The bear does not need the mouse.
FOL: -Needs(Bear, Mouse)
TEXT: The cat chases the bear.
FOL: Chases(Cat, Bear)
TEXT: The cat chases the mouse.
FOL: Chases(Cat, Mouse)
TEXT: The lion eats the bear.
FOL: Eats(Lion, Bear)
TEXT: The lion eats the cat.
FOL: Eats(Lion, Cat)
TEXT: The lion needs the bear.
FOL: Needs(Lion, Bear)
TEXT: The lion needs the cat.
FOL: Needs(Lion, Cat)
TEXT: The mouse eats the lion.
FOL: Eats(Mouse, Lion)
TEXT: If someone eats the mouse then the mouse chases the bear.
FOL: all x. (Eats(x, Mouse) -> Chases(Mouse, Bear))
TEXT: If the mouse chases the bear then the bear eats the cat.
FOL: Chases(Mouse, Bear) -> Eats(Bear, Cat)
TEXT: If someone needs the cat and the cat is red then they eat the bear.
FOL: all x. (Needs(x, Cat) & Red(Cat) -> Eats(x, Bear))
TEXT: If someone chases the bear then they do not eat the bear.
FOL: all x. (Chases(x, Bear) -> -Eats(x, Bear))
TEXT: If someone is nice then they do not eat the bear.
FOL: all x. (Nice(x) -> -Eats(x, Bear))
TEXT: If someone eats the cat then they do not chase the cat.
FOL: all x. (Eats(x, Cat) -> -Chases(x, Cat))
TEXT: If someone chases the lion and they need the lion then they do not eat the mouse.
FOL: all x. (Chases(x, Lion) & Needs(x, Lion) -> -Eats(x, Mouse))
TEXT: If someone needs the lion then they eat the mouse.
FOL: all x. (Needs(x, Lion) -> Eats(x, Mouse))
TEXT: If someone chases the bear then the bear needs the lion.
FOL: all x. (Chases(x, Bear) -> Needs(Bear, Lion))
TEXT: The lion does not eat the mouse.
FOL: -Eats(Lion, Mouse)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: The bear is nice.
FOL: Nice(Bear)
TEXT: The bear is red.
FOL: Red(Bear)
TEXT: The bear does not need the mouse.
FOL: -Needs(Bear, Mouse)
TEXT: The cat chases the bear.
FOL: Chases(Cat, Bear)
TEXT: The cat chases the mouse.
FOL: Chases(Cat, Mouse)
TEXT: The lion eats the bear.
FOL: Eats(Lion, Bear)
TEXT: The lion eats the cat.
FOL: Eats(Lion, Cat)
TEXT: The lion needs the bear.
FOL: Needs(Lion, Bear)
TEXT: The lion needs the cat.
FOL: Needs(Lion, Cat)
TEXT: The mouse eats the lion.
FOL: Eats(Mouse, Lion)
TEXT: If someone eats the mouse then the mouse chases the bear.
FOL: all x. (Eats(x, Mouse) -> Chases(Mouse, Bear))
TEXT: If the mouse chases the bear then the bear eats the cat.
FOL: (Chases(Mouse, Bear) -> Eats(Bear, Cat))
TEXT: If someone needs the cat and the cat is red then they eat the bear.
FOL: all x. (Needs(x, Cat) & Red(Cat) -> Eats(x, Bear))
TEXT: If someone chases the bear then they do not eat the bear.
FOL: all x. (Chases(x, Bear) -> -Eats(x, Bear))
TEXT: If someone is nice then they do not eat the bear.
FOL: all x. (Nice(x) -> -Eats(x, Bear))
TEXT: If someone eats the cat then they do not chase the cat.
FOL: all x. (Eats(x, Cat) -> -Chases(x, Cat))
TEXT: If someone chases the lion and they need the lion then they do not eat the mouse.
FOL: all x. (Chases(x, Lion) & Needs(x, Lion) -> -Eats(x, Mouse))
TEXT: If someone needs the lion then they eat the mouse.
FOL: all x. (Needs(x, Lion) -> Eats(x, Mouse))
TEXT: If someone chases the bear then the bear needs the lion.
FOL: all x. (Chases(x, Bear) -> Needs(Bear, Lion))
TEXT: The lion does not eat the mouse.
FOL: -Eats(Lion, Mouse)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: The bear is nice.
FOL: Nice(Bear)
TEXT: The bear is red.
FOL: Red(Bear)
TEXT: The bear does not need the mouse.
FOL: -(Needs(Bear, Mouse))
TEXT: The cat chases the bear.
FOL: Chases(Cat, Bear)
TEXT: The cat chases the mouse.
FOL: Chases(Cat, Mouse)
TEXT: The lion eats the bear.
FOL: Eats(Lion, Bear)
TEXT: The lion eats the cat.
FOL: Eats(Lion, Cat)
TEXT: The lion needs the bear.
FOL: Needs(Lion, Bear)
TEXT: The lion needs the cat.
FOL: Needs(Lion, Cat)
TEXT: The mouse eats the lion.
FOL: Eats(Mouse, Lion)
TEXT: If someone eats the mouse then the mouse chases the bear.
FOL: all x. (Eats(x, Mouse) -> Chases(Mouse, Bear))
TEXT: If the mouse chases the bear then the bear eats the cat.
FOL: (Chases(Mouse, Bear) -> Eats(Bear, Cat))
TEXT: If someone needs the cat and the cat is red then they eat the bear.
FOL: all x. (Needs(x, Cat) & Red(Cat) -> Eats(x, Bear))
TEXT: If someone chases the bear then they do not eat the bear.
FOL: all x. (Chases(x, Bear) -> -(Eats(x, Bear)))
TEXT: If someone is nice then they do not eat the bear.
FOL: all x. (Nice(x) -> -(Eats(x, Bear)))
TEXT: If someone eats the cat then they do not chase the cat.
FOL: all x. (Eats(x, Cat) -> -(Chases(x, Cat)))
TEXT: If someone chases the lion and they need the lion then they do not eat the mouse.
FOL: all x. (Chases(x, Lion) & Needs(x, Lion) -> -(Eats(x, Mouse)))
TEXT: If someone needs the lion then they eat the mouse.
FOL: all x. (Needs(x, Lion) -> Eats(x, Mouse))
TEXT: If someone chases the bear then the bear needs the lion.
FOL: all x. (Chases(x, Bear) -> Needs(Bear, Lion))
TEXT: The lion does not eat the mouse.
FOL: -(Eats(Lion, Mouse))
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 5 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is blue.
Bob is nice.
Bob is red.
Bob is round.
Bob is young.
Dave is nice.
Dave is smart.
Fiona is round.
Fiona is white.
Gary is red.
If Fiona is young then Fiona is blue.
If Gary is nice then Gary is blue.
White, red things are nice.
Nice, round things are smart.
If Fiona is smart then Fiona is red.
All round things are young.
All blue, young things are white.
All round, blue things are red.
</PREMISES>
<CONCLUSION>
Bob is smart.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is blue.
FOL: Blue(Bob)
TEXT: Bob is nice.
FOL: Nice(Bob)
TEXT: Bob is red.
FOL: Red(Bob)
TEXT: Bob is round.
FOL: Round(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Dave is nice.
FOL: Nice(Dave)
TEXT: Dave is smart.
FOL: Smart(Dave)
TEXT: Fiona is round.
FOL: Round(Fiona)
TEXT: Fiona is white.
FOL: White(Fiona)
TEXT: Gary is red.
FOL: Red(Gary)
TEXT: If Fiona is young then Fiona is blue.
FOL: Young(Fiona) -> Blue(Fiona)
TEXT: If Gary is nice then Gary is blue.
FOL: Nice(Gary) -> Blue(Gary)
TEXT: White, red things are nice.
FOL: all x. (White(x) & Red(x) -> Nice(x))
TEXT: Nice, round things are smart.
FOL: all x. (Nice(x) & Round(x) -> Smart(x))
TEXT: If Fiona is smart then Fiona is red.
FOL: Smart(Fiona) -> Red(Fiona)
TEXT: All round things are young.
FOL: all x. (Round(x) -> Young(x))
TEXT: All blue, young things are white.
FOL: all x. (Blue(x) & Young(x) -> White(x))
TEXT: All round, blue things are red.
FOL: all x. (Round(x) & Blue(x) -> Red(x))
TEXT: Bob is smart.
FOL: Smart(Bob)
Processed: True

Generation 2:
TEXT: Bob is blue.
FOL: Color(Bob, Blue)
TEXT: Bob is nice.
FOL: Nice(Bob)
TEXT: Bob is red.
FOL: Color(Bob, Red)
TEXT: Bob is round.
FOL: Shape(Bob, Round)
TEXT: Bob is young.
FOL: Age(Bob, Young)
TEXT: Dave is nice.
FOL: Nice(Dave)
TEXT: Dave is smart.
FOL: Smart(Dave)
TEXT: Fiona is round.
FOL: Shape(Fiona, Round)
TEXT: Fiona is white.
FOL: Color(Fiona, White)
TEXT: Gary is red.
FOL: Color(Gary, Red)
TEXT: If Fiona is young then Fiona is blue.
FOL: (Age(Fiona, Young) -> Color(Fiona, Blue))
TEXT: If Gary is nice then Gary is blue.
FOL: (Nice(Gary) -> Color(Gary, Blue))
TEXT: White, red things are nice.
FOL: all x. (Color(x, White) & Color(x, Red) -> Nice(x))
TEXT: Nice, round things are smart.
FOL: all x. (Nice(x) & Shape(x, Round) -> Smart(x))
TEXT: If Fiona is smart then Fiona is red.
FOL: (Smart(Fiona) -> Color(Fiona, Red))
TEXT: All round things are young.
FOL: all x. (Shape(x, Round) -> Age(x, Young))
TEXT: All blue, young things are white.
FOL: all x. (Color(x, Blue) & Age(x, Young) -> Color(x, White))
TEXT: All round, blue things are red.
FOL: all x. (Shape(x, Round) & Color(x, Blue) -> Color(x, Red))
TEXT: Bob is smart.
FOL: Smart(Bob)
</EVALUATE>
Processed: True

Generation 3:
TEXT: Bob is blue.
FOL: Blue(Bob)
TEXT: Bob is nice.
FOL: Nice(Bob)
TEXT: Bob is red.
FOL: Red(Bob)
TEXT: Bob is round.
FOL: Round(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Dave is nice.
FOL: Nice(Dave)
TEXT: Dave is smart.
FOL: Smart(Dave)
TEXT: Fiona is round.
FOL: Round(Fiona)
TEXT: Fiona is white.
FOL: White(Fiona)
TEXT: Gary is red.
FOL: Red(Gary)
TEXT: If Fiona is young then Fiona is blue.
FOL: Young(Fiona) -> Blue(Fiona)
TEXT: If Gary is nice then Gary is blue.
FOL: Nice(Gary) -> Blue(Gary)
TEXT: White, red things are nice.
FOL: all x. ((White(x) & Red(x)) -> Nice(x))
TEXT: Nice, round things are smart.
FOL: all x. ((Nice(x) & Round(x)) -> Smart(x))
TEXT: If Fiona is smart then Fiona is red.
FOL: Smart(Fiona) -> Red(Fiona)
TEXT: All round things are young.
FOL: all x. (Round(x) -> Young(x))
TEXT: All blue, young things are white.
FOL: all x. ((Blue(x) & Young(x)) -> White(x))
TEXT: All round, blue things are red.
FOL: all x. ((Round(x) & Blue(x)) -> Red(x))
TEXT: Bob is smart.
FOL: Smart(Bob)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 6 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Dave is quiet.
Erin is big.
Erin is kind.
Fiona is blue.
Fiona is kind.
Gary is big.
Gary is blue.
Furry things are quiet.
Kind things are rough.
All rough, furry things are quiet.
Kind, big things are furry.
If Dave is rough then Dave is blue.
If something is kind and rough then it is big.
If Dave is kind then Dave is furry.
If something is quiet then it is round.
</PREMISES>
<CONCLUSION>
Dave is blue.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Erin is big.
FOL: Big(Erin)
TEXT: Erin is kind.
FOL: Kind(Erin)
TEXT: Fiona is blue.
FOL: Blue(Fiona)
TEXT: Fiona is kind.
FOL: Kind(Fiona)
TEXT: Gary is big.
FOL: Big(Gary)
TEXT: Gary is blue.
FOL: Blue(Gary)
TEXT: Furry things are quiet.
FOL: all x. (Furry(x) -> Quiet(x))
TEXT: Kind things are rough.
FOL: all x. (Kind(x) -> Rough(x))
TEXT: All rough, furry things are quiet.
FOL: all x. ((Rough(x) & Furry(x)) -> Quiet(x))
TEXT: Kind, big things are furry.
FOL: all x. ((Kind(x) & Big(x)) -> Furry(x))
TEXT: If Dave is rough then Dave is blue.
FOL: Rough(Dave) -> Blue(Dave)
TEXT: If something is kind and rough then it is big.
FOL: all x. ((Kind(x) & Rough(x)) -> Big(x))
TEXT: If Dave is kind then Dave is furry.
FOL: Kind(Dave) -> Furry(Dave)
TEXT: If something is quiet then it is round.
FOL: all x. (Quiet(x) -> Round(x))
TEXT: Dave is blue.
FOL: Blue(Dave)
Processed: Uncertain

Generation 2:
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Erin is big.
FOL: Big(Erin)
TEXT: Erin is kind.
FOL: Kind(Erin)
TEXT: Fiona is blue.
FOL: Blue(Fiona)
TEXT: Fiona is kind.
FOL: Kind(Fiona)
TEXT: Gary is big.
FOL: Big(Gary)
TEXT: Gary is blue.
FOL: Blue(Gary)
TEXT: Furry things are quiet.
FOL: all x. (Furry(x) -> Quiet(x))
TEXT: Kind things are rough.
FOL: all x. (Kind(x) -> Rough(x))
TEXT: All rough, furry things are quiet.
FOL: all x. ((Rough(x) & Furry(x)) -> Quiet(x))
TEXT: Kind, big things are furry.
FOL: all x. ((Kind(x) & Big(x)) -> Furry(x))
TEXT: If Dave is rough then Dave is blue.
FOL: (Rough(Dave) -> Blue(Dave))
TEXT: If something is kind and rough then it is big.
FOL: all x. ((Kind(x) & Rough(x)) -> Big(x))
TEXT: If Dave is kind then Dave is furry.
FOL: (Kind(Dave) -> Furry(Dave))
TEXT: If something is quiet then it is round.
FOL: all x. (Quiet(x) -> Round(x))
TEXT: Dave is blue.
FOL: Blue(Dave)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Erin is big.
FOL: Big(Erin)
TEXT: Erin is kind.
FOL: Kind(Erin)
TEXT: Fiona is blue.
FOL: Blue(Fiona)
TEXT: Fiona is kind.
FOL: Kind(Fiona)
TEXT: Gary is big.
FOL: Big(Gary)
TEXT: Gary is blue.
FOL: Blue(Gary)
TEXT: Furry things are quiet.
FOL: all x. (Furry(x) -> Quiet(x))
TEXT: Kind things are rough.
FOL: all x. (Kind(x) -> Rough(x))
TEXT: All rough, furry things are quiet.
FOL: all x. ((Rough(x) & Furry(x)) -> Quiet(x))
TEXT: Kind, big things are furry.
FOL: all x. ((Kind(x) & Big(x)) -> Furry(x))
TEXT: If Dave is rough then Dave is blue.
FOL: (Rough(Dave) -> Blue(Dave))
TEXT: If something is kind and rough then it is big.
FOL: all x. ((Kind(x) & Rough(x)) -> Big(x))
TEXT: If Dave is kind then Dave is furry.
FOL: (Kind(Dave) -> Furry(Dave))
TEXT: If something is quiet then it is round.
FOL: all x. (Quiet(x) -> Round(x))
TEXT: Dave is blue.
FOL: Blue(Dave)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 7 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is not furry.
Bob is quiet.
Bob is not rough.
Bob is not round.
Erin is not kind.
Erin is rough.
Gary is big.
Harry is furry.
Harry is green.
Harry is not round.
All big, round people are rough.
If someone is rough and not green then they are quiet.
If someone is round and rough then they are quiet.
All big people are round.
All quiet people are kind.
All rough, quiet people are big.
If someone is round and kind then they are furry.
If someone is big and not quiet then they are furry.
</PREMISES>
<CONCLUSION>
Gary is green.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is not furry.
FOL: -Furry(Bob)

TEXT: Bob is quiet.
FOL: Quiet(Bob)

TEXT: Bob is not rough.
FOL: -Rough(Bob)

TEXT: Bob is not round.
FOL: -Round(Bob)

TEXT: Erin is not kind.
FOL: -Kind(Erin)

TEXT: Erin is rough.
FOL: Rough(Erin)

TEXT: Gary is big.
FOL: Big(Gary)

TEXT: Harry is furry.
FOL: Furry(Harry)

TEXT: Harry is green.
FOL: Green(Harry)

TEXT: Harry is not round.
FOL: -Round(Harry)

TEXT: All big, round people are rough.
FOL: all x. (Big(x) & Round(x) -> Rough(x))

TEXT: If someone is rough and not green then they are quiet.
FOL: all x. (Rough(x) & -Green(x) -> Quiet(x))

TEXT: If someone is round and rough then they are quiet.
FOL: all x. (Round(x) & Rough(x) -> Quiet(x))

TEXT: All big people are round.
FOL: all x. (Big(x) -> Round(x))

TEXT: All quiet people are kind.
FOL: all x. (Quiet(x) -> Kind(x))

TEXT: All rough, quiet people are big.
FOL: all x. (Rough(x) & Quiet(x) -> Big(x))

TEXT: If someone is round and kind then they are furry.
FOL: all x. (Round(x) & Kind(x) -> Furry(x))

TEXT: If someone is big and not quiet then they are furry.
FOL: all x. (Big(x) & -Quiet(x) -> Furry(x))

TEXT: Gary is green.
FOL: Green(Gary)
Processed: Uncertain

Generation 2:
TEXT: Bob is not furry.
FOL: -Furry(Bob)
TEXT: Bob is quiet.
FOL: Quiet(Bob)
TEXT: Bob is not rough.
FOL: -Rough(Bob)
TEXT: Bob is not round.
FOL: -Round(Bob)
TEXT: Erin is not kind.
FOL: -Kind(Erin)
TEXT: Erin is rough.
FOL: Rough(Erin)
TEXT: Gary is big.
FOL: Big(Gary)
TEXT: Harry is furry.
FOL: Furry(Harry)
TEXT: Harry is green.
FOL: Green(Harry)
TEXT: Harry is not round.
FOL: -Round(Harry)
TEXT: All big, round people are rough.
FOL: all x. (Big(x) & Round(x) -> Rough(x))
TEXT: If someone is rough and not green then they are quiet.
FOL: all x. (Rough(x) & -Green(x) -> Quiet(x))
TEXT: If someone is round and rough then they are quiet.
FOL: all x. (Round(x) & Rough(x) -> Quiet(x))
TEXT: All big people are round.
FOL: all x. (Big(x) -> Round(x))
TEXT: All quiet people are kind.
FOL: all x. (Quiet(x) -> Kind(x))
TEXT: All rough, quiet people are big.
FOL: all x. (Rough(x) & Quiet(x) -> Big(x))
TEXT: If someone is round and kind then they are furry.
FOL: all x. (Round(x) & Kind(x) -> Furry(x))
TEXT: If someone is big and not quiet then they are furry.
FOL: all x. (Big(x) & -Quiet(x) -> Furry(x))
TEXT: Gary is green.
FOL: Green(Gary)
Processed: Uncertain

Generation 3:
TEXT: Bob is not furry.
FOL: -Furry(Bob)

TEXT: Bob is quiet.
FOL: Quiet(Bob)

TEXT: Bob is not rough.
FOL: -Rough(Bob)

TEXT: Bob is not round.
FOL: -Round(Bob)

TEXT: Erin is not kind.
FOL: -Kind(Erin)

TEXT: Erin is rough.
FOL: Rough(Erin)

TEXT: Gary is big.
FOL: Big(Gary)

TEXT: Harry is furry.
FOL: Furry(Harry)

TEXT: Harry is green.
FOL: Green(Harry)

TEXT: Harry is not round.
FOL: -Round(Harry)

TEXT: All big, round people are rough.
FOL: all x. (Big(x) & Round(x) -> Rough(x))

TEXT: If someone is rough and not green then they are quiet.
FOL: all x. (Rough(x) & -Green(x) -> Quiet(x))

TEXT: If someone is round and rough then they are quiet.
FOL: all x. (Round(x) & Rough(x) -> Quiet(x))

TEXT: All big people are round.
FOL: all x. (Big(x) -> Round(x))

TEXT: All quiet people are kind.
FOL: all x. (Quiet(x) -> Kind(x))

TEXT: All rough, quiet people are big.
FOL: all x. (Rough(x) & Quiet(x) -> Big(x))

TEXT: If someone is round and kind then they are furry.
FOL: all x. (Round(x) & Kind(x) -> Furry(x))

TEXT: If someone is big and not quiet then they are furry.
FOL: all x. (Big(x) & -Quiet(x) -> Furry(x))

TEXT: Gary is green.
FOL: Green(Gary)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 8 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is big.
Bob is blue.
Bob is nice.
Bob is rough.
Bob is white.
Erin is blue.
Gary is kind.
Harry is kind.
Harry is nice.
Harry is white.
Blue things are rough.
All nice, white things are young.
If something is big then it is blue.
All blue, big things are nice.
Big, rough things are kind.
All white, rough things are big.
If something is young then it is blue.
If something is rough then it is white.
</PREMISES>
<CONCLUSION>
Gary is young.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is big.
FOL: Big(Bob)
TEXT: Bob is blue.
FOL: Blue(Bob)
TEXT: Bob is nice.
FOL: Nice(Bob)
TEXT: Bob is rough.
FOL: Rough(Bob)
TEXT: Bob is white.
FOL: White(Bob)
TEXT: Erin is blue.
FOL: Blue(Erin)
TEXT: Gary is kind.
FOL: Kind(Gary)
TEXT: Harry is kind.
FOL: Kind(Harry)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: Blue things are rough.
FOL: all x. (Blue(x) -> Rough(x))
TEXT: All nice, white things are young.
FOL: all x. ((Nice(x) & White(x)) -> Young(x))
TEXT: If something is big then it is blue.
FOL: all x. (Big(x) -> Blue(x))
TEXT: All blue, big things are nice.
FOL: all x. ((Blue(x) & Big(x)) -> Nice(x))
TEXT: Big, rough things are kind.
FOL: all x. ((Big(x) & Rough(x)) -> Kind(x))
TEXT: All white, rough things are big.
FOL: all x. ((White(x) & Rough(x)) -> Big(x))
TEXT: If something is young then it is blue.
FOL: all x. (Young(x) -> Blue(x))
TEXT: If something is rough then it is white.
FOL: all x. (Rough(x) -> White(x))
TEXT: Gary is young.
FOL: Young(Gary)
Processed: Uncertain

Generation 2:
TEXT: Bob is big.
FOL: Big(Bob)
TEXT: Bob is blue.
FOL: Blue(Bob)
TEXT: Bob is nice.
FOL: Nice(Bob)
TEXT: Bob is rough.
FOL: Rough(Bob)
TEXT: Bob is white.
FOL: White(Bob)
TEXT: Erin is blue.
FOL: Blue(Erin)
TEXT: Gary is kind.
FOL: Kind(Gary)
TEXT: Harry is kind.
FOL: Kind(Harry)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: Blue things are rough.
FOL: all x. (Blue(x) -> Rough(x))
TEXT: All nice, white things are young.
FOL: all x. (Nice(x) & White(x) -> Young(x))
TEXT: If something is big then it is blue.
FOL: all x. (Big(x) -> Blue(x))
TEXT: All blue, big things are nice.
FOL: all x. (Blue(x) & Big(x) -> Nice(x))
TEXT: Big, rough things are kind.
FOL: all x. (Big(x) & Rough(x) -> Kind(x))
TEXT: All white, rough things are big.
FOL: all x. (White(x) & Rough(x) -> Big(x))
TEXT: If something is young then it is blue.
FOL: all x. (Young(x) -> Blue(x))
TEXT: If something is rough then it is white.
FOL: all x. (Rough(x) -> White(x))
TEXT: Gary is young.
FOL: Young(Gary)
Processed: Uncertain

Generation 3:
TEXT: Bob is big.
FOL: Big(Bob)
TEXT: Bob is blue.
FOL: Blue(Bob)
TEXT: Bob is nice.
FOL: Nice(Bob)
TEXT: Bob is rough.
FOL: Rough(Bob)
TEXT: Bob is white.
FOL: White(Bob)
TEXT: Erin is blue.
FOL: Blue(Erin)
TEXT: Gary is kind.
FOL: Kind(Gary)
TEXT: Harry is kind.
FOL: Kind(Harry)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: Blue things are rough.
FOL: all x. (Blue(x) -> Rough(x))
TEXT: All nice, white things are young.
FOL: all x. ((Nice(x) & White(x)) -> Young(x))
TEXT: If something is big then it is blue.
FOL: all x. (Big(x) -> Blue(x))
TEXT: All blue, big things are nice.
FOL: all x. ((Blue(x) & Big(x)) -> Nice(x))
TEXT: Big, rough things are kind.
FOL: all x. ((Big(x) & Rough(x)) -> Kind(x))
TEXT: All white, rough things are big.
FOL: all x. ((White(x) & Rough(x)) -> Big(x))
TEXT: If something is young then it is blue.
FOL: all x. (Young(x) -> Blue(x))
TEXT: If something is rough then it is white.
FOL: all x. (Rough(x) -> White(x))
TEXT: Gary is young.
FOL: Young(Gary)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 9 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is nice.
Dave is nice.
Dave is rough.
Gary is nice.
Gary is not smart.
Harry is big.
Harry is round.
All white people are round.
If Dave is big then Dave is white.
All cold, round people are rough.
Smart, white people are cold.
If Dave is round and Dave is big then Dave is smart.
If someone is nice then they are big.
All rough, white people are nice.
</PREMISES>
<CONCLUSION>
Dave is white.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Dave is nice.
FOL: Nice(Dave)
TEXT: Dave is rough.
FOL: Rough(Dave)
TEXT: Gary is nice.
FOL: Nice(Gary)
TEXT: Gary is not smart.
FOL: -Smart(Gary)
TEXT: Harry is big.
FOL: Big(Harry)
TEXT: Harry is round.
FOL: Round(Harry)
TEXT: All white people are round.
FOL: all x. (White(x) -> Round(x))
TEXT: If Dave is big then Dave is white.
FOL: Big(Dave) -> White(Dave)
TEXT: All cold, round people are rough.
FOL: all x. (Cold(x) & Round(x) -> Rough(x))
TEXT: Smart, white people are cold.
FOL: all x. (Smart(x) & White(x) -> Cold(x))
TEXT: If Dave is round and Dave is big then Dave is smart.
FOL: (Round(Dave) & Big(Dave)) -> Smart(Dave)
TEXT: If someone is nice then they are big.
FOL: all x. (Nice(x) -> Big(x))
TEXT: All rough, white people are nice.
FOL: all x. (Rough(x) & White(x) -> Nice(x))
TEXT: Dave is white.
FOL: White(Dave)
Processed: True

Generation 2:
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Dave is nice.
FOL: Nice(Dave)
TEXT: Dave is rough.
FOL: Rough(Dave)
TEXT: Gary is nice.
FOL: Nice(Gary)
TEXT: Gary is not smart.
FOL: -Smart(Gary)
TEXT: Harry is big.
FOL: Big(Harry)
TEXT: Harry is round.
FOL: Round(Harry)
TEXT: All white people are round.
FOL: all x. (White(x) -> Round(x))
TEXT: If Dave is big then Dave is white.
FOL: Big(Dave) -> White(Dave)
TEXT: All cold, round people are rough.
FOL: all x. (Cold(x) & Round(x) -> Rough(x))
TEXT: Smart, white people are cold.
FOL: all x. (Smart(x) & White(x) -> Cold(x))
TEXT: If Dave is round and Dave is big then Dave is smart.
FOL: (Round(Dave) & Big(Dave)) -> Smart(Dave)
TEXT: If someone is nice then they are big.
FOL: all x. (Nice(x) -> Big(x))
TEXT: All rough, white people are nice.
FOL: all x. (Rough(x) & White(x) -> Nice(x))
TEXT: Dave is white.
FOL: White(Dave)
</EVALUATE>
Processed: True

Generation 3:
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Dave is nice.
FOL: Nice(Dave)
TEXT: Dave is rough.
FOL: Rough(Dave)
TEXT: Gary is nice.
FOL: Nice(Gary)
TEXT: Gary is not smart.
FOL: -Smart(Gary)
TEXT: Harry is big.
FOL: Big(Harry)
TEXT: Harry is round.
FOL: Round(Harry)
TEXT: All white people are round.
FOL: all x. (White(x) -> Round(x))
TEXT: If Dave is big then Dave is white.
FOL: Big(Dave) -> White(Dave)
TEXT: All cold, round people are rough.
FOL: all x. (Cold(x) & Round(x) -> Rough(x))
TEXT: Smart, white people are cold.
FOL: all x. (Smart(x) & White(x) -> Cold(x))
TEXT: If Dave is round and Dave is big then Dave is smart.
FOL: (Round(Dave) & Big(Dave)) -> Smart(Dave)
TEXT: If someone is nice then they are big.
FOL: all x. (Nice(x) -> Big(x))
TEXT: All rough, white people are nice.
FOL: all x. (Rough(x) & White(x) -> Nice(x))
TEXT: Dave is white.
FOL: White(Dave)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 10 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle is not blue.
The bald eagle likes the dog.
The bald eagle needs the tiger.
The bald eagle does not see the dog.
The bald eagle sees the tiger.
The dog is blue.
The dog sees the tiger.
The rabbit is green.
The rabbit is red.
The rabbit sees the dog.
The tiger needs the bald eagle.
The tiger needs the dog.
If someone needs the bald eagle and the bald eagle sees the tiger then they are rough.
If someone needs the dog and they like the dog then they need the bald eagle.
If someone likes the bald eagle then the bald eagle needs the dog.
If someone is rough and they like the dog then the dog needs the tiger.
If someone likes the dog and the dog is blue then they see the tiger.
If someone needs the tiger and they do not see the dog then the tiger needs the bald eagle.
If someone needs the bald eagle then they like the bald eagle.
</PREMISES>
<CONCLUSION>
The tiger does not need the rabbit.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle is not blue.
FOL: -Blue(BaldEagle)

TEXT: The bald eagle likes the dog.
FOL: Likes(BaldEagle, Dog)

TEXT: The bald eagle needs the tiger.
FOL: Needs(BaldEagle, Tiger)

TEXT: The bald eagle does not see the dog.
FOL: -Sees(BaldEagle, Dog)

TEXT: The bald eagle sees the tiger.
FOL: Sees(BaldEagle, Tiger)

TEXT: The dog is blue.
FOL: Blue(Dog)

TEXT: The dog sees the tiger.
FOL: Sees(Dog, Tiger)

TEXT: The rabbit is green.
FOL: Green(Rabbit)

TEXT: The rabbit is red.
FOL: Red(Rabbit)

TEXT: The rabbit sees the dog.
FOL: Sees(Rabbit, Dog)

TEXT: The tiger needs the bald eagle.
FOL: Needs(Tiger, BaldEagle)

TEXT: The tiger needs the dog.
FOL: Needs(Tiger, Dog)

TEXT: If someone needs the bald eagle and the bald eagle sees the tiger then they are rough.
FOL: all x. ((Needs(x, BaldEagle) & Sees(BaldEagle, Tiger)) -> Rough(x))

TEXT: If someone needs the dog and they like the dog then they need the bald eagle.
FOL: all x. ((Needs(x, Dog) & Likes(x, Dog)) -> Needs(x, BaldEagle))

TEXT: If someone likes the bald eagle then the bald eagle needs the dog.
FOL: all x. (Likes(x, BaldEagle) -> Needs(BaldEagle, Dog))

TEXT: If someone is rough and they like the dog then the dog needs the tiger.
FOL: all x. ((Rough(x) & Likes(x, Dog)) -> Needs(Dog, Tiger))

TEXT: If someone likes the dog and the dog is blue then they see the tiger.
FOL: all x. ((Likes(x, Dog) & Blue(Dog)) -> Sees(x, Tiger))

TEXT: If someone needs the tiger and they do not see the dog then the tiger needs the bald eagle.
FOL: all x. ((Needs(x, Tiger) & -Sees(x, Dog)) -> Needs(Tiger, BaldEagle))

TEXT: If someone needs the bald eagle then they like the bald eagle.
FOL: all x. (Needs(x, BaldEagle) -> Likes(x, BaldEagle))

TEXT: The tiger does not need the rabbit.
FOL: -Needs(Tiger, Rabbit)
Processed: Uncertain

Generation 2:
TEXT: The bald eagle is not blue.
FOL: -Color(bald_eagle, Blue)
TEXT: The bald eagle likes the dog.
FOL: Likes(bald_eagle, dog)
TEXT: The bald eagle needs the tiger.
FOL: Needs(bald_eagle, tiger)
TEXT: The bald eagle does not see the dog.
FOL: -Sees(bald_eagle, dog)
TEXT: The bald eagle sees the tiger.
FOL: Sees(bald_eagle, tiger)
TEXT: The dog is blue.
FOL: Color(dog, Blue)
TEXT: The dog sees the tiger.
FOL: Sees(dog, tiger)
TEXT: The rabbit is green.
FOL: Color(rabbit, Green)
TEXT: The rabbit is red.
FOL: Color(rabbit, Red)
TEXT: The rabbit sees the dog.
FOL: Sees(rabbit, dog)
TEXT: The tiger needs the bald eagle.
FOL: Needs(tiger, bald_eagle)
TEXT: The tiger needs the dog.
FOL: Needs(tiger, dog)
TEXT: If someone needs the bald eagle and the bald eagle sees the tiger then they are rough.
FOL: all x. (Needs(x, bald_eagle) & Sees(bald_eagle, tiger) -> Rough(x))
TEXT: If someone needs the dog and they like the dog then they need the bald eagle.
FOL: all x. (Needs(x, dog) & Likes(x, dog) -> Needs(x, bald_eagle))
TEXT: If someone likes the bald eagle then the bald eagle needs the dog.
FOL: all x. (Likes(x, bald_eagle) -> Needs(bald_eagle, dog))
TEXT: If someone is rough and they like the dog then the dog needs the tiger.
FOL: all x. (Rough(x) & Likes(x, dog) -> Needs(dog, tiger))
TEXT: If someone likes the dog and the dog is blue then they see the tiger.
FOL: all x. (Likes(x, dog) & Color(dog, Blue) -> Sees(x, tiger))
TEXT: If someone needs the tiger and they do not see the dog then the tiger needs the bald eagle.
FOL: all x. (Needs(x, tiger) & -Sees(x, dog) -> Needs(tiger, bald_eagle))
TEXT: If someone needs the bald eagle then they like the bald eagle.
FOL: all x. (Needs(x, bald_eagle) -> Likes(x, bald_eagle))
TEXT: The tiger does not need the rabbit.
FOL: -Needs(tiger, rabbit)
Processed: Uncertain

Generation 3:
TEXT: The bald eagle is not blue.
FOL: -IsColor(BaldEagle, Blue)

TEXT: The bald eagle likes the dog.
FOL: Likes(BaldEagle, Dog)

TEXT: The bald eagle needs the tiger.
FOL: Needs(BaldEagle, Tiger)

TEXT: The bald eagle does not see the dog.
FOL: -Sees(BaldEagle, Dog)

TEXT: The bald eagle sees the tiger.
FOL: Sees(BaldEagle, Tiger)

TEXT: The dog is blue.
FOL: IsColor(Dog, Blue)

TEXT: The dog sees the tiger.
FOL: Sees(Dog, Tiger)

TEXT: The rabbit is green.
FOL: IsColor(Rabbit, Green)

TEXT: The rabbit is red.
FOL: IsColor(Rabbit, Red)

TEXT: The rabbit sees the dog.
FOL: Sees(Rabbit, Dog)

TEXT: The tiger needs the bald eagle.
FOL: Needs(Tiger, BaldEagle)

TEXT: The tiger needs the dog.
FOL: Needs(Tiger, Dog)

TEXT: If someone needs the bald eagle and the bald eagle sees the tiger then they are rough.
FOL: all x. (Needs(x, BaldEagle) & Sees(BaldEagle, Tiger) -> Rough(x))

TEXT: If someone needs the dog and they like the dog then they need the bald eagle.
FOL: all x. (Needs(x, Dog) & Likes(x, Dog) -> Needs(x, BaldEagle))

TEXT: If someone likes the bald eagle then the bald eagle needs the dog.
FOL: all x. (Likes(x, BaldEagle) -> Needs(BaldEagle, Dog))

TEXT: If someone is rough and they like the dog then the dog needs the tiger.
FOL: all x. (Rough(x) & Likes(x, Dog) -> Needs(Dog, Tiger))

TEXT: If someone likes the dog and the dog is blue then they see the tiger.
FOL: all x. (Likes(x, Dog) & IsColor(Dog, Blue) -> Sees(x, Tiger))

TEXT: If someone needs the tiger and they do not see the dog then the tiger needs the bald eagle.
FOL: all x. (Needs(x, Tiger) & -Sees(x, Dog) -> Needs(Tiger, BaldEagle))

TEXT: If someone needs the bald eagle then they like the bald eagle.
FOL: all x. (Needs(x, BaldEagle) -> Likes(x, BaldEagle))

TEXT: The tiger does not need the rabbit.
FOL: -Needs(Tiger, Rabbit)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 11 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle sees the cat.
The cat is round.
The cat needs the rabbit.
The cat sees the lion.
The cat visits the lion.
The lion is big.
The lion is cold.
The lion is nice.
The lion visits the rabbit.
The rabbit is nice.
The rabbit is round.
The rabbit sees the cat.
If something is nice then it is big.
If something is kind and it sees the rabbit then it needs the lion.
If something needs the rabbit then it is nice.
All cold, big things are kind.
If something sees the bald eagle and the bald eagle is nice then it needs the rabbit.
If something sees the lion then it visits the rabbit.
If the bald eagle sees the cat then the bald eagle visits the rabbit.
If something visits the rabbit then it needs the rabbit.
If something is big then it is cold.
</PREMISES>
<CONCLUSION>
The rabbit does not visit the bald eagle.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle sees the cat.
FOL: Sees(BaldEagle, Cat)

TEXT: The cat is round.
FOL: Round(Cat)

TEXT: The cat needs the rabbit.
FOL: Needs(Cat, Rabbit)

TEXT: The cat sees the lion.
FOL: Sees(Cat, Lion)

TEXT: The cat visits the lion.
FOL: Visits(Cat, Lion)

TEXT: The lion is big.
FOL: Big(Lion)

TEXT: The lion is cold.
FOL: Cold(Lion)

TEXT: The lion is nice.
FOL: Nice(Lion)

TEXT: The lion visits the rabbit.
FOL: Visits(Lion, Rabbit)

TEXT: The rabbit is nice.
FOL: Nice(Rabbit)

TEXT: The rabbit is round.
FOL: Round(Rabbit)

TEXT: The rabbit sees the cat.
FOL: Sees(Rabbit, Cat)

TEXT: If something is nice then it is big.
FOL: all x. (Nice(x) -> Big(x))

TEXT: If something is kind and it sees the rabbit then it needs the lion.
FOL: all x. (Kind(x) & Sees(x, Rabbit) -> Needs(x, Lion))

TEXT: If something needs the rabbit then it is nice.
FOL: all x. (Needs(x, Rabbit) -> Nice(x))

TEXT: All cold, big things are kind.
FOL: all x. (Cold(x) & Big(x) -> Kind(x))

TEXT: If something sees the bald eagle and the bald eagle is nice then it needs the rabbit.
FOL: all x. (Sees(x, BaldEagle) & Nice(BaldEagle) -> Needs(x, Rabbit))

TEXT: If something sees the lion then it visits the rabbit.
FOL: all x. (Sees(x, Lion) -> Visits(x, Rabbit))

TEXT: If the bald eagle sees the cat then the bald eagle visits the rabbit.
FOL: (Sees(BaldEagle, Cat) -> Visits(BaldEagle, Rabbit))

TEXT: If something visits the rabbit then it needs the rabbit.
FOL: all x. (Visits(x, Rabbit) -> Needs(x, Rabbit))

TEXT: If something is big then it is cold.
FOL: all x. (Big(x) -> Cold(x))

TEXT: The rabbit does not visit the bald eagle.
FOL: -Visits(Rabbit, BaldEagle)
Processed: Uncertain

Generation 2:
TEXT: The bald eagle sees the cat.
FOL: Sees(BaldEagle, Cat)

TEXT: The cat is round.
FOL: Round(Cat)

TEXT: The cat needs the rabbit.
FOL: Needs(Cat, Rabbit)

TEXT: The cat sees the lion.
FOL: Sees(Cat, Lion)

TEXT: The cat visits the lion.
FOL: Visits(Cat, Lion)

TEXT: The lion is big.
FOL: Big(Lion)

TEXT: The lion is cold.
FOL: Cold(Lion)

TEXT: The lion is nice.
FOL: Nice(Lion)

TEXT: The lion visits the rabbit.
FOL: Visits(Lion, Rabbit)

TEXT: The rabbit is nice.
FOL: Nice(Rabbit)

TEXT: The rabbit is round.
FOL: Round(Rabbit)

TEXT: The rabbit sees the cat.
FOL: Sees(Rabbit, Cat)

TEXT: If something is nice then it is big.
FOL: all x. (Nice(x) -> Big(x))

TEXT: If something is kind and it sees the rabbit then it needs the lion.
FOL: all x. (Kind(x) & Sees(x, Rabbit) -> Needs(x, Lion))

TEXT: If something needs the rabbit then it is nice.
FOL: all x. (Needs(x, Rabbit) -> Nice(x))

TEXT: All cold, big things are kind.
FOL: all x. (Cold(x) & Big(x) -> Kind(x))

TEXT: If something sees the bald eagle and the bald eagle is nice then it needs the rabbit.
FOL: all x. (Sees(x, BaldEagle) & Nice(BaldEagle) -> Needs(x, Rabbit))

TEXT: If something sees the lion then it visits the rabbit.
FOL: all x. (Sees(x, Lion) -> Visits(x, Rabbit))

TEXT: If the bald eagle sees the cat then the bald eagle visits the rabbit.
FOL: (Sees(BaldEagle, Cat) -> Visits(BaldEagle, Rabbit))

TEXT: If something visits the rabbit then it needs the rabbit.
FOL: all x. (Visits(x, Rabbit) -> Needs(x, Rabbit))

TEXT: If something is big then it is cold.
FOL: all x. (Big(x) -> Cold(x))

TEXT: The rabbit does not visit the bald eagle.
FOL: -Visits(Rabbit, BaldEagle)
Processed: Uncertain

Generation 3:
TEXT: The bald eagle sees the cat.
FOL: Sees(BaldEagle, Cat)
TEXT: The cat is round.
FOL: Round(Cat)
TEXT: The cat needs the rabbit.
FOL: Needs(Cat, Rabbit)
TEXT: The cat sees the lion.
FOL: Sees(Cat, Lion)
TEXT: The cat visits the lion.
FOL: Visits(Cat, Lion)
TEXT: The lion is big.
FOL: Big(Lion)
TEXT: The lion is cold.
FOL: Cold(Lion)
TEXT: The lion is nice.
FOL: Nice(Lion)
TEXT: The lion visits the rabbit.
FOL: Visits(Lion, Rabbit)
TEXT: The rabbit is nice.
FOL: Nice(Rabbit)
TEXT: The rabbit is round.
FOL: Round(Rabbit)
TEXT: The rabbit sees the cat.
FOL: Sees(Rabbit, Cat)
TEXT: If something is nice then it is big.
FOL: all x. (Nice(x) -> Big(x))
TEXT: If something is kind and it sees the rabbit then it needs the lion.
FOL: all x. ((Kind(x) & Sees(x, Rabbit)) -> Needs(x, Lion))
TEXT: If something needs the rabbit then it is nice.
FOL: all x. (Needs(x, Rabbit) -> Nice(x))
TEXT: All cold, big things are kind.
FOL: all x. ((Cold(x) & Big(x)) -> Kind(x))
TEXT: If something sees the bald eagle and the bald eagle is nice then it needs the rabbit.
FOL: all x. ((Sees(x, BaldEagle) & Nice(BaldEagle)) -> Needs(x, Rabbit))
TEXT: If something sees the lion then it visits the rabbit.
FOL: all x. (Sees(x, Lion) -> Visits(x, Rabbit))
TEXT: If the bald eagle sees the cat then the bald eagle visits the rabbit.
FOL: (Sees(BaldEagle, Cat) -> Visits(BaldEagle, Rabbit))
TEXT: If something visits the rabbit then it needs the rabbit.
FOL: all x. (Visits(x, Rabbit) -> Needs(x, Rabbit))
TEXT: If something is big then it is cold.
FOL: all x. (Big(x) -> Cold(x))
TEXT: The rabbit does not visit the bald eagle.
FOL: -Visits(Rabbit, BaldEagle)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 12 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Charlie is not red.
Erin is big.
Erin is not red.
Erin is not white.
Fiona is nice.
Harry is not cold.
Harry is white.
Cold people are not big.
If Erin is big then Erin is not green.
Nice people are quiet.
If someone is green and quiet then they are white.
All white people are not cold.
If Erin is nice then Erin is white.
All quiet people are green.
If someone is quiet and not cold then they are red.
</PREMISES>
<CONCLUSION>
Fiona is cold.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Charlie is not red.
FOL: -Red(Charlie)
TEXT: Erin is big.
FOL: Big(Erin)
TEXT: Erin is not red.
FOL: -Red(Erin)
TEXT: Erin is not white.
FOL: -White(Erin)
TEXT: Fiona is nice.
FOL: Nice(Fiona)
TEXT: Harry is not cold.
FOL: -Cold(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: Cold people are not big.
FOL: all x. (Cold(x) -> -Big(x))
TEXT: If Erin is big then Erin is not green.
FOL: Big(Erin) -> -Green(Erin)
TEXT: Nice people are quiet.
FOL: all x. (Nice(x) -> Quiet(x))
TEXT: If someone is green and quiet then they are white.
FOL: all x. ((Green(x) & Quiet(x)) -> White(x))
TEXT: All white people are not cold.
FOL: all x. (White(x) -> -Cold(x))
TEXT: If Erin is nice then Erin is white.
FOL: Nice(Erin) -> White(Erin)
TEXT: All quiet people are green.
FOL: all x. (Quiet(x) -> Green(x))
TEXT: If someone is quiet and not cold then they are red.
FOL: all x. ((Quiet(x) & -Cold(x)) -> Red(x))
TEXT: Fiona is cold.
FOL: Cold(Fiona)
Processed: False

Generation 2:
TEXT: Charlie is not red.
FOL: -Red(Charlie)
TEXT: Erin is big.
FOL: Big(Erin)
TEXT: Erin is not red.
FOL: -Red(Erin)
TEXT: Erin is not white.
FOL: -White(Erin)
TEXT: Fiona is nice.
FOL: Nice(Fiona)
TEXT: Harry is not cold.
FOL: -Cold(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: Cold people are not big.
FOL: all x. (Cold(x) -> -Big(x))
TEXT: If Erin is big then Erin is not green.
FOL: Big(Erin) -> -Green(Erin)
TEXT: Nice people are quiet.
FOL: all x. (Nice(x) -> Quiet(x))
TEXT: If someone is green and quiet then they are white.
FOL: all x. (Green(x) & Quiet(x) -> White(x))
TEXT: All white people are not cold.
FOL: all x. (White(x) -> -Cold(x))
TEXT: If Erin is nice then Erin is white.
FOL: Nice(Erin) -> White(Erin)
TEXT: All quiet people are green.
FOL: all x. (Quiet(x) -> Green(x))
TEXT: If someone is quiet and not cold then they are red.
FOL: all x. (Quiet(x) & -Cold(x) -> Red(x))
TEXT: Fiona is cold.
FOL: Cold(Fiona)
Processed: False

Generation 3:
TEXT: Charlie is not red.
FOL: -Red(Charlie)
TEXT: Erin is big.
FOL: Big(Erin)
TEXT: Erin is not red.
FOL: -Red(Erin)
TEXT: Erin is not white.
FOL: -White(Erin)
TEXT: Fiona is nice.
FOL: Nice(Fiona)
TEXT: Harry is not cold.
FOL: -Cold(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: Cold people are not big.
FOL: all x. (Cold(x) -> -Big(x))
TEXT: If Erin is big then Erin is not green.
FOL: (Big(Erin) -> -Green(Erin))
TEXT: Nice people are quiet.
FOL: all x. (Nice(x) -> Quiet(x))
TEXT: If someone is green and quiet then they are white.
FOL: all x. ((Green(x) & Quiet(x)) -> White(x))
TEXT: All white people are not cold.
FOL: all x. (White(x) -> -Cold(x))
TEXT: If Erin is nice then Erin is white.
FOL: (Nice(Erin) -> White(Erin))
TEXT: All quiet people are green.
FOL: all x. (Quiet(x) -> Green(x))
TEXT: If someone is quiet and not cold then they are red.
FOL: all x. ((Quiet(x) & -Cold(x)) -> Red(x))
TEXT: Fiona is cold.
FOL: Cold(Fiona)
Processed: False

Reference: False
========================================

=== Example 13 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The cat eats the dog.
The cat eats the rabbit.
The cat eats the squirrel.
The cat is red.
The cat sees the dog.
The cat sees the rabbit.
The cat does not see the squirrel.
The dog eats the cat.
The dog eats the squirrel.
The dog likes the rabbit.
The dog likes the squirrel.
The rabbit likes the dog.
The rabbit likes the squirrel.
The rabbit sees the squirrel.
The squirrel is round.
The squirrel sees the rabbit.
If someone is big then they like the cat.
If someone is round then they are big.
If someone eats the squirrel and the squirrel eats the dog then they eat the dog.
If someone eats the cat then they are round.
If the cat is green and the cat eats the rabbit then the cat is big.
If someone likes the rabbit and the rabbit sees the cat then the rabbit likes the dog.
If someone eats the squirrel and they eat the dog then the dog is red.
If someone is big and they see the rabbit then the rabbit eats the cat.
If the cat eats the squirrel then the squirrel does not eat the cat.
</PREMISES>
<CONCLUSION>
The dog is round.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The cat eats the dog.
FOL: Eats(Cat, Dog)
TEXT: The cat eats the rabbit.
FOL: Eats(Cat, Rabbit)
TEXT: The cat eats the squirrel.
FOL: Eats(Cat, Squirrel)
TEXT: The cat is red.
FOL: IsRed(Cat)
TEXT: The cat sees the dog.
FOL: Sees(Cat, Dog)
TEXT: The cat sees the rabbit.
FOL: Sees(Cat, Rabbit)
TEXT: The cat does not see the squirrel.
FOL: -Sees(Cat, Squirrel)
TEXT: The dog eats the cat.
FOL: Eats(Dog, Cat)
TEXT: The dog eats the squirrel.
FOL: Eats(Dog, Squirrel)
TEXT: The dog likes the rabbit.
FOL: Likes(Dog, Rabbit)
TEXT: The dog likes the squirrel.
FOL: Likes(Dog, Squirrel)
TEXT: The rabbit likes the dog.
FOL: Likes(Rabbit, Dog)
TEXT: The rabbit likes the squirrel.
FOL: Likes(Rabbit, Squirrel)
TEXT: The rabbit sees the squirrel.
FOL: Sees(Rabbit, Squirrel)
TEXT: The squirrel is round.
FOL: IsRound(Squirrel)
TEXT: The squirrel sees the rabbit.
FOL: Sees(Squirrel, Rabbit)
TEXT: If someone is big then they like the cat.
FOL: all x. (Big(x) -> Likes(x, Cat))
TEXT: If someone is round then they are big.
FOL: all x. (IsRound(x) -> Big(x))
TEXT: If someone eats the squirrel and the squirrel eats the dog then they eat the dog.
FOL: all x. (Eats(x, Squirrel) & Eats(Squirrel, Dog) -> Eats(x, Dog))
TEXT: If someone eats the cat then they are round.
FOL: all x. (Eats(x, Cat) -> IsRound(x))
TEXT: If the cat is green and the cat eats the rabbit then the cat is big.
FOL: (IsGreen(Cat) & Eats(Cat, Rabbit)) -> Big(Cat)
TEXT: If someone likes the rabbit and the rabbit sees the cat then the rabbit likes the dog.
FOL: all x. (Likes(x, Rabbit) & Sees(Rabbit, Cat) -> Likes(Rabbit, Dog))
TEXT: If someone eats the squirrel and they eat the dog then the dog is red.
FOL: all x. (Eats(x, Squirrel) & Eats(x, Dog) -> IsRed(Dog))
TEXT: If someone is big and they see the rabbit then the rabbit eats the cat.
FOL: all x. (Big(x) & Sees(x, Rabbit) -> Eats(Rabbit, Cat))
TEXT: If the cat eats the squirrel then the squirrel does not eat the cat.
FOL: Eats(Cat, Squirrel) -> -Eats(Squirrel, Cat)
TEXT: The dog is round.
FOL: IsRound(Dog)
Processed: True

Generation 2:
TEXT: The cat eats the dog.
FOL: Eats(Cat, Dog)
TEXT: The cat eats the rabbit.
FOL: Eats(Cat, Rabbit)
TEXT: The cat eats the squirrel.
FOL: Eats(Cat, Squirrel)
TEXT: The cat is red.
FOL: Color(Cat, Red)
TEXT: The cat sees the dog.
FOL: Sees(Cat, Dog)
TEXT: The cat sees the rabbit.
FOL: Sees(Cat, Rabbit)
TEXT: The cat does not see the squirrel.
FOL: -Sees(Cat, Squirrel)
TEXT: The dog eats the cat.
FOL: Eats(Dog, Cat)
TEXT: The dog eats the squirrel.
FOL: Eats(Dog, Squirrel)
TEXT: The dog likes the rabbit.
FOL: Likes(Dog, Rabbit)
TEXT: The dog likes the squirrel.
FOL: Likes(Dog, Squirrel)
TEXT: The rabbit likes the dog.
FOL: Likes(Rabbit, Dog)
TEXT: The rabbit likes the squirrel.
FOL: Likes(Rabbit, Squirrel)
TEXT: The rabbit sees the squirrel.
FOL: Sees(Rabbit, Squirrel)
TEXT: The squirrel is round.
FOL: Shape(Squirrel, Round)
TEXT: The squirrel sees the rabbit.
FOL: Sees(Squirrel, Rabbit)
TEXT: If someone is big then they like the cat.
FOL: all x. (Big(x) -> Likes(x, Cat))
TEXT: If someone is round then they are big.
FOL: all x. (Shape(x, Round) -> Big(x))
TEXT: If someone eats the squirrel and the squirrel eats the dog then they eat the dog.
FOL: all x. ((Eats(x, Squirrel) & Eats(Squirrel, Dog)) -> Eats(x, Dog))
TEXT: If someone eats the cat then they are round.
FOL: all x. (Eats(x, Cat) -> Shape(x, Round))
TEXT: If the cat is green and the cat eats the rabbit then the cat is big.
FOL: (Color(Cat, Green) & Eats(Cat, Rabbit)) -> Big(Cat)
TEXT: If someone likes the rabbit and the rabbit sees the cat then the rabbit likes the dog.
FOL: all x. ((Likes(x, Rabbit) & Sees(Rabbit, Cat)) -> Likes(Rabbit, Dog))
TEXT: If someone eats the squirrel and they eat the dog then the dog is red.
FOL: all x. ((Eats(x, Squirrel) & Eats(x, Dog)) -> Color(Dog, Red))
TEXT: If someone is big and they see the rabbit then the rabbit eats the cat.
FOL: all x. ((Big(x) & Sees(x, Rabbit)) -> Eats(Rabbit, Cat))
TEXT: If the cat eats the squirrel then the squirrel does not eat the cat.
FOL: (Eats(Cat, Squirrel) -> -Eats(Squirrel, Cat))
TEXT: The dog is round.
FOL: Shape(Dog, Round)
Processed: True

Generation 3:
TEXT: The cat eats the dog.
FOL: Eats(Cat, Dog)
TEXT: The cat eats the rabbit.
FOL: Eats(Cat, Rabbit)
TEXT: The cat eats the squirrel.
FOL: Eats(Cat, Squirrel)
TEXT: The cat is red.
FOL: Red(Cat)
TEXT: The cat sees the dog.
FOL: Sees(Cat, Dog)
TEXT: The cat sees the rabbit.
FOL: Sees(Cat, Rabbit)
TEXT: The cat does not see the squirrel.
FOL: -Sees(Cat, Squirrel)
TEXT: The dog eats the cat.
FOL: Eats(Dog, Cat)
TEXT: The dog eats the squirrel.
FOL: Eats(Dog, Squirrel)
TEXT: The dog likes the rabbit.
FOL: Likes(Dog, Rabbit)
TEXT: The dog likes the squirrel.
FOL: Likes(Dog, Squirrel)
TEXT: The rabbit likes the dog.
FOL: Likes(Rabbit, Dog)
TEXT: The rabbit likes the squirrel.
FOL: Likes(Rabbit, Squirrel)
TEXT: The rabbit sees the squirrel.
FOL: Sees(Rabbit, Squirrel)
TEXT: The squirrel is round.
FOL: Round(Squirrel)
TEXT: The squirrel sees the rabbit.
FOL: Sees(Squirrel, Rabbit)
TEXT: If someone is big then they like the cat.
FOL: all x. (Big(x) -> Likes(x, Cat))
TEXT: If someone is round then they are big.
FOL: all x. (Round(x) -> Big(x))
TEXT: If someone eats the squirrel and the squirrel eats the dog then they eat the dog.
FOL: all x. ((Eats(x, Squirrel) & Eats(Squirrel, Dog)) -> Eats(x, Dog))
TEXT: If someone eats the cat then they are round.
FOL: all x. (Eats(x, Cat) -> Round(x))
TEXT: If the cat is green and the cat eats the rabbit then the cat is big.
FOL: (Green(Cat) & Eats(Cat, Rabbit)) -> Big(Cat)
TEXT: If someone likes the rabbit and the rabbit sees the cat then the rabbit likes the dog.
FOL: all x. ((Likes(x, Rabbit) & Sees(Rabbit, Cat)) -> Likes(Rabbit, Dog))
TEXT: If someone eats the squirrel and they eat the dog then the dog is red.
FOL: all x. ((Eats(x, Squirrel) & Eats(x, Dog)) -> Red(Dog))
TEXT: If someone is big and they see the rabbit then the rabbit eats the cat.
FOL: all x. ((Big(x) & Sees(x, Rabbit)) -> Eats(Rabbit, Cat))
TEXT: If the cat eats the squirrel then the squirrel does not eat the cat.
FOL: (Eats(Cat, Squirrel) -> -Eats(Squirrel, Cat))
TEXT: The dog is round.
FOL: Round(Dog)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 14 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is nice.
Anne is white.
Charlie is round.
Charlie is white.
Erin is not nice.
Erin is quiet.
Gary is not quiet.
Blue people are big.
If someone is white then they are green.
If Anne is quiet then Anne is blue.
If Anne is green then Anne is quiet.
Blue people are quiet.
If Anne is white and Anne is not blue then Anne is nice.
Big people are round.
If someone is big and not nice then they are round.
</PREMISES>
<CONCLUSION>
Anne is green.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Anne is white.
FOL: White(Anne)
TEXT: Charlie is round.
FOL: Round(Charlie)
TEXT: Charlie is white.
FOL: White(Charlie)
TEXT: Erin is not nice.
FOL: -Nice(Erin)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Gary is not quiet.
FOL: -Quiet(Gary)
TEXT: Blue people are big.
FOL: all x. (Blue(x) -> Big(x))
TEXT: If someone is white then they are green.
FOL: all x. (White(x) -> Green(x))
TEXT: If Anne is quiet then Anne is blue.
FOL: Quiet(Anne) -> Blue(Anne)
TEXT: If Anne is green then Anne is quiet.
FOL: Green(Anne) -> Quiet(Anne)
TEXT: Blue people are quiet.
FOL: all x. (Blue(x) -> Quiet(x))
TEXT: If Anne is white and Anne is not blue then Anne is nice.
FOL: (White(Anne) & -Blue(Anne)) -> Nice(Anne)
TEXT: Big people are round.
FOL: all x. (Big(x) -> Round(x))
TEXT: If someone is big and not nice then they are round.
FOL: all x. (Big(x) & -Nice(x) -> Round(x))
TEXT: Anne is green.
FOL: Green(Anne)
Processed: True

Generation 2:
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Anne is white.
FOL: White(Anne)
TEXT: Charlie is round.
FOL: Round(Charlie)
TEXT: Charlie is white.
FOL: White(Charlie)
TEXT: Erin is not nice.
FOL: -Nice(Erin)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Gary is not quiet.
FOL: -Quiet(Gary)
TEXT: Blue people are big.
FOL: all x. (Blue(x) -> Big(x))
TEXT: If someone is white then they are green.
FOL: all x. (White(x) -> Green(x))
TEXT: If Anne is quiet then Anne is blue.
FOL: Quiet(Anne) -> Blue(Anne)
TEXT: If Anne is green then Anne is quiet.
FOL: Green(Anne) -> Quiet(Anne)
TEXT: Blue people are quiet.
FOL: all x. (Blue(x) -> Quiet(x))
TEXT: If Anne is white and Anne is not blue then Anne is nice.
FOL: (White(Anne) & -Blue(Anne)) -> Nice(Anne)
TEXT: Big people are round.
FOL: all x. (Big(x) -> Round(x))
TEXT: If someone is big and not nice then they are round.
FOL: all x. ((Big(x) & -Nice(x)) -> Round(x))
TEXT: Anne is green.
FOL: Green(Anne)
</EVALUATE>
Processed: True

Generation 3:
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Anne is white.
FOL: White(Anne)
TEXT: Charlie is round.
FOL: Round(Charlie)
TEXT: Charlie is white.
FOL: White(Charlie)
TEXT: Erin is not nice.
FOL: -Nice(Erin)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Gary is not quiet.
FOL: -Quiet(Gary)
TEXT: Blue people are big.
FOL: all x. (Blue(x) -> Big(x))
TEXT: If someone is white then they are green.
FOL: all x. (White(x) -> Green(x))
TEXT: If Anne is quiet then Anne is blue.
FOL: Quiet(Anne) -> Blue(Anne)
TEXT: If Anne is green then Anne is quiet.
FOL: Green(Anne) -> Quiet(Anne)
TEXT: Blue people are quiet.
FOL: all x. (Blue(x) -> Quiet(x))
TEXT: If Anne is white and Anne is not blue then Anne is nice.
FOL: (White(Anne) & -Blue(Anne)) -> Nice(Anne)
TEXT: Big people are round.
FOL: all x. (Big(x) -> Round(x))
TEXT: If someone is big and not nice then they are round.
FOL: all x. ((Big(x) & -Nice(x)) -> Round(x))
TEXT: Anne is green.
FOL: Green(Anne)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 15 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is furry.
Charlie is blue.
Charlie is smart.
Dave is not blue.
Dave is green.
Erin is not blue.
Erin is red.
If something is smart and not blue then it is not cold.
If something is furry then it is kind.
Blue, smart things are kind.
All kind things are smart.
If something is blue then it is furry.
All red things are furry.
Red things are furry.
Blue, kind things are red.
If something is furry and not cold then it is green.
</PREMISES>
<CONCLUSION>
Dave is not smart.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is furry.
FOL: Furry(Anne)
TEXT: Charlie is blue.
FOL: Blue(Charlie)
TEXT: Charlie is smart.
FOL: Smart(Charlie)
TEXT: Dave is not blue.
FOL: -Blue(Dave)
TEXT: Dave is green.
FOL: Green(Dave)
TEXT: Erin is not blue.
FOL: -Blue(Erin)
TEXT: Erin is red.
FOL: Red(Erin)
TEXT: If something is smart and not blue then it is not cold.
FOL: all x. ((Smart(x) & -Blue(x)) -> -Cold(x))
TEXT: If something is furry then it is kind.
FOL: all x. (Furry(x) -> Kind(x))
TEXT: Blue, smart things are kind.
FOL: all x. ((Blue(x) & Smart(x)) -> Kind(x))
TEXT: All kind things are smart.
FOL: all x. (Kind(x) -> Smart(x))
TEXT: If something is blue then it is furry.
FOL: all x. (Blue(x) -> Furry(x))
TEXT: All red things are furry.
FOL: all x. (Red(x) -> Furry(x))
TEXT: Red things are furry.
FOL: all x. (Red(x) -> Furry(x))
TEXT: Blue, kind things are red.
FOL: all x. ((Blue(x) & Kind(x)) -> Red(x))
TEXT: If something is furry and not cold then it is green.
FOL: all x. ((Furry(x) & -Cold(x)) -> Green(x))
TEXT: Dave is not smart.
FOL: -Smart(Dave)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: Anne is furry.
FOL: Furry(Anne)
TEXT: Charlie is blue.
FOL: Blue(Charlie)
TEXT: Charlie is smart.
FOL: Smart(Charlie)
TEXT: Dave is not blue.
FOL: -Blue(Dave)
TEXT: Dave is green.
FOL: Green(Dave)
TEXT: Erin is not blue.
FOL: -Blue(Erin)
TEXT: Erin is red.
FOL: Red(Erin)
TEXT: If something is smart and not blue then it is not cold.
FOL: all x. ((Smart(x) & -Blue(x)) -> -Cold(x))
TEXT: If something is furry then it is kind.
FOL: all x. (Furry(x) -> Kind(x))
TEXT: Blue, smart things are kind.
FOL: all x. ((Blue(x) & Smart(x)) -> Kind(x))
TEXT: All kind things are smart.
FOL: all x. (Kind(x) -> Smart(x))
TEXT: If something is blue then it is furry.
FOL: all x. (Blue(x) -> Furry(x))
TEXT: All red things are furry.
FOL: all x. (Red(x) -> Furry(x))
TEXT: Red things are furry.
FOL: all x. (Red(x) -> Furry(x))
TEXT: Blue, kind things are red.
FOL: all x. ((Blue(x) & Kind(x)) -> Red(x))
TEXT: If something is furry and not cold then it is green.
FOL: all x. ((Furry(x) & -Cold(x)) -> Green(x))
TEXT: Dave is not smart.
FOL: -Smart(Dave)
Processed: Uncertain

Generation 3:
TEXT: Anne is furry.
FOL: Furry(Anne)

TEXT: Charlie is blue.
FOL: Blue(Charlie)

TEXT: Charlie is smart.
FOL: Smart(Charlie)

TEXT: Dave is not blue.
FOL: -Blue(Dave)

TEXT: Dave is green.
FOL: Green(Dave)

TEXT: Erin is not blue.
FOL: -Blue(Erin)

TEXT: Erin is red.
FOL: Red(Erin)

TEXT: If something is smart and not blue then it is not cold.
FOL: all x. ((Smart(x) & -Blue(x)) -> -Cold(x))

TEXT: If something is furry then it is kind.
FOL: all x. (Furry(x) -> Kind(x))

TEXT: Blue, smart things are kind.
FOL: all x. ((Blue(x) & Smart(x)) -> Kind(x))

TEXT: All kind things are smart.
FOL: all x. (Kind(x) -> Smart(x))

TEXT: If something is blue then it is furry.
FOL: all x. (Blue(x) -> Furry(x))

TEXT: All red things are furry.
FOL: all x. (Red(x) -> Furry(x))

TEXT: Red things are furry.
FOL: all x. (Red(x) -> Furry(x))

TEXT: Blue, kind things are red.
FOL: all x. ((Blue(x) & Kind(x)) -> Red(x))

TEXT: If something is furry and not cold then it is green.
FOL: all x. ((Furry(x) & -Cold(x)) -> Green(x))

TEXT: Dave is not smart.
FOL: -Smart(Dave)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 16 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Dave is not cold.
Erin is cold.
Erin is furry.
Fiona is cold.
Fiona is quiet.
Harry is smart.
Harry is white.
Smart, cold things are white.
If Dave is green then Dave is not blue.
If Erin is green then Erin is smart.
If something is white and furry then it is smart.
If Fiona is cold and Fiona is quiet then Fiona is smart.
If something is furry then it is green.
All green, white things are furry.
If something is white and quiet then it is furry.
Green, quiet things are blue.
</PREMISES>
<CONCLUSION>
Dave is furry.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Dave is not cold.
FOL: -Cold(Dave)
TEXT: Erin is cold.
FOL: Cold(Erin)
TEXT: Erin is furry.
FOL: Furry(Erin)
TEXT: Fiona is cold.
FOL: Cold(Fiona)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Harry is smart.
FOL: Smart(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: Smart, cold things are white.
FOL: all x. (Smart(x) & Cold(x) -> White(x))
TEXT: If Dave is green then Dave is not blue.
FOL: Green(Dave) -> -Blue(Dave)
TEXT: If Erin is green then Erin is smart.
FOL: Green(Erin) -> Smart(Erin)
TEXT: If something is white and furry then it is smart.
FOL: all x. (White(x) & Furry(x) -> Smart(x))
TEXT: If Fiona is cold and Fiona is quiet then Fiona is smart.
FOL: (Cold(Fiona) & Quiet(Fiona)) -> Smart(Fiona)
TEXT: If something is furry then it is green.
FOL: all x. (Furry(x) -> Green(x))
TEXT: All green, white things are furry.
FOL: all x. (Green(x) & White(x) -> Furry(x))
TEXT: If something is white and quiet then it is furry.
FOL: all x. (White(x) & Quiet(x) -> Furry(x))
TEXT: Green, quiet things are blue.
FOL: all x. (Green(x) & Quiet(x) -> Blue(x))
TEXT: Dave is furry.
FOL: Furry(Dave)
Processed: Uncertain

Generation 2:
TEXT: Dave is not cold.
FOL: -Cold(Dave)
TEXT: Erin is cold.
FOL: Cold(Erin)
TEXT: Erin is furry.
FOL: Furry(Erin)
TEXT: Fiona is cold.
FOL: Cold(Fiona)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Harry is smart.
FOL: Smart(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: Smart, cold things are white.
FOL: all x. (Smart(x) & Cold(x) -> White(x))
TEXT: If Dave is green then Dave is not blue.
FOL: Green(Dave) -> -Blue(Dave)
TEXT: If Erin is green then Erin is smart.
FOL: Green(Erin) -> Smart(Erin)
TEXT: If something is white and furry then it is smart.
FOL: all x. (White(x) & Furry(x) -> Smart(x))
TEXT: If Fiona is cold and Fiona is quiet then Fiona is smart.
FOL: (Cold(Fiona) & Quiet(Fiona) -> Smart(Fiona))
TEXT: If something is furry then it is green.
FOL: all x. (Furry(x) -> Green(x))
TEXT: All green, white things are furry.
FOL: all x. (Green(x) & White(x) -> Furry(x))
TEXT: If something is white and quiet then it is furry.
FOL: all x. (White(x) & Quiet(x) -> Furry(x))
TEXT: Green, quiet things are blue.
FOL: all x. (Green(x) & Quiet(x) -> Blue(x))
TEXT: Dave is furry.
FOL: Furry(Dave)
Processed: Uncertain

Generation 3:
TEXT: Dave is not cold.
FOL: -Cold(Dave)
TEXT: Erin is cold.
FOL: Cold(Erin)
TEXT: Erin is furry.
FOL: Furry(Erin)
TEXT: Fiona is cold.
FOL: Cold(Fiona)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Harry is smart.
FOL: Smart(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: Smart, cold things are white.
FOL: all x. (Smart(x) & Cold(x) -> White(x))
TEXT: If Dave is green then Dave is not blue.
FOL: Green(Dave) -> -Blue(Dave)
TEXT: If Erin is green then Erin is smart.
FOL: Green(Erin) -> Smart(Erin)
TEXT: If something is white and furry then it is smart.
FOL: all x. (White(x) & Furry(x) -> Smart(x))
TEXT: If Fiona is cold and Fiona is quiet then Fiona is smart.
FOL: Cold(Fiona) & Quiet(Fiona) -> Smart(Fiona)
TEXT: If something is furry then it is green.
FOL: all x. (Furry(x) -> Green(x))
TEXT: All green, white things are furry.
FOL: all x. (Green(x) & White(x) -> Furry(x))
TEXT: If something is white and quiet then it is furry.
FOL: all x. (White(x) & Quiet(x) -> Furry(x))
TEXT: Green, quiet things are blue.
FOL: all x. (Green(x) & Quiet(x) -> Blue(x))
TEXT: Dave is furry.
FOL: Furry(Dave)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 17 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bear is big.
The bear sees the cat.
The cat chases the cow.
The cat likes the bear.
The cow likes the cat.
The cow sees the bear.
The dog sees the cow.
If the cat likes the bear and the cat chases the dog then the dog likes the cat.
If someone likes the cat then the cat sees the bear.
If someone sees the bear then they chase the dog.
If the cat is red then the cat likes the bear.
If someone chases the bear then the bear sees the dog.
If someone likes the cat then they chase the cow.
If someone chases the cow and the cow chases the dog then they are red.
If the cow is green then the cow chases the cat.
If someone likes the dog and they see the bear then the bear is young.
</PREMISES>
<CONCLUSION>
The cat does not chase the dog.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bear is big.
FOL: Big(Bear)

TEXT: The bear sees the cat.
FOL: Sees(Bear, Cat)

TEXT: The cat chases the cow.
FOL: Chases(Cat, Cow)

TEXT: The cat likes the bear.
FOL: Likes(Cat, Bear)

TEXT: The cow likes the cat.
FOL: Likes(Cow, Cat)

TEXT: The cow sees the bear.
FOL: Sees(Cow, Bear)

TEXT: The dog sees the cow.
FOL: Sees(Dog, Cow)

TEXT: If the cat likes the bear and the cat chases the dog then the dog likes the cat.
FOL: (Likes(Cat, Bear) & Chases(Cat, Dog)) -> Likes(Dog, Cat)

TEXT: If someone likes the cat then the cat sees the bear.
FOL: all x. (Likes(x, Cat) -> Sees(Cat, Bear))

TEXT: If someone sees the bear then they chase the dog.
FOL: all x. (Sees(x, Bear) -> Chases(x, Dog))

TEXT: If the cat is red then the cat likes the bear.
FOL: Red(Cat) -> Likes(Cat, Bear)

TEXT: If someone chases the bear then the bear sees the dog.
FOL: all x. (Chases(x, Bear) -> Sees(Bear, Dog))

TEXT: If someone likes the cat then they chase the cow.
FOL: all x. (Likes(x, Cat) -> Chases(x, Cow))

TEXT: If someone chases the cow and the cow chases the dog then they are red.
FOL: all x. (Chases(x, Cow) & Chases(Cow, Dog)) -> Red(x)

TEXT: If the cow is green then the cow chases the cat.
FOL: Green(Cow) -> Chases(Cow, Cat)

TEXT: If someone likes the dog and they see the bear then the bear is young.
FOL: all x. (Likes(x, Dog) & Sees(x, Bear)) -> Young(Bear)

TEXT: The cat does not chase the dog.
FOL: -Chases(Cat, Dog)
Processed: False

Generation 2:
TEXT: The bear is big.
FOL: Big(Bear)
TEXT: The bear sees the cat.
FOL: Sees(Bear, Cat)
TEXT: The cat chases the cow.
FOL: Chases(Cat, Cow)
TEXT: The cat likes the bear.
FOL: Likes(Cat, Bear)
TEXT: The cow likes the cat.
FOL: Likes(Cow, Cat)
TEXT: The cow sees the bear.
FOL: Sees(Cow, Bear)
TEXT: The dog sees the cow.
FOL: Sees(Dog, Cow)
TEXT: If the cat likes the bear and the cat chases the dog then the dog likes the cat.
FOL: (Likes(Cat, Bear) & Chases(Cat, Dog)) -> Likes(Dog, Cat)
TEXT: If someone likes the cat then the cat sees the bear.
FOL: all x. (Likes(x, Cat) -> Sees(Cat, Bear))
TEXT: If someone sees the bear then they chase the dog.
FOL: all x. (Sees(x, Bear) -> Chases(x, Dog))
TEXT: If the cat is red then the cat likes the bear.
FOL: Red(Cat) -> Likes(Cat, Bear)
TEXT: If someone chases the bear then the bear sees the dog.
FOL: all x. (Chases(x, Bear) -> Sees(Bear, Dog))
TEXT: If someone likes the cat then they chase the cow.
FOL: all x. (Likes(x, Cat) -> Chases(x, Cow))
TEXT: If someone chases the cow and the cow chases the dog then they are red.
FOL: all x. (Chases(x, Cow) & Chases(Cow, Dog)) -> Red(x)
TEXT: If the cow is green then the cow chases the cat.
FOL: Green(Cow) -> Chases(Cow, Cat)
TEXT: If someone likes the dog and they see the bear then the bear is young.
FOL: all x. (Likes(x, Dog) & Sees(x, Bear)) -> Young(Bear)
TEXT: The cat does not chase the dog.
FOL: -Chases(Cat, Dog)
</EVALUATE>
Processed: False

Generation 3:
TEXT: The bear is big.
FOL: Big(Bear)
TEXT: The bear sees the cat.
FOL: Sees(Bear, Cat)
TEXT: The cat chases the cow.
FOL: Chases(Cat, Cow)
TEXT: The cat likes the bear.
FOL: Likes(Cat, Bear)
TEXT: The cow likes the cat.
FOL: Likes(Cow, Cat)
TEXT: The cow sees the bear.
FOL: Sees(Cow, Bear)
TEXT: The dog sees the cow.
FOL: Sees(Dog, Cow)
TEXT: If the cat likes the bear and the cat chases the dog then the dog likes the cat.
FOL: (Likes(Cat, Bear) & Chases(Cat, Dog)) -> Likes(Dog, Cat)
TEXT: If someone likes the cat then the cat sees the bear.
FOL: all x. (Likes(x, Cat) -> Sees(Cat, Bear))
TEXT: If someone sees the bear then they chase the dog.
FOL: all x. (Sees(x, Bear) -> Chases(x, Dog))
TEXT: If the cat is red then the cat likes the bear.
FOL: Red(Cat) -> Likes(Cat, Bear)
TEXT: If someone chases the bear then the bear sees the dog.
FOL: all x. (Chases(x, Bear) -> Sees(Bear, Dog))
TEXT: If someone likes the cat then they chase the cow.
FOL: all x. (Likes(x, Cat) -> Chases(x, Cow))
TEXT: If someone chases the cow and the cow chases the dog then they are red.
FOL: all x. (Chases(x, Cow) & Chases(Cow, Dog)) -> Red(x)
TEXT: If the cow is green then the cow chases the cat.
FOL: Green(Cow) -> Chases(Cow, Cat)
TEXT: If someone likes the dog and they see the bear then the bear is young.
FOL: all x. (Likes(x, Dog) & Sees(x, Bear)) -> Young(Bear)
TEXT: The cat does not chase the dog.
FOL: -Chases(Cat, Dog)
Processed: False

Reference: False
========================================

=== Example 18 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is green.
Bob is white.
Dave is blue.
Dave is cold.
Dave is green.
Dave is white.
Fiona is cold.
Fiona is green.
Fiona is white.
Fiona is young.
Gary is kind.
Gary is white.
Cold, white people are furry.
If someone is furry then they are green.
All cold people are young.
If someone is kind and young then they are blue.
If someone is furry then they are blue.
All white, kind people are young.
All kind, blue people are cold.
If Bob is blue then Bob is kind.
</PREMISES>
<CONCLUSION>
Bob is kind.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is green.
FOL: Green(Bob)
TEXT: Bob is white.
FOL: White(Bob)
TEXT: Dave is blue.
FOL: Blue(Dave)
TEXT: Dave is cold.
FOL: Cold(Dave)
TEXT: Dave is green.
FOL: Green(Dave)
TEXT: Dave is white.
FOL: White(Dave)
TEXT: Fiona is cold.
FOL: Cold(Fiona)
TEXT: Fiona is green.
FOL: Green(Fiona)
TEXT: Fiona is white.
FOL: White(Fiona)
TEXT: Fiona is young.
FOL: Young(Fiona)
TEXT: Gary is kind.
FOL: Kind(Gary)
TEXT: Gary is white.
FOL: White(Gary)
TEXT: Cold, white people are furry.
FOL: all x. (Cold(x) & White(x) -> Furry(x))
TEXT: If someone is furry then they are green.
FOL: all x. (Furry(x) -> Green(x))
TEXT: All cold people are young.
FOL: all x. (Cold(x) -> Young(x))
TEXT: If someone is kind and young then they are blue.
FOL: all x. (Kind(x) & Young(x) -> Blue(x))
TEXT: If someone is furry then they are blue.
FOL: all x. (Furry(x) -> Blue(x))
TEXT: All white, kind people are young.
FOL: all x. (White(x) & Kind(x) -> Young(x))
TEXT: All kind, blue people are cold.
FOL: all x. (Kind(x) & Blue(x) -> Cold(x))
TEXT: If Bob is blue then Bob is kind.
FOL: Blue(Bob) -> Kind(Bob)
TEXT: Bob is kind.
FOL: Kind(Bob)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: Bob is green.
FOL: Color(Bob, Green)

TEXT: Bob is white.
FOL: Color(Bob, White)

TEXT: Dave is blue.
FOL: Color(Dave, Blue)

TEXT: Dave is cold.
FOL: Cold(Dave)

TEXT: Dave is green.
FOL: Color(Dave, Green)

TEXT: Dave is white.
FOL: Color(Dave, White)

TEXT: Fiona is cold.
FOL: Cold(Fiona)

TEXT: Fiona is green.
FOL: Color(Fiona, Green)

TEXT: Fiona is white.
FOL: Color(Fiona, White)

TEXT: Fiona is young.
FOL: Young(Fiona)

TEXT: Gary is kind.
FOL: Kind(Gary)

TEXT: Gary is white.
FOL: Color(Gary, White)

TEXT: Cold, white people are furry.
FOL: all x. (Cold(x) & Color(x, White) -> Furry(x))

TEXT: If someone is furry then they are green.
FOL: all x. (Furry(x) -> Color(x, Green))

TEXT: All cold people are young.
FOL: all x. (Cold(x) -> Young(x))

TEXT: If someone is kind and young then they are blue.
FOL: all x. (Kind(x) & Young(x) -> Color(x, Blue))

TEXT: If someone is furry then they are blue.
FOL: all x. (Furry(x) -> Color(x, Blue))

TEXT: All white, kind people are young.
FOL: all x. (Color(x, White) & Kind(x) -> Young(x))

TEXT: All kind, blue people are cold.
FOL: all x. (Kind(x) & Color(x, Blue) -> Cold(x))

TEXT: If Bob is blue then Bob is kind.
FOL: (Color(Bob, Blue) -> Kind(Bob))

TEXT: Bob is kind.
FOL: Kind(Bob)
Processed: Uncertain

Generation 3:
TEXT: Bob is green.
FOL: Color(Bob, Green)

TEXT: Bob is white.
FOL: Color(Bob, White)

TEXT: Dave is blue.
FOL: Color(Dave, Blue)

TEXT: Dave is cold.
FOL: Temperature(Dave, Cold)

TEXT: Dave is green.
FOL: Color(Dave, Green)

TEXT: Dave is white.
FOL: Color(Dave, White)

TEXT: Fiona is cold.
FOL: Temperature(Fiona, Cold)

TEXT: Fiona is green.
FOL: Color(Fiona, Green)

TEXT: Fiona is white.
FOL: Color(Fiona, White)

TEXT: Fiona is young.
FOL: Age(Fiona, Young)

TEXT: Gary is kind.
FOL: Trait(Gary, Kind)

TEXT: Gary is white.
FOL: Color(Gary, White)

TEXT: Cold, white people are furry.
FOL: all x. (Temperature(x, Cold) & Color(x, White) -> Fur(x))

TEXT: If someone is furry then they are green.
FOL: all x. (Fur(x) -> Color(x, Green))

TEXT: All cold people are young.
FOL: all x. (Temperature(x, Cold) -> Age(x, Young))

TEXT: If someone is kind and young then they are blue.
FOL: all x. (Trait(x, Kind) & Age(x, Young) -> Color(x, Blue))

TEXT: If someone is furry then they are blue.
FOL: all x. (Fur(x) -> Color(x, Blue))

TEXT: All white, kind people are young.
FOL: all x. (Color(x, White) & Trait(x, Kind) -> Age(x, Young))

TEXT: All kind, blue people are cold.
FOL: all x. (Trait(x, Kind) & Color(x, Blue) -> Temperature(x, Cold))

TEXT: If Bob is blue then Bob is kind.
FOL: (Color(Bob, Blue) -> Trait(Bob, Kind))

TEXT: Bob is kind.
FOL: Trait(Bob, Kind)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 19 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle is big.
The bald eagle is kind.
The bald eagle does not like the rabbit.
The bald eagle needs the cat.
The bald eagle needs the rabbit.
The bald eagle does not see the squirrel.
The cat is not green.
The cat likes the rabbit.
The rabbit likes the bald eagle.
The squirrel is not blue.
The squirrel is not cold.
The squirrel is kind.
The squirrel needs the cat.
The squirrel needs the rabbit.
If something likes the squirrel then the squirrel is big.
All big things are green.
If something is kind and big then it needs the squirrel.
If something sees the rabbit and it needs the cat then it does not like the rabbit.
If something needs the rabbit and the rabbit is kind then it needs the cat.
If the bald eagle likes the squirrel and the bald eagle needs the squirrel then the squirrel does not like the bald eagle.
If something sees the cat and it is blue then the cat does not see the bald eagle.
If something needs the squirrel then it likes the squirrel.
</PREMISES>
<CONCLUSION>
The squirrel likes the bald eagle.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle is big.
FOL: Big(BaldEagle)
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)
TEXT: The bald eagle does not like the rabbit.
FOL: -Likes(BaldEagle, Rabbit)
TEXT: The bald eagle needs the cat.
FOL: Needs(BaldEagle, Cat)
TEXT: The bald eagle needs the rabbit.
FOL: Needs(BaldEagle, Rabbit)
TEXT: The bald eagle does not see the squirrel.
FOL: -Sees(BaldEagle, Squirrel)
TEXT: The cat is not green.
FOL: -Green(Cat)
TEXT: The cat likes the rabbit.
FOL: Likes(Cat, Rabbit)
TEXT: The rabbit likes the bald eagle.
FOL: Likes(Rabbit, BaldEagle)
TEXT: The squirrel is not blue.
FOL: -Blue(Squirrel)
TEXT: The squirrel is not cold.
FOL: -Cold(Squirrel)
TEXT: The squirrel is kind.
FOL: Kind(Squirrel)
TEXT: The squirrel needs the cat.
FOL: Needs(Squirrel, Cat)
TEXT: The squirrel needs the rabbit.
FOL: Needs(Squirrel, Rabbit)
TEXT: If something likes the squirrel then the squirrel is big.
FOL: all x. (Likes(x, Squirrel) -> Big(Squirrel))
TEXT: All big things are green.
FOL: all x. (Big(x) -> Green(x))
TEXT: If something is kind and big then it needs the squirrel.
FOL: all x. (Kind(x) & Big(x) -> Needs(x, Squirrel))
TEXT: If something sees the rabbit and it needs the cat then it does not like the rabbit.
FOL: all x. (Sees(x, Rabbit) & Needs(x, Cat) -> -Likes(x, Rabbit))
TEXT: If something needs the rabbit and the rabbit is kind then it needs the cat.
FOL: all x. (Needs(x, Rabbit) & Kind(Rabbit) -> Needs(x, Cat))
TEXT: If the bald eagle likes the squirrel and the bald eagle needs the squirrel then the squirrel does not like the bald eagle.
FOL: (Likes(BaldEagle, Squirrel) & Needs(BaldEagle, Squirrel) -> -Likes(Squirrel, BaldEagle))
TEXT: If something sees the cat and it is blue then the cat does not see the bald eagle.
FOL: all x. (Sees(x, Cat) & Blue(x) -> -Sees(Cat, BaldEagle))
TEXT: If something needs the squirrel then it likes the squirrel.
FOL: all x. (Needs(x, Squirrel) -> Likes(x, Squirrel))
TEXT: The squirrel likes the bald eagle.
FOL: Likes(Squirrel, BaldEagle)
Processed: False

Generation 2:
TEXT: The bald eagle is big.
FOL: Big(BaldEagle)
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)
TEXT: The bald eagle does not like the rabbit.
FOL: -Likes(BaldEagle, Rabbit)
TEXT: The bald eagle needs the cat.
FOL: Needs(BaldEagle, Cat)
TEXT: The bald eagle needs the rabbit.
FOL: Needs(BaldEagle, Rabbit)
TEXT: The bald eagle does not see the squirrel.
FOL: -Sees(BaldEagle, Squirrel)
TEXT: The cat is not green.
FOL: -Green(Cat)
TEXT: The cat likes the rabbit.
FOL: Likes(Cat, Rabbit)
TEXT: The rabbit likes the bald eagle.
FOL: Likes(Rabbit, BaldEagle)
TEXT: The squirrel is not blue.
FOL: -Blue(Squirrel)
TEXT: The squirrel is not cold.
FOL: -Cold(Squirrel)
TEXT: The squirrel is kind.
FOL: Kind(Squirrel)
TEXT: The squirrel needs the cat.
FOL: Needs(Squirrel, Cat)
TEXT: The squirrel needs the rabbit.
FOL: Needs(Squirrel, Rabbit)
TEXT: If something likes the squirrel then the squirrel is big.
FOL: all x. (Likes(x, Squirrel) -> Big(Squirrel))
TEXT: All big things are green.
FOL: all x. (Big(x) -> Green(x))
TEXT: If something is kind and big then it needs the squirrel.
FOL: all x. ((Kind(x) & Big(x)) -> Needs(x, Squirrel))
TEXT: If something sees the rabbit and it needs the cat then it does not like the rabbit.
FOL: all x. ((Sees(x, Rabbit) & Needs(x, Cat)) -> -Likes(x, Rabbit))
TEXT: If something needs the rabbit and the rabbit is kind then it needs the cat.
FOL: all x. ((Needs(x, Rabbit) & Kind(Rabbit)) -> Needs(x, Cat))
TEXT: If the bald eagle likes the squirrel and the bald eagle needs the squirrel then the squirrel does not like the bald eagle.
FOL: (Likes(BaldEagle, Squirrel) & Needs(BaldEagle, Squirrel)) -> -Likes(Squirrel, BaldEagle)
TEXT: If something sees the cat and it is blue then the cat does not see the bald eagle.
FOL: all x. ((Sees(x, Cat) & Blue(x)) -> -Sees(Cat, BaldEagle))
TEXT: If something needs the squirrel then it likes the squirrel.
FOL: all x. (Needs(x, Squirrel) -> Likes(x, Squirrel))
TEXT: The squirrel likes the bald eagle.
FOL: Likes(Squirrel, BaldEagle)
Processed: False

Generation 3:
TEXT: The bald eagle is big.
FOL: Big(BaldEagle)
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)
TEXT: The bald eagle does not like the rabbit.
FOL: -Likes(BaldEagle, Rabbit)
TEXT: The bald eagle needs the cat.
FOL: Needs(BaldEagle, Cat)
TEXT: The bald eagle needs the rabbit.
FOL: Needs(BaldEagle, Rabbit)
TEXT: The bald eagle does not see the squirrel.
FOL: -Sees(BaldEagle, Squirrel)
TEXT: The cat is not green.
FOL: -Green(Cat)
TEXT: The cat likes the rabbit.
FOL: Likes(Cat, Rabbit)
TEXT: The rabbit likes the bald eagle.
FOL: Likes(Rabbit, BaldEagle)
TEXT: The squirrel is not blue.
FOL: -Blue(Squirrel)
TEXT: The squirrel is not cold.
FOL: -Cold(Squirrel)
TEXT: The squirrel is kind.
FOL: Kind(Squirrel)
TEXT: The squirrel needs the cat.
FOL: Needs(Squirrel, Cat)
TEXT: The squirrel needs the rabbit.
FOL: Needs(Squirrel, Rabbit)
TEXT: If something likes the squirrel then the squirrel is big.
FOL: all x. (Likes(x, Squirrel) -> Big(Squirrel))
TEXT: All big things are green.
FOL: all x. (Big(x) -> Green(x))
TEXT: If something is kind and big then it needs the squirrel.
FOL: all x. ((Kind(x) & Big(x)) -> Needs(x, Squirrel))
TEXT: If something sees the rabbit and it needs the cat then it does not like the rabbit.
FOL: all x. ((Sees(x, Rabbit) & Needs(x, Cat)) -> -Likes(x, Rabbit))
TEXT: If something needs the rabbit and the rabbit is kind then it needs the cat.
FOL: all x. ((Needs(x, Rabbit) & Kind(Rabbit)) -> Needs(x, Cat))
TEXT: If the bald eagle likes the squirrel and the bald eagle needs the squirrel then the squirrel does not like the bald eagle.
FOL: ((Likes(BaldEagle, Squirrel) & Needs(BaldEagle, Squirrel)) -> -Likes(Squirrel, BaldEagle))
TEXT: If something sees the cat and it is blue then the cat does not see the bald eagle.
FOL: all x. ((Sees(x, Cat) & Blue(x)) -> -Sees(Cat, BaldEagle))
TEXT: If something needs the squirrel then it likes the squirrel.
FOL: all x. (Needs(x, Squirrel) -> Likes(x, Squirrel))
TEXT: The squirrel likes the bald eagle.
FOL: Likes(Squirrel, BaldEagle)
</EVALUATE>
Processed: False

Reference: False
========================================

=== Example 20 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is green.
Erin is rough.
Gary is cold.
Gary is smart.
Harry is green.
Harry is smart.
Harry is white.
If something is white then it is green.
All rough things are quiet.
If something is green and smart then it is cold.
All quiet things are blue.
All quiet things are white.
All white things are rough.
Quiet, green things are smart.
</PREMISES>
<CONCLUSION>
Erin is smart.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is green.
FOL: Green(Bob)
TEXT: Erin is rough.
FOL: Rough(Erin)
TEXT: Gary is cold.
FOL: Cold(Gary)
TEXT: Gary is smart.
FOL: Smart(Gary)
TEXT: Harry is green.
FOL: Green(Harry)
TEXT: Harry is smart.
FOL: Smart(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: If something is white then it is green.
FOL: all x. (White(x) -> Green(x))
TEXT: All rough things are quiet.
FOL: all x. (Rough(x) -> Quiet(x))
TEXT: If something is green and smart then it is cold.
FOL: all x. ((Green(x) & Smart(x)) -> Cold(x))
TEXT: All quiet things are blue.
FOL: all x. (Quiet(x) -> Blue(x))
TEXT: All quiet things are white.
FOL: all x. (Quiet(x) -> White(x))
TEXT: All white things are rough.
FOL: all x. (White(x) -> Rough(x))
TEXT: Quiet, green things are smart.
FOL: all x. ((Quiet(x) & Green(x)) -> Smart(x))
TEXT: Erin is smart.
FOL: Smart(Erin)
</EVALUATE>
Processed: True

Generation 2:
TEXT: Bob is green.
FOL: Green(Bob)

TEXT: Erin is rough.
FOL: Rough(Erin)

TEXT: Gary is cold.
FOL: Cold(Gary)

TEXT: Gary is smart.
FOL: Smart(Gary)

TEXT: Harry is green.
FOL: Green(Harry)

TEXT: Harry is smart.
FOL: Smart(Harry)

TEXT: Harry is white.
FOL: White(Harry)

TEXT: If something is white then it is green.
FOL: all x. (White(x) -> Green(x))

TEXT: All rough things are quiet.
FOL: all x. (Rough(x) -> Quiet(x))

TEXT: If something is green and smart then it is cold.
FOL: all x. ((Green(x) & Smart(x)) -> Cold(x))

TEXT: All quiet things are blue.
FOL: all x. (Quiet(x) -> Blue(x))

TEXT: All quiet things are white.
FOL: all x. (Quiet(x) -> White(x))

TEXT: All white things are rough.
FOL: all x. (White(x) -> Rough(x))

TEXT: Quiet, green things are smart.
FOL: all x. ((Quiet(x) & Green(x)) -> Smart(x))

TEXT: Erin is smart.
FOL: Smart(Erin)
Processed: True

Generation 3:
TEXT: Bob is green.
FOL: Green(Bob)
TEXT: Erin is rough.
FOL: Rough(Erin)
TEXT: Gary is cold.
FOL: Cold(Gary)
TEXT: Gary is smart.
FOL: Smart(Gary)
TEXT: Harry is green.
FOL: Green(Harry)
TEXT: Harry is smart.
FOL: Smart(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: If something is white then it is green.
FOL: all x. (White(x) -> Green(x))
TEXT: All rough things are quiet.
FOL: all x. (Rough(x) -> Quiet(x))
TEXT: If something is green and smart then it is cold.
FOL: all x. ((Green(x) & Smart(x)) -> Cold(x))
TEXT: All quiet things are blue.
FOL: all x. (Quiet(x) -> Blue(x))
TEXT: All quiet things are white.
FOL: all x. (Quiet(x) -> White(x))
TEXT: All white things are rough.
FOL: all x. (White(x) -> Rough(x))
TEXT: Quiet, green things are smart.
FOL: all x. ((Quiet(x) & Green(x)) -> Smart(x))
TEXT: Erin is smart.
FOL: Smart(Erin)
Processed: True

Reference: True
========================================

=== Example 21 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is furry.
Anne is quiet.
Charlie is furry.
Charlie is green.
Dave is furry.
Dave is young.
Fiona is furry.
If something is green and furry then it is quiet.
Young things are quiet.
If something is quiet then it is green.
Smart, nice things are green.
All nice things are furry.
All nice things are not smart.
Furry things are young.
All furry things are cold.
All green, quiet things are nice.
</PREMISES>
<CONCLUSION>
Anne is smart.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is furry.
FOL: Furry(Anne)

TEXT: Anne is quiet.
FOL: Quiet(Anne)

TEXT: Charlie is furry.
FOL: Furry(Charlie)

TEXT: Charlie is green.
FOL: Green(Charlie)

TEXT: Dave is furry.
FOL: Furry(Dave)

TEXT: Dave is young.
FOL: Young(Dave)

TEXT: Fiona is furry.
FOL: Furry(Fiona)

TEXT: If something is green and furry then it is quiet.
FOL: all x. (Green(x) & Furry(x) -> Quiet(x))

TEXT: Young things are quiet.
FOL: all x. (Young(x) -> Quiet(x))

TEXT: If something is quiet then it is green.
FOL: all x. (Quiet(x) -> Green(x))

TEXT: Smart, nice things are green.
FOL: all x. (Smart(x) & Nice(x) -> Green(x))

TEXT: All nice things are furry.
FOL: all x. (Nice(x) -> Furry(x))

TEXT: All nice things are not smart.
FOL: all x. (Nice(x) -> -Smart(x))

TEXT: Furry things are young.
FOL: all x. (Furry(x) -> Young(x))

TEXT: All furry things are cold.
FOL: all x. (Furry(x) -> Cold(x))

TEXT: All green, quiet things are nice.
FOL: all x. (Green(x) & Quiet(x) -> Nice(x))

TEXT: Anne is smart.
FOL: Smart(Anne)
Processed: False

Generation 2:
TEXT: Anne is furry.
FOL: Furry(Anne)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
TEXT: Charlie is furry.
FOL: Furry(Charlie)
TEXT: Charlie is green.
FOL: Green(Charlie)
TEXT: Dave is furry.
FOL: Furry(Dave)
TEXT: Dave is young.
FOL: Young(Dave)
TEXT: Fiona is furry.
FOL: Furry(Fiona)
TEXT: If something is green and furry then it is quiet.
FOL: all x. (Green(x) & Furry(x) -> Quiet(x))
TEXT: Young things are quiet.
FOL: all x. (Young(x) -> Quiet(x))
TEXT: If something is quiet then it is green.
FOL: all x. (Quiet(x) -> Green(x))
TEXT: Smart, nice things are green.
FOL: all x. (Smart(x) & Nice(x) -> Green(x))
TEXT: All nice things are furry.
FOL: all x. (Nice(x) -> Furry(x))
TEXT: All nice things are not smart.
FOL: all x. (Nice(x) -> -Smart(x))
TEXT: Furry things are young.
FOL: all x. (Furry(x) -> Young(x))
TEXT: All furry things are cold.
FOL: all x. (Furry(x) -> Cold(x))
TEXT: All green, quiet things are nice.
FOL: all x. (Green(x) & Quiet(x) -> Nice(x))
TEXT: Anne is smart.
FOL: Smart(Anne)
Processed: False

Generation 3:
TEXT: Anne is furry.
FOL: Furry(Anne)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
TEXT: Charlie is furry.
FOL: Furry(Charlie)
TEXT: Charlie is green.
FOL: Green(Charlie)
TEXT: Dave is furry.
FOL: Furry(Dave)
TEXT: Dave is young.
FOL: Young(Dave)
TEXT: Fiona is furry.
FOL: Furry(Fiona)
TEXT: If something is green and furry then it is quiet.
FOL: all x. (Green(x) & Furry(x) -> Quiet(x))
TEXT: Young things are quiet.
FOL: all x. (Young(x) -> Quiet(x))
TEXT: If something is quiet then it is green.
FOL: all x. (Quiet(x) -> Green(x))
TEXT: Smart, nice things are green.
FOL: all x. (Smart(x) & Nice(x) -> Green(x))
TEXT: All nice things are furry.
FOL: all x. (Nice(x) -> Furry(x))
TEXT: All nice things are not smart.
FOL: all x. (Nice(x) -> -Smart(x))
TEXT: Furry things are young.
FOL: all x. (Furry(x) -> Young(x))
TEXT: All furry things are cold.
FOL: all x. (Furry(x) -> Cold(x))
TEXT: All green, quiet things are nice.
FOL: all x. (Green(x) & Quiet(x) -> Nice(x))
TEXT: Anne is smart.
FOL: Smart(Anne)
</EVALUATE>
Processed: False

Reference: False
========================================

=== Example 22 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle is kind.
The cat chases the bald eagle.
The cat is young.
The cat needs the bald eagle.
The cat needs the cow.
The cow chases the rabbit.
The cow is red.
The cow is rough.
The cow likes the bald eagle.
The rabbit is rough.
The rabbit needs the cat.
If something is red and it likes the cat then it is blue.
If something needs the cat then it needs the cow.
If something is rough and young then it likes the cow.
If something is blue then it needs the cat.
If something needs the cow then it chases the cow.
If something likes the rabbit and the rabbit is kind then it needs the rabbit.
If something chases the cow then the cow likes the cat.
</PREMISES>
<CONCLUSION>
The cow chases the rabbit.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)

TEXT: The cat chases the bald eagle.
FOL: Chases(Cat, BaldEagle)

TEXT: The cat is young.
FOL: Young(Cat)

TEXT: The cat needs the bald eagle.
FOL: Needs(Cat, BaldEagle)

TEXT: The cat needs the cow.
FOL: Needs(Cat, Cow)

TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)

TEXT: The cow is red.
FOL: Red(Cow)

TEXT: The cow is rough.
FOL: Rough(Cow)

TEXT: The cow likes the bald eagle.
FOL: Likes(Cow, BaldEagle)

TEXT: The rabbit is rough.
FOL: Rough(Rabbit)

TEXT: The rabbit needs the cat.
FOL: Needs(Rabbit, Cat)

TEXT: If something is red and it likes the cat then it is blue.
FOL: all x. (Red(x) & Likes(x, Cat) -> Blue(x))

TEXT: If something needs the cat then it needs the cow.
FOL: all x. (Needs(x, Cat) -> Needs(x, Cow))

TEXT: If something is rough and young then it likes the cow.
FOL: all x. (Rough(x) & Young(x) -> Likes(x, Cow))

TEXT: If something is blue then it needs the cat.
FOL: all x. (Blue(x) -> Needs(x, Cat))

TEXT: If something needs the cow then it chases the cow.
FOL: all x. (Needs(x, Cow) -> Chases(x, Cow))

TEXT: If something likes the rabbit and the rabbit is kind then it needs the rabbit.
FOL: all x. (Likes(x, Rabbit) & Kind(Rabbit) -> Needs(x, Rabbit))

TEXT: If something chases the cow then the cow likes the cat.
FOL: all x. (Chases(x, Cow) -> Likes(Cow, Cat))

TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)
Processed: True

Generation 2:
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)

TEXT: The cat chases the bald eagle.
FOL: Chases(Cat, BaldEagle)

TEXT: The cat is young.
FOL: Young(Cat)

TEXT: The cat needs the bald eagle.
FOL: Needs(Cat, BaldEagle)

TEXT: The cat needs the cow.
FOL: Needs(Cat, Cow)

TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)

TEXT: The cow is red.
FOL: Red(Cow)

TEXT: The cow is rough.
FOL: Rough(Cow)

TEXT: The cow likes the bald eagle.
FOL: Likes(Cow, BaldEagle)

TEXT: The rabbit is rough.
FOL: Rough(Rabbit)

TEXT: The rabbit needs the cat.
FOL: Needs(Rabbit, Cat)

TEXT: If something is red and it likes the cat then it is blue.
FOL: all x. ((Red(x) & Likes(x, Cat)) -> Blue(x))

TEXT: If something needs the cat then it needs the cow.
FOL: all x. (Needs(x, Cat) -> Needs(x, Cow))

TEXT: If something is rough and young then it likes the cow.
FOL: all x. ((Rough(x) & Young(x)) -> Likes(x, Cow))

TEXT: If something is blue then it needs the cat.
FOL: all x. (Blue(x) -> Needs(x, Cat))

TEXT: If something needs the cow then it chases the cow.
FOL: all x. (Needs(x, Cow) -> Chases(x, Cow))

TEXT: If something likes the rabbit and the rabbit is kind then it needs the rabbit.
FOL: all x. ((Likes(x, Rabbit) & Kind(Rabbit)) -> Needs(x, Rabbit))

TEXT: If something chases the cow then the cow likes the cat.
FOL: all x. (Chases(x, Cow) -> Likes(Cow, Cat))

TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)
Processed: True

Generation 3:
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)
TEXT: The cat chases the bald eagle.
FOL: Chases(Cat, BaldEagle)
TEXT: The cat is young.
FOL: Young(Cat)
TEXT: The cat needs the bald eagle.
FOL: Needs(Cat, BaldEagle)
TEXT: The cat needs the cow.
FOL: Needs(Cat, Cow)
TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)
TEXT: The cow is red.
FOL: Red(Cow)
TEXT: The cow is rough.
FOL: Rough(Cow)
TEXT: The cow likes the bald eagle.
FOL: Likes(Cow, BaldEagle)
TEXT: The rabbit is rough.
FOL: Rough(Rabbit)
TEXT: The rabbit needs the cat.
FOL: Needs(Rabbit, Cat)
TEXT: If something is red and it likes the cat then it is blue.
FOL: all x. (Red(x) & Likes(x, Cat) -> Blue(x))
TEXT: If something needs the cat then it needs the cow.
FOL: all x. (Needs(x, Cat) -> Needs(x, Cow))
TEXT: If something is rough and young then it likes the cow.
FOL: all x. (Rough(x) & Young(x) -> Likes(x, Cow))
TEXT: If something is blue then it needs the cat.
FOL: all x. (Blue(x) -> Needs(x, Cat))
TEXT: If something needs the cow then it chases the cow.
FOL: all x. (Needs(x, Cow) -> Chases(x, Cow))
TEXT: If something likes the rabbit and the rabbit is kind then it needs the rabbit.
FOL: all x. (Likes(x, Rabbit) & Kind(Rabbit) -> Needs(x, Rabbit))
TEXT: If something chases the cow then the cow likes the cat.
FOL: all x. (Chases(x, Cow) -> Likes(Cow, Cat))
TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 23 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle eats the lion.
The bald eagle eats the tiger.
The bald eagle is big.
The bald eagle is round.
The bald eagle likes the lion.
The cow eats the lion.
The cow likes the bald eagle.
The cow sees the tiger.
The lion eats the cow.
The tiger eats the lion.
The tiger is red.
If someone eats the cow then the cow sees the bald eagle.
If someone likes the bald eagle and they eat the bald eagle then they like the cow.
If someone likes the lion and the lion is cold then they see the bald eagle.
All young people are cold.
If someone likes the bald eagle and they see the bald eagle then the bald eagle is red.
If someone is red then they eat the bald eagle.
If someone eats the lion then they like the bald eagle.
If someone likes the cow then they like the tiger.
If the lion sees the cow then the cow eats the tiger.
</PREMISES>
<CONCLUSION>
The tiger sees the tiger.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle eats the lion.
FOL: Eats(BaldEagle, Lion)
TEXT: The bald eagle eats the tiger.
FOL: Eats(BaldEagle, Tiger)
TEXT: The bald eagle is big.
FOL: Big(BaldEagle)
TEXT: The bald eagle is round.
FOL: Round(BaldEagle)
TEXT: The bald eagle likes the lion.
FOL: Likes(BaldEagle, Lion)
TEXT: The cow eats the lion.
FOL: Eats(Cow, Lion)
TEXT: The cow likes the bald eagle.
FOL: Likes(Cow, BaldEagle)
TEXT: The cow sees the tiger.
FOL: Sees(Cow, Tiger)
TEXT: The lion eats the cow.
FOL: Eats(Lion, Cow)
TEXT: The tiger eats the lion.
FOL: Eats(Tiger, Lion)
TEXT: The tiger is red.
FOL: Red(Tiger)
TEXT: If someone eats the cow then the cow sees the bald eagle.
FOL: all x. (Eats(x, Cow) -> Sees(Cow, BaldEagle))
TEXT: If someone likes the bald eagle and they eat the bald eagle then they like the cow.
FOL: all x. (Likes(x, BaldEagle) & Eats(x, BaldEagle) -> Likes(x, Cow))
TEXT: If someone likes the lion and the lion is cold then they see the bald eagle.
FOL: all x. (Likes(x, Lion) & Cold(Lion) -> Sees(x, BaldEagle))
TEXT: All young people are cold.
FOL: all x. (YoungPerson(x) -> Cold(x))
TEXT: If someone likes the bald eagle and they see the bald eagle then the bald eagle is red.
FOL: all x. (Likes(x, BaldEagle) & Sees(x, BaldEagle) -> Red(BaldEagle))
TEXT: If someone is red then they eat the bald eagle.
FOL: all x. (Red(x) -> Eats(x, BaldEagle))
TEXT: If someone eats the lion then they like the bald eagle.
FOL: all x. (Eats(x, Lion) -> Likes(x, BaldEagle))
TEXT: If someone likes the cow then they like the tiger.
FOL: all x. (Likes(x, Cow) -> Likes(x, Tiger))
TEXT: If the lion sees the cow then the cow eats the tiger.
FOL: all x. (Sees(Lion, Cow) -> Eats(Cow, Tiger))
TEXT: The tiger sees the tiger.
FOL: Sees(Tiger, Tiger)
Processed: Uncertain

Generation 2:
TEXT: The bald eagle eats the lion.
FOL: Eats(BaldEagle, Lion)
TEXT: The bald eagle eats the tiger.
FOL: Eats(BaldEagle, Tiger)
TEXT: The bald eagle is big.
FOL: IsBig(BaldEagle)
TEXT: The bald eagle is round.
FOL: IsRound(BaldEagle)
TEXT: The bald eagle likes the lion.
FOL: Likes(BaldEagle, Lion)
TEXT: The cow eats the lion.
FOL: Eats(Cow, Lion)
TEXT: The cow likes the bald eagle.
FOL: Likes(Cow, BaldEagle)
TEXT: The cow sees the tiger.
FOL: Sees(Cow, Tiger)
TEXT: The lion eats the cow.
FOL: Eats(Lion, Cow)
TEXT: The tiger eats the lion.
FOL: Eats(Tiger, Lion)
TEXT: The tiger is red.
FOL: IsRed(Tiger)
TEXT: If someone eats the cow then the cow sees the bald eagle.
FOL: all x. (Eats(x, Cow) -> Sees(Cow, BaldEagle))
TEXT: If someone likes the bald eagle and they eat the bald eagle then they like the cow.
FOL: all x. ((Likes(x, BaldEagle) & Eats(x, BaldEagle)) -> Likes(x, Cow))
TEXT: If someone likes the lion and the lion is cold then they see the bald eagle.
FOL: all x. ((Likes(x, Lion) & Cold(Lion)) -> Sees(x, BaldEagle))
TEXT: All young people are cold.
FOL: all x. (YoungPerson(x) -> Cold(x))
TEXT: If someone likes the bald eagle and they see the bald eagle then the bald eagle is red.
FOL: all x. ((Likes(x, BaldEagle) & Sees(x, BaldEagle)) -> IsRed(BaldEagle))
TEXT: If someone is red then they eat the bald eagle.
FOL: all x. (IsRed(x) -> Eats(x, BaldEagle))
TEXT: If someone eats the lion then they like the bald eagle.
FOL: all x. (Eats(x, Lion) -> Likes(x, BaldEagle))
TEXT: If someone likes the cow then they like the tiger.
FOL: all x. (Likes(x, Cow) -> Likes(x, Tiger))
TEXT: If the lion sees the cow then the cow eats the tiger.
FOL: (Sees(Lion, Cow) -> Eats(Cow, Tiger))
TEXT: The tiger sees the tiger.
FOL: Sees(Tiger, Tiger)
Processed: Uncertain

Generation 3:
TEXT: The bald eagle eats the lion.
FOL: Eats(BaldEagle, Lion)
TEXT: The bald eagle eats the tiger.
FOL: Eats(BaldEagle, Tiger)
TEXT: The bald eagle is big.
FOL: Big(BaldEagle)
TEXT: The bald eagle is round.
FOL: Round(BaldEagle)
TEXT: The bald eagle likes the lion.
FOL: Likes(BaldEagle, Lion)
TEXT: The cow eats the lion.
FOL: Eats(Cow, Lion)
TEXT: The cow likes the bald eagle.
FOL: Likes(Cow, BaldEagle)
TEXT: The cow sees the tiger.
FOL: Sees(Cow, Tiger)
TEXT: The lion eats the cow.
FOL: Eats(Lion, Cow)
TEXT: The tiger eats the lion.
FOL: Eats(Tiger, Lion)
TEXT: The tiger is red.
FOL: Red(Tiger)
TEXT: If someone eats the cow then the cow sees the bald eagle.
FOL: all x. (Eats(x, Cow) -> Sees(Cow, BaldEagle))
TEXT: If someone likes the bald eagle and they eat the bald eagle then they like the cow.
FOL: all x. (Likes(x, BaldEagle) & Eats(x, BaldEagle) -> Likes(x, Cow))
TEXT: If someone likes the lion and the lion is cold then they see the bald eagle.
FOL: all x. (Likes(x, Lion) & Cold(Lion) -> Sees(x, BaldEagle))
TEXT: All young people are cold.
FOL: all x. (YoungPerson(x) -> Cold(x))
TEXT: If someone likes the bald eagle and they see the bald eagle then the bald eagle is red.
FOL: all x. (Likes(x, BaldEagle) & Sees(x, BaldEagle) -> Red(BaldEagle))
TEXT: If someone is red then they eat the bald eagle.
FOL: all x. (Red(x) -> Eats(x, BaldEagle))
TEXT: If someone eats the lion then they like the bald eagle.
FOL: all x. (Eats(x, Lion) -> Likes(x, BaldEagle))
TEXT: If someone likes the cow then they like the tiger.
FOL: all x. (Likes(x, Cow) -> Likes(x, Tiger))
TEXT: If the lion sees the cow then the cow eats the tiger.
FOL: Sees(Lion, Cow) -> Eats(Cow, Tiger)
TEXT: The tiger sees the tiger.
FOL: Sees(Tiger, Tiger)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 24 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle chases the mouse.
The bald eagle eats the cat.
The cat eats the mouse.
The mouse eats the bald eagle.
The mouse is blue.
The mouse needs the tiger.
The tiger is nice.
If something is rough then it eats the cat.
If something eats the mouse and the mouse needs the cat then it eats the bald eagle.
If something eats the cat then it needs the cat.
If the bald eagle needs the mouse and the bald eagle eats the cat then the bald eagle chases the tiger.
If something is rough then it chases the bald eagle.
If something eats the bald eagle then it is rough.
If something eats the tiger then the tiger eats the bald eagle.
If something needs the cat then the cat chases the tiger.
If something eats the cat then the cat is young.
</PREMISES>
<CONCLUSION>
The cat is not rough.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle chases the mouse.
FOL: Chases(BaldEagle, Mouse)
TEXT: The bald eagle eats the cat.
FOL: Eats(BaldEagle, Cat)
TEXT: The cat eats the mouse.
FOL: Eats(Cat, Mouse)
TEXT: The mouse eats the bald eagle.
FOL: Eats(Mouse, BaldEagle)
TEXT: The mouse is blue.
FOL: Blue(Mouse)
TEXT: The mouse needs the tiger.
FOL: Needs(Mouse, Tiger)
TEXT: The tiger is nice.
FOL: Nice(Tiger)
TEXT: If something is rough then it eats the cat.
FOL: all x. (Rough(x) -> Eats(x, Cat))
TEXT: If something eats the mouse and the mouse needs the cat then it eats the bald eagle.
FOL: all x. ((Eats(x, Mouse) & Needs(Mouse, Cat)) -> Eats(x, BaldEagle))
TEXT: If something eats the cat then it needs the cat.
FOL: all x. (Eats(x, Cat) -> Needs(x, Cat))
TEXT: If the bald eagle needs the mouse and the bald eagle eats the cat then the bald eagle chases the tiger.
FOL: (Needs(BaldEagle, Mouse) & Eats(BaldEagle, Cat)) -> Chases(BaldEagle, Tiger)
TEXT: If something is rough then it chases the bald eagle.
FOL: all x. (Rough(x) -> Chases(x, BaldEagle))
TEXT: If something eats the bald eagle then it is rough.
FOL: all x. (Eats(x, BaldEagle) -> Rough(x))
TEXT: If something eats the tiger then the tiger eats the bald eagle.
FOL: all x. (Eats(x, Tiger) -> Eats(Tiger, BaldEagle))
TEXT: If something needs the cat then the cat chases the tiger.
FOL: all x. (Needs(x, Cat) -> Chases(Cat, Tiger))
TEXT: If something eats the cat then the cat is young.
FOL: all x. (Eats(x, Cat) -> Young(Cat))
TEXT: The cat is not rough.
FOL: -Rough(Cat)
Processed: False

Generation 2:
TEXT: The bald eagle chases the mouse.
FOL: Chases(BaldEagle, Mouse)

TEXT: The bald eagle eats the cat.
FOL: Eats(BaldEagle, Cat)

TEXT: The cat eats the mouse.
FOL: Eats(Cat, Mouse)

TEXT: The mouse eats the bald eagle.
FOL: Eats(Mouse, BaldEagle)

TEXT: The mouse is blue.
FOL: IsBlue(Mouse)

TEXT: The mouse needs the tiger.
FOL: Needs(Mouse, Tiger)

TEXT: The tiger is nice.
FOL: Nice(Tiger)

TEXT: If something is rough then it eats the cat.
FOL: all x. (Rough(x) -> Eats(x, Cat))

TEXT: If something eats the mouse and the mouse needs the cat then it eats the bald eagle.
FOL: all x. ((Eats(x, Mouse) & Needs(Mouse, Cat)) -> Eats(x, BaldEagle))

TEXT: If something eats the cat then it needs the cat.
FOL: all x. (Eats(x, Cat) -> Needs(x, Cat))

TEXT: If the bald eagle needs the mouse and the bald eagle eats the cat then the bald eagle chases the tiger.
FOL: (Needs(BaldEagle, Mouse) & Eats(BaldEagle, Cat)) -> Chases(BaldEagle, Tiger)

TEXT: If something is rough then it chases the bald eagle.
FOL: all x. (Rough(x) -> Chases(x, BaldEagle))

TEXT: If something eats the bald eagle then it is rough.
FOL: all x. (Eats(x, BaldEagle) -> Rough(x))

TEXT: If something eats the tiger then the tiger eats the bald eagle.
FOL: all x. (Eats(x, Tiger) -> Eats(Tiger, BaldEagle))

TEXT: If something needs the cat then the cat chases the tiger.
FOL: all x. (Needs(x, Cat) -> Chases(Cat, Tiger))

TEXT: If something eats the cat then the cat is young.
FOL: all x. (Eats(x, Cat) -> Young(Cat))

TEXT: The cat is not rough.
FOL: -Rough(Cat)
Processed: False

Generation 3:
TEXT: The bald eagle chases the mouse.
FOL: Chases(BaldEagle, Mouse)
TEXT: The bald eagle eats the cat.
FOL: Eats(BaldEagle, Cat)
TEXT: The cat eats the mouse.
FOL: Eats(Cat, Mouse)
TEXT: The mouse eats the bald eagle.
FOL: Eats(Mouse, BaldEagle)
TEXT: The mouse is blue.
FOL: Blue(Mouse)
TEXT: The mouse needs the tiger.
FOL: Needs(Mouse, Tiger)
TEXT: The tiger is nice.
FOL: Nice(Tiger)
TEXT: If something is rough then it eats the cat.
FOL: all x. (Rough(x) -> Eats(x, Cat))
TEXT: If something eats the mouse and the mouse needs the cat then it eats the bald eagle.
FOL: all x. ((Eats(x, Mouse) & Needs(Mouse, Cat)) -> Eats(x, BaldEagle))
TEXT: If something eats the cat then it needs the cat.
FOL: all x. (Eats(x, Cat) -> Needs(x, Cat))
TEXT: If the bald eagle needs the mouse and the bald eagle eats the cat then the bald eagle chases the tiger.
FOL: (Needs(BaldEagle, Mouse) & Eats(BaldEagle, Cat)) -> Chases(BaldEagle, Tiger)
TEXT: If something is rough then it chases the bald eagle.
FOL: all x. (Rough(x) -> Chases(x, BaldEagle))
TEXT: If something eats the bald eagle then it is rough.
FOL: all x. (Eats(x, BaldEagle) -> Rough(x))
TEXT: If something eats the tiger then the tiger eats the bald eagle.
FOL: all x. (Eats(x, Tiger) -> Eats(Tiger, BaldEagle))
TEXT: If something needs the cat then the cat chases the tiger.
FOL: all x. (Needs(x, Cat) -> Chases(Cat, Tiger))
TEXT: If something eats the cat then the cat is young.
FOL: all x. (Eats(x, Cat) -> Young(Cat))
TEXT: The cat is not rough.
FOL: -Rough(Cat)
Processed: False

Reference: False
========================================

=== Example 25 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle eats the mouse.
The bald eagle likes the tiger.
The bald eagle sees the lion.
The lion does not eat the bald eagle.
The lion is rough.
The mouse likes the tiger.
The tiger is cold.
If something is kind then it sees the mouse.
If something likes the mouse then it likes the tiger.
If something is round then it does not like the tiger.
If something sees the bald eagle then it likes the lion.
If something sees the mouse then it is cold.
Rough things are kind.
If something eats the bald eagle then it likes the bald eagle.
All cold things are round.
</PREMISES>
<CONCLUSION>
The lion does not see the mouse.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle eats the mouse.
FOL: Eats(BaldEagle, Mouse)
TEXT: The bald eagle likes the tiger.
FOL: Likes(BaldEagle, Tiger)
TEXT: The bald eagle sees the lion.
FOL: Sees(BaldEagle, Lion)
TEXT: The lion does not eat the bald eagle.
FOL: -Eats(Lion, BaldEagle)
TEXT: The lion is rough.
FOL: Rough(Lion)
TEXT: The mouse likes the tiger.
FOL: Likes(Mouse, Tiger)
TEXT: The tiger is cold.
FOL: Cold(Tiger)
TEXT: If something is kind then it sees the mouse.
FOL: all x. (Kind(x) -> Sees(x, Mouse))
TEXT: If something likes the mouse then it likes the tiger.
FOL: all x. (Likes(x, Mouse) -> Likes(x, Tiger))
TEXT: If something is round then it does not like the tiger.
FOL: all x. (Round(x) -> -Likes(x, Tiger))
TEXT: If something sees the bald eagle then it likes the lion.
FOL: all x. (Sees(x, BaldEagle) -> Likes(x, Lion))
TEXT: If something sees the mouse then it is cold.
FOL: all x. (Sees(x, Mouse) -> Cold(x))
TEXT: Rough things are kind.
FOL: all x. (Rough(x) -> Kind(x))
TEXT: If something eats the bald eagle then it likes the bald eagle.
FOL: all x. (Eats(x, BaldEagle) -> Likes(x, BaldEagle))
TEXT: All cold things are round.
FOL: all x. (Cold(x) -> Round(x))
TEXT: The lion does not see the mouse.
FOL: -Sees(Lion, Mouse)
</EVALUATE>
Processed: False

Generation 2:
TEXT: The bald eagle eats the mouse.
FOL: Eats(BaldEagle, Mouse)

TEXT: The bald eagle likes the tiger.
FOL: Likes(BaldEagle, Tiger)

TEXT: The bald eagle sees the lion.
FOL: Sees(BaldEagle, Lion)

TEXT: The lion does not eat the bald eagle.
FOL: -Eats(Lion, BaldEagle)

TEXT: The lion is rough.
FOL: Rough(Lion)

TEXT: The mouse likes the tiger.
FOL: Likes(Mouse, Tiger)

TEXT: The tiger is cold.
FOL: Cold(Tiger)

TEXT: If something is kind then it sees the mouse.
FOL: all x. (Kind(x) -> Sees(x, Mouse))

TEXT: If something likes the mouse then it likes the tiger.
FOL: all x. (Likes(x, Mouse) -> Likes(x, Tiger))

TEXT: If something is round then it does not like the tiger.
FOL: all x. (Round(x) -> -Likes(x, Tiger))

TEXT: If something sees the bald eagle then it likes the lion.
FOL: all x. (Sees(x, BaldEagle) -> Likes(x, Lion))

TEXT: If something sees the mouse then it is cold.
FOL: all x. (Sees(x, Mouse) -> Cold(x))

TEXT: Rough things are kind.
FOL: all x. (Rough(x) -> Kind(x))

TEXT: If something eats the bald eagle then it likes the bald eagle.
FOL: all x. (Eats(x, BaldEagle) -> Likes(x, BaldEagle))

TEXT: All cold things are round.
FOL: all x. (Cold(x) -> Round(x))

TEXT: The lion does not see the mouse.
FOL: -Sees(Lion, Mouse)
Processed: False

Generation 3:
TEXT: The bald eagle eats the mouse.
FOL: Eats(BaldEagle, Mouse)
TEXT: The bald eagle likes the tiger.
FOL: Likes(BaldEagle, Tiger)
TEXT: The bald eagle sees the lion.
FOL: Sees(BaldEagle, Lion)
TEXT: The lion does not eat the bald eagle.
FOL: -Eats(Lion, BaldEagle)
TEXT: The lion is rough.
FOL: Rough(Lion)
TEXT: The mouse likes the tiger.
FOL: Likes(Mouse, Tiger)
TEXT: The tiger is cold.
FOL: Cold(Tiger)
TEXT: If something is kind then it sees the mouse.
FOL: all x. (Kind(x) -> Sees(x, Mouse))
TEXT: If something likes the mouse then it likes the tiger.
FOL: all x. (Likes(x, Mouse) -> Likes(x, Tiger))
TEXT: If something is round then it does not like the tiger.
FOL: all x. (Round(x) -> -Likes(x, Tiger))
TEXT: If something sees the bald eagle then it likes the lion.
FOL: all x. (Sees(x, BaldEagle) -> Likes(x, Lion))
TEXT: If something sees the mouse then it is cold.
FOL: all x. (Sees(x, Mouse) -> Cold(x))
TEXT: Rough things are kind.
FOL: all x. (Rough(x) -> Kind(x))
TEXT: If something eats the bald eagle then it likes the bald eagle.
FOL: all x. (Eats(x, BaldEagle) -> Likes(x, BaldEagle))
TEXT: All cold things are round.
FOL: all x. (Cold(x) -> Round(x))
TEXT: The lion does not see the mouse.
FOL: -Sees(Lion, Mouse)
Processed: False

Reference: False
========================================

=== Example 26 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bear chases the tiger.
The bear is kind.
The bear is rough.
The bear is round.
The bear sees the mouse.
The lion chases the tiger.
The lion is kind.
The lion is round.
The lion sees the mouse.
The mouse is kind.
The mouse is rough.
The mouse sees the bear.
The mouse sees the tiger.
The tiger is blue.
The tiger is kind.
The tiger visits the bear.
If someone is blue then they are nice.
If someone chases the bear then they chase the lion.
If someone visits the mouse then they are rough.
If someone chases the lion then the lion is nice.
If someone is nice then they chase the bear.
If someone chases the lion then they visit the mouse.
</PREMISES>
<CONCLUSION>
The lion is not round.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bear chases the tiger.
FOL: Chases(Bear, Tiger)

TEXT: The bear is kind.
FOL: Kind(Bear)

TEXT: The bear is rough.
FOL: Rough(Bear)

TEXT: The bear is round.
FOL: Round(Bear)

TEXT: The bear sees the mouse.
FOL: Sees(Bear, Mouse)

TEXT: The lion chases the tiger.
FOL: Chases(Lion, Tiger)

TEXT: The lion is kind.
FOL: Kind(Lion)

TEXT: The lion is round.
FOL: Round(Lion)

TEXT: The lion sees the mouse.
FOL: Sees(Lion, Mouse)

TEXT: The mouse is kind.
FOL: Kind(Mouse)

TEXT: The mouse is rough.
FOL: Rough(Mouse)

TEXT: The mouse sees the bear.
FOL: Sees(Mouse, Bear)

TEXT: The mouse sees the tiger.
FOL: Sees(Mouse, Tiger)

TEXT: The tiger is blue.
FOL: Blue(Tiger)

TEXT: The tiger is kind.
FOL: Kind(Tiger)

TEXT: The tiger visits the bear.
FOL: Visits(Tiger, Bear)

TEXT: If someone is blue then they are nice.
FOL: all x. (Blue(x) -> Nice(x))

TEXT: If someone chases the bear then they chase the lion.
FOL: all x. (Chases(x, Bear) -> Chases(x, Lion))

TEXT: If someone visits the mouse then they are rough.
FOL: all x. (Visits(x, Mouse) -> Rough(x))

TEXT: If someone chases the lion then the lion is nice.
FOL: all x. (Chases(x, Lion) -> Nice(Lion))

TEXT: If someone is nice then they chase the bear.
FOL: all x. (Nice(x) -> Chases(x, Bear))

TEXT: If someone chases the lion then they visit the mouse.
FOL: all x. (Chases(x, Lion) -> Visits(x, Mouse))

TEXT: The lion is not round.
FOL: -Round(Lion)
Processed: False

Generation 2:
TEXT: The bear chases the tiger.
FOL: Chases(Bear, Tiger)
TEXT: The bear is kind.
FOL: Kind(Bear)
TEXT: The bear is rough.
FOL: Rough(Bear)
TEXT: The bear is round.
FOL: Round(Bear)
TEXT: The bear sees the mouse.
FOL: Sees(Bear, Mouse)
TEXT: The lion chases the tiger.
FOL: Chases(Lion, Tiger)
TEXT: The lion is kind.
FOL: Kind(Lion)
TEXT: The lion is round.
FOL: Round(Lion)
TEXT: The lion sees the mouse.
FOL: Sees(Lion, Mouse)
TEXT: The mouse is kind.
FOL: Kind(Mouse)
TEXT: The mouse is rough.
FOL: Rough(Mouse)
TEXT: The mouse sees the bear.
FOL: Sees(Mouse, Bear)
TEXT: The mouse sees the tiger.
FOL: Sees(Mouse, Tiger)
TEXT: The tiger is blue.
FOL: Blue(Tiger)
TEXT: The tiger is kind.
FOL: Kind(Tiger)
TEXT: The tiger visits the bear.
FOL: Visits(Tiger, Bear)
TEXT: If someone is blue then they are nice.
FOL: all x. (Blue(x) -> Nice(x))
TEXT: If someone chases the bear then they chase the lion.
FOL: all x. (Chases(x, Bear) -> Chases(x, Lion))
TEXT: If someone visits the mouse then they are rough.
FOL: all x. (Visits(x, Mouse) -> Rough(x))
TEXT: If someone chases the lion then the lion is nice.
FOL: all x. (Chases(x, Lion) -> Nice(Lion))
TEXT: If someone is nice then they chase the bear.
FOL: all x. (Nice(x) -> Chases(x, Bear))
TEXT: If someone chases the lion then they visit the mouse.
FOL: all x. (Chases(x, Lion) -> Visits(x, Mouse))
TEXT: The lion is not round.
FOL: -Round(Lion)
Processed: False

Generation 3:
TEXT: The bear chases the tiger.
FOL: Chases(Bear, Tiger)
TEXT: The bear is kind.
FOL: Kind(Bear)
TEXT: The bear is rough.
FOL: Rough(Bear)
TEXT: The bear is round.
FOL: Round(Bear)
TEXT: The bear sees the mouse.
FOL: Sees(Bear, Mouse)
TEXT: The lion chases the tiger.
FOL: Chases(Lion, Tiger)
TEXT: The lion is kind.
FOL: Kind(Lion)
TEXT: The lion is round.
FOL: Round(Lion)
TEXT: The lion sees the mouse.
FOL: Sees(Lion, Mouse)
TEXT: The mouse is kind.
FOL: Kind(Mouse)
TEXT: The mouse is rough.
FOL: Rough(Mouse)
TEXT: The mouse sees the bear.
FOL: Sees(Mouse, Bear)
TEXT: The mouse sees the tiger.
FOL: Sees(Mouse, Tiger)
TEXT: The tiger is blue.
FOL: Blue(Tiger)
TEXT: The tiger is kind.
FOL: Kind(Tiger)
TEXT: The tiger visits the bear.
FOL: Visits(Tiger, Bear)
TEXT: If someone is blue then they are nice.
FOL: all x. (Blue(x) -> Nice(x))
TEXT: If someone chases the bear then they chase the lion.
FOL: all x. (Chases(x, Bear) -> Chases(x, Lion))
TEXT: If someone visits the mouse then they are rough.
FOL: all x. (Visits(x, Mouse) -> Rough(x))
TEXT: If someone chases the lion then the lion is nice.
FOL: all x. (Chases(x, Lion) -> Nice(Lion))
TEXT: If someone is nice then they chase the bear.
FOL: all x. (Nice(x) -> Chases(x, Bear))
TEXT: If someone chases the lion then they visit the mouse.
FOL: all x. (Chases(x, Lion) -> Visits(x, Mouse))
TEXT: The lion is not round.
FOL: -Round(Lion)
Processed: False

Reference: False
========================================

=== Example 27 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is green.
Bob is kind.
Charlie is nice.
Erin is kind.
Erin is nice.
Erin is white.
Gary is young.
All young things are white.
White things are young.
All nice, green things are kind.
If something is young then it is furry.
All kind things are nice.
All nice, green things are white.
If something is cold and kind then it is green.
If something is nice and young then it is furry.
Furry things are cold.
</PREMISES>
<CONCLUSION>
Erin is green.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is green.
FOL: Green(Bob)
TEXT: Bob is kind.
FOL: Kind(Bob)
TEXT: Charlie is nice.
FOL: Nice(Charlie)
TEXT: Erin is kind.
FOL: Kind(Erin)
TEXT: Erin is nice.
FOL: Nice(Erin)
TEXT: Erin is white.
FOL: White(Erin)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: All young things are white.
FOL: all x. (Young(x) -> White(x))
TEXT: White things are young.
FOL: all x. (White(x) -> Young(x))
TEXT: All nice, green things are kind.
FOL: all x. (Nice(x) & Green(x) -> Kind(x))
TEXT: If something is young then it is furry.
FOL: all x. (Young(x) -> Furry(x))
TEXT: All kind things are nice.
FOL: all x. (Kind(x) -> Nice(x))
TEXT: All nice, green things are white.
FOL: all x. (Nice(x) & Green(x) -> White(x))
TEXT: If something is cold and kind then it is green.
FOL: all x. (Cold(x) & Kind(x) -> Green(x))
TEXT: If something is nice and young then it is furry.
FOL: all x. (Nice(x) & Young(x) -> Furry(x))
TEXT: Furry things are cold.
FOL: all x. (Furry(x) -> Cold(x))
TEXT: Erin is green.
FOL: Green(Erin)
</EVALUATE>
Processed: True

Generation 2:
TEXT: Bob is green.
FOL: Green(Bob)
TEXT: Bob is kind.
FOL: Kind(Bob)
TEXT: Charlie is nice.
FOL: Nice(Charlie)
TEXT: Erin is kind.
FOL: Kind(Erin)
TEXT: Erin is nice.
FOL: Nice(Erin)
TEXT: Erin is white.
FOL: White(Erin)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: All young things are white.
FOL: all x. (Young(x) -> White(x))
TEXT: White things are young.
FOL: all x. (White(x) -> Young(x))
TEXT: All nice, green things are kind.
FOL: all x. ((Nice(x) & Green(x)) -> Kind(x))
TEXT: If something is young then it is furry.
FOL: all x. (Young(x) -> Furry(x))
TEXT: All kind things are nice.
FOL: all x. (Kind(x) -> Nice(x))
TEXT: All nice, green things are white.
FOL: all x. ((Nice(x) & Green(x)) -> White(x))
TEXT: If something is cold and kind then it is green.
FOL: all x. ((Cold(x) & Kind(x)) -> Green(x))
TEXT: If something is nice and young then it is furry.
FOL: all x. ((Nice(x) & Young(x)) -> Furry(x))
TEXT: Furry things are cold.
FOL: all x. (Furry(x) -> Cold(x))
TEXT: Erin is green.
FOL: Green(Erin)
Processed: True

Generation 3:
TEXT: Bob is green.
FOL: Green(Bob)
TEXT: Bob is kind.
FOL: Kind(Bob)
TEXT: Charlie is nice.
FOL: Nice(Charlie)
TEXT: Erin is kind.
FOL: Kind(Erin)
TEXT: Erin is nice.
FOL: Nice(Erin)
TEXT: Erin is white.
FOL: White(Erin)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: All young things are white.
FOL: all x. (Young(x) -> White(x))
TEXT: White things are young.
FOL: all x. (White(x) -> Young(x))
TEXT: All nice, green things are kind.
FOL: all x. ((Nice(x) & Green(x)) -> Kind(x))
TEXT: If something is young then it is furry.
FOL: all x. (Young(x) -> Furry(x))
TEXT: All kind things are nice.
FOL: all x. (Kind(x) -> Nice(x))
TEXT: All nice, green things are white.
FOL: all x. ((Nice(x) & Green(x)) -> White(x))
TEXT: If something is cold and kind then it is green.
FOL: all x. ((Cold(x) & Kind(x)) -> Green(x))
TEXT: If something is nice and young then it is furry.
FOL: all x. ((Nice(x) & Young(x)) -> Furry(x))
TEXT: Furry things are cold.
FOL: all x. (Furry(x) -> Cold(x))
TEXT: Erin is green.
FOL: Green(Erin)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 28 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bear is young.
The bear likes the cat.
The bear likes the lion.
The bear likes the tiger.
The bear needs the lion.
The bear needs the tiger.
The bear visits the lion.
The bear visits the tiger.
The cat needs the tiger.
The lion is young.
The tiger is blue.
The tiger likes the bear.
The tiger likes the cat.
The tiger visits the lion.
If something likes the bear then it is rough.
If something likes the bear and it visits the bear then the bear visits the cat.
If something likes the bear and it visits the cat then it is rough.
Big things are nice.
If something is rough then it needs the bear.
If something visits the tiger and it visits the cat then it is nice.
If something likes the lion then the lion is young.
If something is big then it is rough.
If something is rough and it needs the bear then it visits the bear.
</PREMISES>
<CONCLUSION>
The cat is not nice.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bear is young.
FOL: Young(Bear)
TEXT: The bear likes the cat.
FOL: Likes(Bear, Cat)
TEXT: The bear likes the lion.
FOL: Likes(Bear, Lion)
TEXT: The bear likes the tiger.
FOL: Likes(Bear, Tiger)
TEXT: The bear needs the lion.
FOL: Needs(Bear, Lion)
TEXT: The bear needs the tiger.
FOL: Needs(Bear, Tiger)
TEXT: The bear visits the lion.
FOL: Visits(Bear, Lion)
TEXT: The bear visits the tiger.
FOL: Visits(Bear, Tiger)
TEXT: The cat needs the tiger.
FOL: Needs(Cat, Tiger)
TEXT: The lion is young.
FOL: Young(Lion)
TEXT: The tiger is blue.
FOL: Blue(Tiger)
TEXT: The tiger likes the bear.
FOL: Likes(Tiger, Bear)
TEXT: The tiger likes the cat.
FOL: Likes(Tiger, Cat)
TEXT: The tiger visits the lion.
FOL: Visits(Tiger, Lion)
TEXT: If something likes the bear then it is rough.
FOL: all x. (Likes(x, Bear) -> Rough(x))
TEXT: If something likes the bear and it visits the bear then the bear visits the cat.
FOL: all x. (Likes(x, Bear) & Visits(x, Bear) -> Visits(Bear, Cat))
TEXT: If something likes the bear and it visits the cat then it is rough.
FOL: all x. (Likes(x, Bear) & Visits(x, Cat) -> Rough(x))
TEXT: Big things are nice.
FOL: all x. (Big(x) -> Nice(x))
TEXT: If something is rough then it needs the bear.
FOL: all x. (Rough(x) -> Needs(x, Bear))
TEXT: If something visits the tiger and it visits the cat then it is nice.
FOL: all x. (Visits(x, Tiger) & Visits(x, Cat) -> Nice(x))
TEXT: If something likes the lion then the lion is young.
FOL: all x. (Likes(x, Lion) -> Young(Lion))
TEXT: If something is big then it is rough.
FOL: all x. (Big(x) -> Rough(x))
TEXT: If something is rough and it needs the bear then it visits the bear.
FOL: all x. (Rough(x) & Needs(x, Bear) -> Visits(x, Bear))
TEXT: The cat is not nice.
FOL: -Nice(Cat)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: The bear is young.
FOL: Young(Bear)

TEXT: The bear likes the cat.
FOL: Likes(Bear, Cat)

TEXT: The bear likes the lion.
FOL: Likes(Bear, Lion)

TEXT: The bear likes the tiger.
FOL: Likes(Bear, Tiger)

TEXT: The bear needs the lion.
FOL: Needs(Bear, Lion)

TEXT: The bear needs the tiger.
FOL: Needs(Bear, Tiger)

TEXT: The bear visits the lion.
FOL: Visits(Bear, Lion)

TEXT: The bear visits the tiger.
FOL: Visits(Bear, Tiger)

TEXT: The cat needs the tiger.
FOL: Needs(Cat, Tiger)

TEXT: The lion is young.
FOL: Young(Lion)

TEXT: The tiger is blue.
FOL: Blue(Tiger)

TEXT: The tiger likes the bear.
FOL: Likes(Tiger, Bear)

TEXT: The tiger likes the cat.
FOL: Likes(Tiger, Cat)

TEXT: The tiger visits the lion.
FOL: Visits(Tiger, Lion)

TEXT: If something likes the bear then it is rough.
FOL: all x. (Likes(x, Bear) -> Rough(x))

TEXT: If something likes the bear and it visits the bear then the bear visits the cat.
FOL: all x. ((Likes(x, Bear) & Visits(x, Bear)) -> Visits(Bear, Cat))

TEXT: If something likes the bear and it visits the cat then it is rough.
FOL: all x. ((Likes(x, Bear) & Visits(x, Cat)) -> Rough(x))

TEXT: Big things are nice.
FOL: all x. (Big(x) -> Nice(x))

TEXT: If something is rough then it needs the bear.
FOL: all x. (Rough(x) -> Needs(x, Bear))

TEXT: If something visits the tiger and it visits the cat then it is nice.
FOL: all x. ((Visits(x, Tiger) & Visits(x, Cat)) -> Nice(x))

TEXT: If something likes the lion then the lion is young.
FOL: all x. (Likes(x, Lion) -> Young(Lion))

TEXT: If something is big then it is rough.
FOL: all x. (Big(x) -> Rough(x))

TEXT: If something is rough and it needs the bear then it visits the bear.
FOL: all x. ((Rough(x) & Needs(x, Bear)) -> Visits(x, Bear))

TEXT: The cat is not nice.
FOL: -Nice(Cat)
Processed: Uncertain

Generation 3:
TEXT: The bear is young.
FOL: Young(Bear)

TEXT: The bear likes the cat.
FOL: Likes(Bear, Cat)

TEXT: The bear likes the lion.
FOL: Likes(Bear, Lion)

TEXT: The bear likes the tiger.
FOL: Likes(Bear, Tiger)

TEXT: The bear needs the lion.
FOL: Needs(Bear, Lion)

TEXT: The bear needs the tiger.
FOL: Needs(Bear, Tiger)

TEXT: The bear visits the lion.
FOL: Visits(Bear, Lion)

TEXT: The bear visits the tiger.
FOL: Visits(Bear, Tiger)

TEXT: The cat needs the tiger.
FOL: Needs(Cat, Tiger)

TEXT: The lion is young.
FOL: Young(Lion)

TEXT: The tiger is blue.
FOL: Blue(Tiger)

TEXT: The tiger likes the bear.
FOL: Likes(Tiger, Bear)

TEXT: The tiger likes the cat.
FOL: Likes(Tiger, Cat)

TEXT: The tiger visits the lion.
FOL: Visits(Tiger, Lion)

TEXT: If something likes the bear then it is rough.
FOL: all x. (Likes(x, Bear) -> Rough(x))

TEXT: If something likes the bear and it visits the bear then the bear visits the cat.
FOL: all x. ((Likes(x, Bear) & Visits(x, Bear)) -> Visits(Bear, Cat))

TEXT: If something likes the bear and it visits the cat then it is rough.
FOL: all x. ((Likes(x, Bear) & Visits(x, Cat)) -> Rough(x))

TEXT: Big things are nice.
FOL: all x. (Big(x) -> Nice(x))

TEXT: If something is rough then it needs the bear.
FOL: all x. (Rough(x) -> Needs(x, Bear))

TEXT: If something visits the tiger and it visits the cat then it is nice.
FOL: all x. ((Visits(x, Tiger) & Visits(x, Cat)) -> Nice(x))

TEXT: If something likes the lion then the lion is young.
FOL: all x. (Likes(x, Lion) -> Young(Lion))

TEXT: If something is big then it is rough.
FOL: all x. (Big(x) -> Rough(x))

TEXT: If something is rough and it needs the bear then it visits the bear.
FOL: all x. ((Rough(x) & Needs(x, Bear)) -> Visits(x, Bear))

TEXT: The cat is not nice.
FOL: -Nice(Cat)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 29 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle is big.
The bald eagle sees the squirrel.
The dog eats the mouse.
The dog is not cold.
The dog is not nice.
The dog visits the mouse.
The mouse is red.
The squirrel sees the bald eagle.
The squirrel visits the bald eagle.
The squirrel visits the dog.
If something sees the mouse then it visits the mouse.
If something eats the dog then it visits the mouse.
If something eats the squirrel then it visits the mouse.
If something visits the dog then the dog visits the bald eagle.
If something is big and it visits the mouse then the mouse visits the squirrel.
If something visits the bald eagle then the bald eagle sees the mouse.
If something is big then it visits the bald eagle.
If something visits the squirrel then it is big.
If something eats the bald eagle and it sees the squirrel then it does not see the bald eagle.
</PREMISES>
<CONCLUSION>
The mouse visits the mouse.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle is big.
FOL: Big(BaldEagle)

TEXT: The bald eagle sees the squirrel.
FOL: Sees(BaldEagle, Squirrel)

TEXT: The dog eats the mouse.
FOL: Eats(Dog, Mouse)

TEXT: The dog is not cold.
FOL: -Cold(Dog)

TEXT: The dog is not nice.
FOL: -Nice(Dog)

TEXT: The dog visits the mouse.
FOL: Visits(Dog, Mouse)

TEXT: The mouse is red.
FOL: Red(Mouse)

TEXT: The squirrel sees the bald eagle.
FOL: Sees(Squirrel, BaldEagle)

TEXT: The squirrel visits the bald eagle.
FOL: Visits(Squirrel, BaldEagle)

TEXT: The squirrel visits the dog.
FOL: Visits(Squirrel, Dog)

TEXT: If something sees the mouse then it visits the mouse.
FOL: all x. (Sees(x, Mouse) -> Visits(x, Mouse))

TEXT: If something eats the dog then it visits the mouse.
FOL: all x. (Eats(x, Dog) -> Visits(x, Mouse))

TEXT: If something eats the squirrel then it visits the mouse.
FOL: all x. (Eats(x, Squirrel) -> Visits(x, Mouse))

TEXT: If something visits the dog then the dog visits the bald eagle.
FOL: all x. (Visits(x, Dog) -> Visits(Dog, BaldEagle))

TEXT: If something is big and it visits the mouse then the mouse visits the squirrel.
FOL: all x. (Big(x) & Visits(x, Mouse) -> Visits(Mouse, Squirrel))

TEXT: If something visits the bald eagle then the bald eagle sees the mouse.
FOL: all x. (Visits(x, BaldEagle) -> Sees(BaldEagle, Mouse))

TEXT: If something is big then it visits the bald eagle.
FOL: all x. (Big(x) -> Visits(x, BaldEagle))

TEXT: If something visits the squirrel then it is big.
FOL: all x. (Visits(x, Squirrel) -> Big(x))

TEXT: If something eats the bald eagle and it sees the squirrel then it does not see the bald eagle.
FOL: all x. (Eats(x, BaldEagle) & Sees(x, Squirrel) -> -Sees(x, BaldEagle))

TEXT: The mouse visits the mouse.
FOL: Visits(Mouse, Mouse)
Processed: Uncertain

Generation 2:
TEXT: The bald eagle is big.
FOL: Big(BaldEagle)
TEXT: The bald eagle sees the squirrel.
FOL: Sees(BaldEagle, Squirrel)
TEXT: The dog eats the mouse.
FOL: Eats(Dog, Mouse)
TEXT: The dog is not cold.
FOL: -Cold(Dog)
TEXT: The dog is not nice.
FOL: -Nice(Dog)
TEXT: The dog visits the mouse.
FOL: Visits(Dog, Mouse)
TEXT: The mouse is red.
FOL: Red(Mouse)
TEXT: The squirrel sees the bald eagle.
FOL: Sees(Squirrel, BaldEagle)
TEXT: The squirrel visits the bald eagle.
FOL: Visits(Squirrel, BaldEagle)
TEXT: The squirrel visits the dog.
FOL: Visits(Squirrel, Dog)
TEXT: If something sees the mouse then it visits the mouse.
FOL: all x. (Sees(x, Mouse) -> Visits(x, Mouse))
TEXT: If something eats the dog then it visits the mouse.
FOL: all x. (Eats(x, Dog) -> Visits(x, Mouse))
TEXT: If something eats the squirrel then it visits the mouse.
FOL: all x. (Eats(x, Squirrel) -> Visits(x, Mouse))
TEXT: If something visits the dog then the dog visits the bald eagle.
FOL: all x. (Visits(x, Dog) -> Visits(Dog, BaldEagle))
TEXT: If something is big and it visits the mouse then the mouse visits the squirrel.
FOL: all x. (Big(x) & Visits(x, Mouse) -> Visits(Mouse, Squirrel))
TEXT: If something visits the bald eagle then the bald eagle sees the mouse.
FOL: all x. (Visits(x, BaldEagle) -> Sees(BaldEagle, Mouse))
TEXT: If something is big then it visits the bald eagle.
FOL: all x. (Big(x) -> Visits(x, BaldEagle))
TEXT: If something visits the squirrel then it is big.
FOL: all x. (Visits(x, Squirrel) -> Big(x))
TEXT: If something eats the bald eagle and it sees the squirrel then it does not see the bald eagle.
FOL: all x. (Eats(x, BaldEagle) & Sees(x, Squirrel) -> -Sees(x, BaldEagle))
TEXT: The mouse visits the mouse.
FOL: Visits(Mouse, Mouse)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: The bald eagle is big.
FOL: Big(BaldEagle)
TEXT: The bald eagle sees the squirrel.
FOL: Sees(BaldEagle, Squirrel)
TEXT: The dog eats the mouse.
FOL: Eats(Dog, Mouse)
TEXT: The dog is not cold.
FOL: -Cold(Dog)
TEXT: The dog is not nice.
FOL: -Nice(Dog)
TEXT: The dog visits the mouse.
FOL: Visits(Dog, Mouse)
TEXT: The mouse is red.
FOL: Red(Mouse)
TEXT: The squirrel sees the bald eagle.
FOL: Sees(Squirrel, BaldEagle)
TEXT: The squirrel visits the bald eagle.
FOL: Visits(Squirrel, BaldEagle)
TEXT: The squirrel visits the dog.
FOL: Visits(Squirrel, Dog)
TEXT: If something sees the mouse then it visits the mouse.
FOL: all x. (Sees(x, Mouse) -> Visits(x, Mouse))
TEXT: If something eats the dog then it visits the mouse.
FOL: all x. (Eats(x, Dog) -> Visits(x, Mouse))
TEXT: If something eats the squirrel then it visits the mouse.
FOL: all x. (Eats(x, Squirrel) -> Visits(x, Mouse))
TEXT: If something visits the dog then the dog visits the bald eagle.
FOL: all x. (Visits(x, Dog) -> Visits(Dog, BaldEagle))
TEXT: If something is big and it visits the mouse then the mouse visits the squirrel.
FOL: all x. ((Big(x) & Visits(x, Mouse)) -> Visits(Mouse, Squirrel))
TEXT: If something visits the bald eagle then the bald eagle sees the mouse.
FOL: all x. (Visits(x, BaldEagle) -> Sees(BaldEagle, Mouse))
TEXT: If something is big then it visits the bald eagle.
FOL: all x. (Big(x) -> Visits(x, BaldEagle))
TEXT: If something visits the squirrel then it is big.
FOL: all x. (Visits(x, Squirrel) -> Big(x))
TEXT: If something eats the bald eagle and it sees the squirrel then it does not see the bald eagle.
FOL: all x. ((Eats(x, BaldEagle) & Sees(x, Squirrel)) -> -Sees(x, BaldEagle))
TEXT: The mouse visits the mouse.
FOL: Visits(Mouse, Mouse)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 30 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle eats the tiger.
The bald eagle is green.
The bear chases the bald eagle.
The bear chases the dog.
The bear eats the bald eagle.
The bear eats the dog.
The bear eats the tiger.
The bear is big.
The bear is green.
The bear is young.
The dog is big.
The dog is young.
The tiger chases the bear.
The tiger chases the dog.
If something is red and it eats the dog then the dog eats the tiger.
If something visits the tiger then the tiger eats the bear.
If something eats the dog then the dog is young.
If something is green and it visits the bald eagle then it visits the dog.
If something eats the tiger then it eats the bear.
If something is rough then it eats the bear.
If something eats the bear then it is red.
</PREMISES>
<CONCLUSION>
The dog is red.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle eats the tiger.
FOL: Eats(BaldEagle, Tiger)

TEXT: The bald eagle is green.
FOL: Color(BaldEagle, Green)

TEXT: The bear chases the bald eagle.
FOL: Chases(Bear, BaldEagle)

TEXT: The bear chases the dog.
FOL: Chases(Bear, Dog)

TEXT: The bear eats the bald eagle.
FOL: Eats(Bear, BaldEagle)

TEXT: The bear eats the dog.
FOL: Eats(Bear, Dog)

TEXT: The bear eats the tiger.
FOL: Eats(Bear, Tiger)

TEXT: The bear is big.
FOL: Size(Bear, Big)

TEXT: The bear is green.
FOL: Color(Bear, Green)

TEXT: The bear is young.
FOL: Age(Bear, Young)

TEXT: The dog is big.
FOL: Size(Dog, Big)

TEXT: The dog is young.
FOL: Age(Dog, Young)

TEXT: The tiger chases the bear.
FOL: Chases(Tiger, Bear)

TEXT: The tiger chases the dog.
FOL: Chases(Tiger, Dog)

TEXT: If something is red and it eats the dog then the dog eats the tiger.
FOL: all x. (Color(x, Red) & Eats(x, Dog) -> Eats(Dog, Tiger))

TEXT: If something visits the tiger then the tiger eats the bear.
FOL: all x. (Visits(x, Tiger) -> Eats(Tiger, Bear))

TEXT: If something eats the dog then the dog is young.
FOL: all x. (Eats(x, Dog) -> Age(Dog, Young))

TEXT: If something is green and it visits the bald eagle then it visits the dog.
FOL: all x. (Color(x, Green) & Visits(x, BaldEagle) -> Visits(x, Dog))

TEXT: If something eats the tiger then it eats the bear.
FOL: all x. (Eats(x, Tiger) -> Eats(x, Bear))

TEXT: If something is rough then it eats the bear.
FOL: all x. (Surface(x, Rough) -> Eats(x, Bear))

TEXT: If something eats the bear then it is red.
FOL: all x. (Eats(x, Bear) -> Color(x, Red))

TEXT: The dog is red.
FOL: Color(Dog, Red)
Processed: True

Generation 2:
TEXT: The bald eagle eats the tiger.
FOL: Eats(BaldEagle, Tiger)

TEXT: The bald eagle is green.
FOL: Color(BaldEagle, Green)

TEXT: The bear chases the bald eagle.
FOL: Chases(Bear, BaldEagle)

TEXT: The bear chases the dog.
FOL: Chases(Bear, Dog)

TEXT: The bear eats the bald eagle.
FOL: Eats(Bear, BaldEagle)

TEXT: The bear eats the dog.
FOL: Eats(Bear, Dog)

TEXT: The bear eats the tiger.
FOL: Eats(Bear, Tiger)

TEXT: The bear is big.
FOL: Size(Bear, Big)

TEXT: The bear is green.
FOL: Color(Bear, Green)

TEXT: The bear is young.
FOL: Age(Bear, Young)

TEXT: The dog is big.
FOL: Size(Dog, Big)

TEXT: The dog is young.
FOL: Age(Dog, Young)

TEXT: The tiger chases the bear.
FOL: Chases(Tiger, Bear)

TEXT: The tiger chases the dog.
FOL: Chases(Tiger, Dog)

TEXT: If something is red and it eats the dog then the dog eats the tiger.
FOL: all x. ((Color(x, Red) & Eats(x, Dog)) -> Eats(Dog, Tiger))

TEXT: If something visits the tiger then the tiger eats the bear.
FOL: all x. (Visits(x, Tiger) -> Eats(Tiger, Bear))

TEXT: If something eats the dog then the dog is young.
FOL: all x. (Eats(x, Dog) -> Age(Dog, Young))

TEXT: If something is green and it visits the bald eagle then it visits the dog.
FOL: all x. ((Color(x, Green) & Visits(x, BaldEagle)) -> Visits(x, Dog))

TEXT: If something eats the tiger then it eats the bear.
FOL: all x. (Eats(x, Tiger) -> Eats(x, Bear))

TEXT: If something is rough then it eats the bear.
FOL: all x. (Texture(x, Rough) -> Eats(x, Bear))

TEXT: If something eats the bear then it is red.
FOL: all x. (Eats(x, Bear) -> Color(x, Red))

TEXT: The dog is red.
FOL: Color(Dog, Red)
Processed: True

Generation 3:
TEXT: The bald eagle eats the tiger.
FOL: Eats(BaldEagle, Tiger)
TEXT: The bald eagle is green.
FOL: Color(BaldEagle, Green)
TEXT: The bear chases the bald eagle.
FOL: Chases(Bear, BaldEagle)
TEXT: The bear chases the dog.
FOL: Chases(Bear, Dog)
TEXT: The bear eats the bald eagle.
FOL: Eats(Bear, BaldEagle)
TEXT: The bear eats the dog.
FOL: Eats(Bear, Dog)
TEXT: The bear eats the tiger.
FOL: Eats(Bear, Tiger)
TEXT: The bear is big.
FOL: Size(Bear, Big)
TEXT: The bear is green.
FOL: Color(Bear, Green)
TEXT: The bear is young.
FOL: Age(Bear, Young)
TEXT: The dog is big.
FOL: Size(Dog, Big)
TEXT: The dog is young.
FOL: Age(Dog, Young)
TEXT: The tiger chases the bear.
FOL: Chases(Tiger, Bear)
TEXT: The tiger chases the dog.
FOL: Chases(Tiger, Dog)
TEXT: If something is red and it eats the dog then the dog eats the tiger.
FOL: all x. (Color(x, Red) & Eats(x, Dog) -> Eats(Dog, Tiger))
TEXT: If something visits the tiger then the tiger eats the bear.
FOL: all x. (Visits(x, Tiger) -> Eats(Tiger, Bear))
TEXT: If something eats the dog then the dog is young.
FOL: all x. (Eats(x, Dog) -> Age(Dog, Young))
TEXT: If something is green and it visits the bald eagle then it visits the dog.
FOL: all x. (Color(x, Green) & Visits(x, BaldEagle) -> Visits(x, Dog))
TEXT: If something eats the tiger then it eats the bear.
FOL: all x. (Eats(x, Tiger) -> Eats(x, Bear))
TEXT: If something is rough then it eats the bear.
FOL: all x. (Surface(x, Rough) -> Eats(x, Bear))
TEXT: If something eats the bear then it is red.
FOL: all x. (Eats(x, Bear) -> Color(x, Red))
TEXT: The dog is red.
FOL: Color(Dog, Red)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 31 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is furry.
Bob is kind.
Bob is white.
Erin is kind.
Erin is white.
Gary is rough.
Harry is not smart.
If Bob is rough then Bob is furry.
If someone is white then they are young.
All big, furry people are not smart.
If someone is smart and rough then they are big.
If someone is young then they are big.
If someone is rough then they are furry.
All smart, young people are furry.
If someone is furry and not rough then they are kind.
If someone is rough and furry then they are white.
</PREMISES>
<CONCLUSION>
Gary is big.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is furry.
FOL: Furry(Bob)

TEXT: Bob is kind.
FOL: Kind(Bob)

TEXT: Bob is white.
FOL: White(Bob)

TEXT: Erin is kind.
FOL: Kind(Erin)

TEXT: Erin is white.
FOL: White(Erin)

TEXT: Gary is rough.
FOL: Rough(Gary)

TEXT: Harry is not smart.
FOL: -Smart(Harry)

TEXT: If Bob is rough then Bob is furry.
FOL: Rough(Bob) -> Furry(Bob)

TEXT: If someone is white then they are young.
FOL: all x. (White(x) -> Young(x))

TEXT: All big, furry people are not smart.
FOL: all x. (Big(x) & Furry(x) -> -Smart(x))

TEXT: If someone is smart and rough then they are big.
FOL: all x. (Smart(x) & Rough(x) -> Big(x))

TEXT: If someone is young then they are big.
FOL: all x. (Young(x) -> Big(x))

TEXT: If someone is rough then they are furry.
FOL: all x. (Rough(x) -> Furry(x))

TEXT: All smart, young people are furry.
FOL: all x. (Smart(x) & Young(x) -> Furry(x))

TEXT: If someone is furry and not rough then they are kind.
FOL: all x. (Furry(x) & -Rough(x) -> Kind(x))

TEXT: If someone is rough and furry then they are white.
FOL: all x. (Rough(x) & Furry(x) -> White(x))

TEXT: Gary is big.
FOL: Big(Gary)
Processed: True

Generation 2:
TEXT: Bob is furry.
FOL: Furry(Bob)
TEXT: Bob is kind.
FOL: Kind(Bob)
TEXT: Bob is white.
FOL: White(Bob)
TEXT: Erin is kind.
FOL: Kind(Erin)
TEXT: Erin is white.
FOL: White(Erin)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: Harry is not smart.
FOL: -Smart(Harry)
TEXT: If Bob is rough then Bob is furry.
FOL: Rough(Bob) -> Furry(Bob)
TEXT: If someone is white then they are young.
FOL: all x. (White(x) -> Young(x))
TEXT: All big, furry people are not smart.
FOL: all x. (Big(x) & Furry(x) -> -Smart(x))
TEXT: If someone is smart and rough then they are big.
FOL: all x. (Smart(x) & Rough(x) -> Big(x))
TEXT: If someone is young then they are big.
FOL: all x. (Young(x) -> Big(x))
TEXT: If someone is rough then they are furry.
FOL: all x. (Rough(x) -> Furry(x))
TEXT: All smart, young people are furry.
FOL: all x. (Smart(x) & Young(x) -> Furry(x))
TEXT: If someone is furry and not rough then they are kind.
FOL: all x. (Furry(x) & -Rough(x) -> Kind(x))
TEXT: If someone is rough and furry then they are white.
FOL: all x. (Rough(x) & Furry(x) -> White(x))
TEXT: Gary is big.
FOL: Big(Gary)
</EVALUATE>
Processed: True

Generation 3:
TEXT: Bob is furry.
FOL: Furry(Bob)
TEXT: Bob is kind.
FOL: Kind(Bob)
TEXT: Bob is white.
FOL: White(Bob)
TEXT: Erin is kind.
FOL: Kind(Erin)
TEXT: Erin is white.
FOL: White(Erin)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: Harry is not smart.
FOL: -Smart(Harry)
TEXT: If Bob is rough then Bob is furry.
FOL: Rough(Bob) -> Furry(Bob)
TEXT: If someone is white then they are young.
FOL: all x. (White(x) -> Young(x))
TEXT: All big, furry people are not smart.
FOL: all x. (Big(x) & Furry(x) -> -Smart(x))
TEXT: If someone is smart and rough then they are big.
FOL: all x. (Smart(x) & Rough(x) -> Big(x))
TEXT: If someone is young then they are big.
FOL: all x. (Young(x) -> Big(x))
TEXT: If someone is rough then they are furry.
FOL: all x. (Rough(x) -> Furry(x))
TEXT: All smart, young people are furry.
FOL: all x. (Smart(x) & Young(x) -> Furry(x))
TEXT: If someone is furry and not rough then they are kind.
FOL: all x. (Furry(x) & -Rough(x) -> Kind(x))
TEXT: If someone is rough and furry then they are white.
FOL: all x. (Rough(x) & Furry(x) -> White(x))
TEXT: Gary is big.
FOL: Big(Gary)
Processed: True

Reference: True
========================================

=== Example 32 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Charlie is quiet.
Dave is quiet.
Dave is young.
Erin is blue.
Erin is nice.
Erin is quiet.
Fiona is not blue.
Fiona is cold.
Fiona is nice.
Fiona is round.
Fiona is young.
If someone is kind then they are round.
All kind, cold people are blue.
If someone is nice and not young then they are not blue.
If Fiona is kind then Fiona is blue.
If Dave is kind and Dave is blue then Dave is not nice.
Round people are cold.
If Dave is young then Dave is kind.
If Erin is kind and Erin is blue then Erin is round.
</PREMISES>
<CONCLUSION>
Dave is not cold.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Charlie is quiet.
FOL: Quiet(Charlie)
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Dave is young.
FOL: Young(Dave)
TEXT: Erin is blue.
FOL: Blue(Erin)
TEXT: Erin is nice.
FOL: Nice(Erin)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Fiona is not blue.
FOL: -Blue(Fiona)
TEXT: Fiona is cold.
FOL: Cold(Fiona)
TEXT: Fiona is nice.
FOL: Nice(Fiona)
TEXT: Fiona is round.
FOL: Round(Fiona)
TEXT: Fiona is young.
FOL: Young(Fiona)
TEXT: If someone is kind then they are round.
FOL: all x. (Kind(x) -> Round(x))
TEXT: All kind, cold people are blue.
FOL: all x. ((Kind(x) & Cold(x)) -> Blue(x))
TEXT: If someone is nice and not young then they are not blue.
FOL: all x. ((Nice(x) & -Young(x)) -> -Blue(x))
TEXT: If Fiona is kind then Fiona is blue.
FOL: Kind(Fiona) -> Blue(Fiona)
TEXT: If Dave is kind and Dave is blue then Dave is not nice.
FOL: ((Kind(Dave) & Blue(Dave)) -> -Nice(Dave))
TEXT: Round people are cold.
FOL: all x. (Round(x) -> Cold(x))
TEXT: If Dave is young then Dave is kind.
FOL: (Young(Dave) -> Kind(Dave))
TEXT: If Erin is kind and Erin is blue then Erin is round.
FOL: ((Kind(Erin) & Blue(Erin)) -> Round(Erin))
TEXT: Dave is not cold.
FOL: -Cold(Dave)
Processed: False

Generation 2:
TEXT: Charlie is quiet.
FOL: Quiet(Charlie)
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Dave is young.
FOL: Young(Dave)
TEXT: Erin is blue.
FOL: Blue(Erin)
TEXT: Erin is nice.
FOL: Nice(Erin)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Fiona is not blue.
FOL: -Blue(Fiona)
TEXT: Fiona is cold.
FOL: Cold(Fiona)
TEXT: Fiona is nice.
FOL: Nice(Fiona)
TEXT: Fiona is round.
FOL: Round(Fiona)
TEXT: Fiona is young.
FOL: Young(Fiona)
TEXT: If someone is kind then they are round.
FOL: all x. (Kind(x) -> Round(x))
TEXT: All kind, cold people are blue.
FOL: all x. ((Kind(x) & Cold(x)) -> Blue(x))
TEXT: If someone is nice and not young then they are not blue.
FOL: all x. ((Nice(x) & -Young(x)) -> -Blue(x))
TEXT: If Fiona is kind then Fiona is blue.
FOL: Kind(Fiona) -> Blue(Fiona)
TEXT: If Dave is kind and Dave is blue then Dave is not nice.
FOL: (Kind(Dave) & Blue(Dave)) -> -Nice(Dave)
TEXT: Round people are cold.
FOL: all x. (Round(x) -> Cold(x))
TEXT: If Dave is young then Dave is kind.
FOL: Young(Dave) -> Kind(Dave)
TEXT: If Erin is kind and Erin is blue then Erin is round.
FOL: (Kind(Erin) & Blue(Erin)) -> Round(Erin)
TEXT: Dave is not cold.
FOL: -Cold(Dave)
Processed: False

Generation 3:
TEXT: Charlie is quiet.
FOL: Quiet(Charlie)
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Dave is young.
FOL: Young(Dave)
TEXT: Erin is blue.
FOL: Blue(Erin)
TEXT: Erin is nice.
FOL: Nice(Erin)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Fiona is not blue.
FOL: -Blue(Fiona)
TEXT: Fiona is cold.
FOL: Cold(Fiona)
TEXT: Fiona is nice.
FOL: Nice(Fiona)
TEXT: Fiona is round.
FOL: Round(Fiona)
TEXT: Fiona is young.
FOL: Young(Fiona)
TEXT: If someone is kind then they are round.
FOL: all x. (Kind(x) -> Round(x))
TEXT: All kind, cold people are blue.
FOL: all x. ((Kind(x) & Cold(x)) -> Blue(x))
TEXT: If someone is nice and not young then they are not blue.
FOL: all x. ((Nice(x) & -Young(x)) -> -Blue(x))
TEXT: If Fiona is kind then Fiona is blue.
FOL: Kind(Fiona) -> Blue(Fiona)
TEXT: If Dave is kind and Dave is blue then Dave is not nice.
FOL: (Kind(Dave) & Blue(Dave)) -> -Nice(Dave)
TEXT: Round people are cold.
FOL: all x. (Round(x) -> Cold(x))
TEXT: If Dave is young then Dave is kind.
FOL: Young(Dave) -> Kind(Dave)
TEXT: If Erin is kind and Erin is blue then Erin is round.
FOL: (Kind(Erin) & Blue(Erin)) -> Round(Erin)
TEXT: Dave is not cold.
FOL: -Cold(Dave)
</EVALUATE>
Processed: False

Reference: False
========================================

=== Example 33 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle visits the cow.
The cow chases the rabbit.
The cow does not visit the dog.
The dog is not big.
The dog is young.
The rabbit sees the dog.
The rabbit visits the cow.
If someone sees the dog then they visit the dog.
If someone visits the bald eagle and they are round then the bald eagle chases the cow.
If someone is round then they see the rabbit.
If someone sees the rabbit then the rabbit is round.
If someone chases the dog then the dog visits the bald eagle.
If the dog is young then the dog does not visit the bald eagle.
If someone visits the dog then the dog is round.
If the dog is nice then the dog sees the cow.
If the rabbit sees the bald eagle and the bald eagle chases the cow then the cow sees the bald eagle.
</PREMISES>
<CONCLUSION>
The dog does not visit the dog.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle visits the cow.
FOL: Visits(BaldEagle, Cow)

TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)

TEXT: The cow does not visit the dog.
FOL: -Visits(Cow, Dog)

TEXT: The dog is not big.
FOL: -Big(Dog)

TEXT: The dog is young.
FOL: Young(Dog)

TEXT: The rabbit sees the dog.
FOL: Sees(Rabbit, Dog)

TEXT: The rabbit visits the cow.
FOL: Visits(Rabbit, Cow)

TEXT: If someone sees the dog then they visit the dog.
FOL: all x. (Sees(x, Dog) -> Visits(x, Dog))

TEXT: If someone visits the bald eagle and they are round then the bald eagle chases the cow.
FOL: all x. (Visits(x, BaldEagle) & Round(x) -> Chases(BaldEagle, Cow))

TEXT: If someone is round then they see the rabbit.
FOL: all x. (Round(x) -> Sees(x, Rabbit))

TEXT: If someone sees the rabbit then the rabbit is round.
FOL: all x. (Sees(x, Rabbit) -> Round(Rabbit))

TEXT: If someone chases the dog then the dog visits the bald eagle.
FOL: all x. (Chases(x, Dog) -> Visits(Dog, BaldEagle))

TEXT: If the dog is young then the dog does not visit the bald eagle.
FOL: Young(Dog) -> -Visits(Dog, BaldEagle)

TEXT: If someone visits the dog then the dog is round.
FOL: all x. (Visits(x, Dog) -> Round(Dog))

TEXT: If the dog is nice then the dog sees the cow.
FOL: Nice(Dog) -> Sees(Dog, Cow)

TEXT: If the rabbit sees the bald eagle and the bald eagle chases the cow then the cow sees the bald eagle.
FOL: (Sees(Rabbit, BaldEagle) & Chases(BaldEagle, Cow)) -> Sees(Cow, BaldEagle)

TEXT: The dog does not visit the dog.
FOL: -Visits(Dog, Dog)
Processed: Uncertain

Generation 2:
TEXT: The bald eagle visits the cow.
FOL: Visits(BaldEagle, Cow)

TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)

TEXT: The cow does not visit the dog.
FOL: -Visits(Cow, Dog)

TEXT: The dog is not big.
FOL: -Big(Dog)

TEXT: The dog is young.
FOL: Young(Dog)

TEXT: The rabbit sees the dog.
FOL: Sees(Rabbit, Dog)

TEXT: The rabbit visits the cow.
FOL: Visits(Rabbit, Cow)

TEXT: If someone sees the dog then they visit the dog.
FOL: all x. (Sees(x, Dog) -> Visits(x, Dog))

TEXT: If someone visits the bald eagle and they are round then the bald eagle chases the cow.
FOL: all x. (Visits(x, BaldEagle) & Round(x) -> Chases(BaldEagle, Cow))

TEXT: If someone is round then they see the rabbit.
FOL: all x. (Round(x) -> Sees(x, Rabbit))

TEXT: If someone sees the rabbit then the rabbit is round.
FOL: all x. (Sees(x, Rabbit) -> Round(Rabbit))

TEXT: If someone chases the dog then the dog visits the bald eagle.
FOL: all x. (Chases(x, Dog) -> Visits(Dog, BaldEagle))

TEXT: If the dog is young then the dog does not visit the bald eagle.
FOL: Young(Dog) -> -Visits(Dog, BaldEagle)

TEXT: If someone visits the dog then the dog is round.
FOL: all x. (Visits(x, Dog) -> Round(Dog))

TEXT: If the dog is nice then the dog sees the cow.
FOL: Nice(Dog) -> Sees(Dog, Cow)

TEXT: If the rabbit sees the bald eagle and the bald eagle chases the cow then the cow sees the bald eagle.
FOL: (Sees(Rabbit, BaldEagle) & Chases(BaldEagle, Cow)) -> Sees(Cow, BaldEagle)

TEXT: The dog does not visit the dog.
FOL: -Visits(Dog, Dog)
Processed: Uncertain

Generation 3:
TEXT: The bald eagle visits the cow.
FOL: Visits(BaldEagle, Cow)

TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)

TEXT: The cow does not visit the dog.
FOL: -Visits(Cow, Dog)

TEXT: The dog is not big.
FOL: -Big(Dog)

TEXT: The dog is young.
FOL: Young(Dog)

TEXT: The rabbit sees the dog.
FOL: Sees(Rabbit, Dog)

TEXT: The rabbit visits the cow.
FOL: Visits(Rabbit, Cow)

TEXT: If someone sees the dog then they visit the dog.
FOL: all x. (Sees(x, Dog) -> Visits(x, Dog))

TEXT: If someone visits the bald eagle and they are round then the bald eagle chases the cow.
FOL: all x. (Visits(x, BaldEagle) & Round(x) -> Chases(BaldEagle, Cow))

TEXT: If someone is round then they see the rabbit.
FOL: all x. (Round(x) -> Sees(x, Rabbit))

TEXT: If someone sees the rabbit then the rabbit is round.
FOL: all x. (Sees(x, Rabbit) -> Round(Rabbit))

TEXT: If someone chases the dog then the dog visits the bald eagle.
FOL: all x. (Chases(x, Dog) -> Visits(Dog, BaldEagle))

TEXT: If the dog is young then the dog does not visit the bald eagle.
FOL: Young(Dog) -> -Visits(Dog, BaldEagle)

TEXT: If someone visits the dog then the dog is round.
FOL: all x. (Visits(x, Dog) -> Round(Dog))

TEXT: If the dog is nice then the dog sees the cow.
FOL: Nice(Dog) -> Sees(Dog, Cow)

TEXT: If the rabbit sees the bald eagle and the bald eagle chases the cow then the cow sees the bald eagle.
FOL: (Sees(Rabbit, BaldEagle) & Chases(BaldEagle, Cow)) -> Sees(Cow, BaldEagle)

TEXT: The dog does not visit the dog.
FOL: -Visits(Dog, Dog)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 34 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is big.
Bob is quiet.
Bob is young.
Charlie is young.
Erin is quiet.
Erin is rough.
Gary is green.
Gary is nice.
Gary is quiet.
Gary is rough.
Gary is young.
Big, quiet things are green.
If Bob is round then Bob is nice.
If something is young then it is round.
All quiet things are nice.
All nice things are young.
Quiet, round things are big.
</PREMISES>
<CONCLUSION>
Erin is not big.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is big.
FOL: Big(Bob)
TEXT: Bob is quiet.
FOL: Quiet(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Charlie is young.
FOL: Young(Charlie)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Erin is rough.
FOL: Rough(Erin)
TEXT: Gary is green.
FOL: Green(Gary)
TEXT: Gary is nice.
FOL: Nice(Gary)
TEXT: Gary is quiet.
FOL: Quiet(Gary)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: Big, quiet things are green.
FOL: all x. (Big(x) & Quiet(x) -> Green(x))
TEXT: If Bob is round then Bob is nice.
FOL: Round(Bob) -> Nice(Bob)
TEXT: If something is young then it is round.
FOL: all x. (Young(x) -> Round(x))
TEXT: All quiet things are nice.
FOL: all x. (Quiet(x) -> Nice(x))
TEXT: All nice things are young.
FOL: all x. (Nice(x) -> Young(x))
TEXT: Quiet, round things are big.
FOL: all x. (Quiet(x) & Round(x) -> Big(x))
TEXT: Erin is not big.
FOL: -Big(Erin)
</EVALUATE>
Processed: False

Generation 2:
TEXT: Bob is big.
FOL: Big(Bob)
TEXT: Bob is quiet.
FOL: Quiet(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Charlie is young.
FOL: Young(Charlie)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Erin is rough.
FOL: Rough(Erin)
TEXT: Gary is green.
FOL: Green(Gary)
TEXT: Gary is nice.
FOL: Nice(Gary)
TEXT: Gary is quiet.
FOL: Quiet(Gary)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: Big, quiet things are green.
FOL: all x. (Big(x) & Quiet(x) -> Green(x))
TEXT: If Bob is round then Bob is nice.
FOL: Round(Bob) -> Nice(Bob)
TEXT: If something is young then it is round.
FOL: all x. (Young(x) -> Round(x))
TEXT: All quiet things are nice.
FOL: all x. (Quiet(x) -> Nice(x))
TEXT: All nice things are young.
FOL: all x. (Nice(x) -> Young(x))
TEXT: Quiet, round things are big.
FOL: all x. (Quiet(x) & Round(x) -> Big(x))
TEXT: Erin is not big.
FOL: -Big(Erin)
Processed: False

Generation 3:
TEXT: Bob is big.
FOL: Big(Bob)
TEXT: Bob is quiet.
FOL: Quiet(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Charlie is young.
FOL: Young(Charlie)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Erin is rough.
FOL: Rough(Erin)
TEXT: Gary is green.
FOL: Green(Gary)
TEXT: Gary is nice.
FOL: Nice(Gary)
TEXT: Gary is quiet.
FOL: Quiet(Gary)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: Big, quiet things are green.
FOL: all x. (Big(x) & Quiet(x) -> Green(x))
TEXT: If Bob is round then Bob is nice.
FOL: Round(Bob) -> Nice(Bob)
TEXT: If something is young then it is round.
FOL: all x. (Young(x) -> Round(x))
TEXT: All quiet things are nice.
FOL: all x. (Quiet(x) -> Nice(x))
TEXT: All nice things are young.
FOL: all x. (Nice(x) -> Young(x))
TEXT: Quiet, round things are big.
FOL: all x. (Quiet(x) & Round(x) -> Big(x))
TEXT: Erin is not big.
FOL: -Big(Erin)
</EVALUATE>
Processed: False

Reference: False
========================================

=== Example 35 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is not nice.
Anne is round.
Anne is not white.
Anne is young.
Erin is round.
Fiona is blue.
Gary is young.
All nice people are not quiet.
All round people are quiet.
If Anne is nice then Anne is white.
If someone is quiet then they are blue.
If Fiona is white then Fiona is blue.
If someone is rough then they are young.
If someone is nice and not blue then they are not rough.
If someone is blue then they are rough.
If Erin is young then Erin is white.
</PREMISES>
<CONCLUSION>
Anne is quiet.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is not nice.
FOL: -Nice(Anne)
TEXT: Anne is round.
FOL: Round(Anne)
TEXT: Anne is not white.
FOL: -White(Anne)
TEXT: Anne is young.
FOL: Young(Anne)
TEXT: Erin is round.
FOL: Round(Erin)
TEXT: Fiona is blue.
FOL: Blue(Fiona)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: All nice people are not quiet.
FOL: all x. (Nice(x) -> -Quiet(x))
TEXT: All round people are quiet.
FOL: all x. (Round(x) -> Quiet(x))
TEXT: If Anne is nice then Anne is white.
FOL: Nice(Anne) -> White(Anne)
TEXT: If someone is quiet then they are blue.
FOL: all x. (Quiet(x) -> Blue(x))
TEXT: If Fiona is white then Fiona is blue.
FOL: White(Fiona) -> Blue(Fiona)
TEXT: If someone is rough then they are young.
FOL: all x. (Rough(x) -> Young(x))
TEXT: If someone is nice and not blue then they are not rough.
FOL: all x. ((Nice(x) & -Blue(x)) -> -Rough(x))
TEXT: If someone is blue then they are rough.
FOL: all x. (Blue(x) -> Rough(x))
TEXT: If Erin is young then Erin is white.
FOL: Young(Erin) -> White(Erin)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
Processed: True

Generation 2:
TEXT: Anne is not nice.
FOL: -Nice(Anne)

TEXT: Anne is round.
FOL: Round(Anne)

TEXT: Anne is not white.
FOL: -White(Anne)

TEXT: Anne is young.
FOL: Young(Anne)

TEXT: Erin is round.
FOL: Round(Erin)

TEXT: Fiona is blue.
FOL: Blue(Fiona)

TEXT: Gary is young.
FOL: Young(Gary)

TEXT: All nice people are not quiet.
FOL: all x. (Nice(x) -> -Quiet(x))

TEXT: All round people are quiet.
FOL: all x. (Round(x) -> Quiet(x))

TEXT: If Anne is nice then Anne is white.
FOL: Nice(Anne) -> White(Anne)

TEXT: If someone is quiet then they are blue.
FOL: all x. (Quiet(x) -> Blue(x))

TEXT: If Fiona is white then Fiona is blue.
FOL: White(Fiona) -> Blue(Fiona)

TEXT: If someone is rough then they are young.
FOL: all x. (Rough(x) -> Young(x))

TEXT: If someone is nice and not blue then they are not rough.
FOL: all x. (Nice(x) & -Blue(x) -> -Rough(x))

TEXT: If someone is blue then they are rough.
FOL: all x. (Blue(x) -> Rough(x))

TEXT: If Erin is young then Erin is white.
FOL: Young(Erin) -> White(Erin)

TEXT: Anne is quiet.
FOL: Quiet(Anne)
Processed: True

Generation 3:
TEXT: Anne is not nice.
FOL: -Nice(Anne)
TEXT: Anne is round.
FOL: Round(Anne)
TEXT: Anne is not white.
FOL: -White(Anne)
TEXT: Anne is young.
FOL: Young(Anne)
TEXT: Erin is round.
FOL: Round(Erin)
TEXT: Fiona is blue.
FOL: Blue(Fiona)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: All nice people are not quiet.
FOL: all x. (Nice(x) -> -Quiet(x))
TEXT: All round people are quiet.
FOL: all x. (Round(x) -> Quiet(x))
TEXT: If Anne is nice then Anne is white.
FOL: Nice(Anne) -> White(Anne)
TEXT: If someone is quiet then they are blue.
FOL: all x. (Quiet(x) -> Blue(x))
TEXT: If Fiona is white then Fiona is blue.
FOL: White(Fiona) -> Blue(Fiona)
TEXT: If someone is rough then they are young.
FOL: all x. (Rough(x) -> Young(x))
TEXT: If someone is nice and not blue then they are not rough.
FOL: all x. ((Nice(x) & -Blue(x)) -> -Rough(x))
TEXT: If someone is blue then they are rough.
FOL: all x. (Blue(x) -> Rough(x))
TEXT: If Erin is young then Erin is white.
FOL: Young(Erin) -> White(Erin)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
Processed: True

Reference: True
========================================

=== Example 36 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bear is big.
The bear is nice.
The bear is rough.
The bear sees the squirrel.
The bear sees the tiger.
The lion eats the squirrel.
The lion is not green.
The lion likes the tiger.
The squirrel eats the tiger.
The squirrel likes the lion.
The squirrel likes the tiger.
The tiger eats the bear.
The tiger is not nice.
The tiger is rough.
The tiger does not like the squirrel.
The tiger sees the lion.
If someone likes the tiger and the tiger eats the bear then the bear eats the tiger.
If someone eats the tiger then the tiger is blue.
If someone sees the bear then they do not like the lion.
If someone is blue then they see the bear.
If someone eats the bear then the bear likes the tiger.
If someone sees the bear then the bear is blue.
If someone likes the tiger and the tiger sees the lion then they eat the lion.
If someone sees the tiger and they are not blue then the tiger eats the lion.
</PREMISES>
<CONCLUSION>
The bear does not like the lion.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bear is big.
FOL: Big(Bear)
TEXT: The bear is nice.
FOL: Nice(Bear)
TEXT: The bear is rough.
FOL: Rough(Bear)
TEXT: The bear sees the squirrel.
FOL: Sees(Bear, Squirrel)
TEXT: The bear sees the tiger.
FOL: Sees(Bear, Tiger)
TEXT: The lion eats the squirrel.
FOL: Eats(Lion, Squirrel)
TEXT: The lion is not green.
FOL: -Green(Lion)
TEXT: The lion likes the tiger.
FOL: Likes(Lion, Tiger)
TEXT: The squirrel eats the tiger.
FOL: Eats(Squirrel, Tiger)
TEXT: The squirrel likes the lion.
FOL: Likes(Squirrel, Lion)
TEXT: The squirrel likes the tiger.
FOL: Likes(Squirrel, Tiger)
TEXT: The tiger eats the bear.
FOL: Eats(Tiger, Bear)
TEXT: The tiger is not nice.
FOL: -Nice(Tiger)
TEXT: The tiger is rough.
FOL: Rough(Tiger)
TEXT: The tiger does not like the squirrel.
FOL: -Likes(Tiger, Squirrel)
TEXT: The tiger sees the lion.
FOL: Sees(Tiger, Lion)
TEXT: If someone likes the tiger and the tiger eats the bear then the bear eats the tiger.
FOL: all x. (Likes(x, Tiger) & Eats(Tiger, Bear) -> Eats(Bear, Tiger))
TEXT: If someone eats the tiger then the tiger is blue.
FOL: all x. (Eats(x, Tiger) -> Blue(Tiger))
TEXT: If someone sees the bear then they do not like the lion.
FOL: all x. (Sees(x, Bear) -> -Likes(x, Lion))
TEXT: If someone is blue then they see the bear.
FOL: all x. (Blue(x) -> Sees(x, Bear))
TEXT: If someone eats the bear then the bear likes the tiger.
FOL: all x. (Eats(x, Bear) -> Likes(Bear, Tiger))
TEXT: If someone sees the bear then the bear is blue.
FOL: all x. (Sees(x, Bear) -> Blue(Bear))
TEXT: If someone likes the tiger and the tiger sees the lion then they eat the lion.
FOL: all x. (Likes(x, Tiger) & Sees(Tiger, Lion) -> Eats(x, Lion))
TEXT: If someone sees the tiger and they are not blue then the tiger eats the lion.
FOL: all x. (Sees(x, Tiger) & -Blue(x) -> Eats(Tiger, Lion))
TEXT: The bear does not like the lion.
FOL: -Likes(Bear, Lion)
</EVALUATE>
Processed: True

Generation 2:
TEXT: The bear is big.
FOL: Big(Bear)
TEXT: The bear is nice.
FOL: Nice(Bear)
TEXT: The bear is rough.
FOL: Rough(Bear)
TEXT: The bear sees the squirrel.
FOL: Sees(Bear, Squirrel)
TEXT: The bear sees the tiger.
FOL: Sees(Bear, Tiger)
TEXT: The lion eats the squirrel.
FOL: Eats(Lion, Squirrel)
TEXT: The lion is not green.
FOL: -Green(Lion)
TEXT: The lion likes the tiger.
FOL: Likes(Lion, Tiger)
TEXT: The squirrel eats the tiger.
FOL: Eats(Squirrel, Tiger)
TEXT: The squirrel likes the lion.
FOL: Likes(Squirrel, Lion)
TEXT: The squirrel likes the tiger.
FOL: Likes(Squirrel, Tiger)
TEXT: The tiger eats the bear.
FOL: Eats(Tiger, Bear)
TEXT: The tiger is not nice.
FOL: -Nice(Tiger)
TEXT: The tiger is rough.
FOL: Rough(Tiger)
TEXT: The tiger does not like the squirrel.
FOL: -Likes(Tiger, Squirrel)
TEXT: The tiger sees the lion.
FOL: Sees(Tiger, Lion)
TEXT: If someone likes the tiger and the tiger eats the bear then the bear eats the tiger.
FOL: all x. ((Likes(x, Tiger) & Eats(Tiger, Bear)) -> Eats(Bear, Tiger))
TEXT: If someone eats the tiger then the tiger is blue.
FOL: all x. (Eats(x, Tiger) -> Blue(Tiger))
TEXT: If someone sees the bear then they do not like the lion.
FOL: all x. (Sees(x, Bear) -> -Likes(x, Lion))
TEXT: If someone is blue then they see the bear.
FOL: all x. (Blue(x) -> Sees(x, Bear))
TEXT: If someone eats the bear then the bear likes the tiger.
FOL: all x. (Eats(x, Bear) -> Likes(Bear, Tiger))
TEXT: If someone sees the bear then the bear is blue.
FOL: all x. (Sees(x, Bear) -> Blue(Bear))
TEXT: If someone likes the tiger and the tiger sees the lion then they eat the lion.
FOL: all x. ((Likes(x, Tiger) & Sees(Tiger, Lion)) -> Eats(x, Lion))
TEXT: If someone sees the tiger and they are not blue then the tiger eats the lion.
FOL: all x. ((Sees(x, Tiger) & -Blue(x)) -> Eats(Tiger, Lion))
TEXT: The bear does not like the lion.
FOL: -Likes(Bear, Lion)
Processed: True

Generation 3:
TEXT: The bear is big.
FOL: Big(Bear)
TEXT: The bear is nice.
FOL: Nice(Bear)
TEXT: The bear is rough.
FOL: Rough(Bear)
TEXT: The bear sees the squirrel.
FOL: Sees(Bear, Squirrel)
TEXT: The bear sees the tiger.
FOL: Sees(Bear, Tiger)
TEXT: The lion eats the squirrel.
FOL: Eats(Lion, Squirrel)
TEXT: The lion is not green.
FOL: -Green(Lion)
TEXT: The lion likes the tiger.
FOL: Likes(Lion, Tiger)
TEXT: The squirrel eats the tiger.
FOL: Eats(Squirrel, Tiger)
TEXT: The squirrel likes the lion.
FOL: Likes(Squirrel, Lion)
TEXT: The squirrel likes the tiger.
FOL: Likes(Squirrel, Tiger)
TEXT: The tiger eats the bear.
FOL: Eats(Tiger, Bear)
TEXT: The tiger is not nice.
FOL: -Nice(Tiger)
TEXT: The tiger is rough.
FOL: Rough(Tiger)
TEXT: The tiger does not like the squirrel.
FOL: -Likes(Tiger, Squirrel)
TEXT: The tiger sees the lion.
FOL: Sees(Tiger, Lion)
TEXT: If someone likes the tiger and the tiger eats the bear then the bear eats the tiger.
FOL: all x. (Likes(x, Tiger) & Eats(Tiger, Bear) -> Eats(Bear, Tiger))
TEXT: If someone eats the tiger then the tiger is blue.
FOL: all x. (Eats(x, Tiger) -> Blue(Tiger))
TEXT: If someone sees the bear then they do not like the lion.
FOL: all x. (Sees(x, Bear) -> -Likes(x, Lion))
TEXT: If someone is blue then they see the bear.
FOL: all x. (Blue(x) -> Sees(x, Bear))
TEXT: If someone eats the bear then the bear likes the tiger.
FOL: all x. (Eats(x, Bear) -> Likes(Bear, Tiger))
TEXT: If someone sees the bear then the bear is blue.
FOL: all x. (Sees(x, Bear) -> Blue(Bear))
TEXT: If someone likes the tiger and the tiger sees the lion then they eat the lion.
FOL: all x. (Likes(x, Tiger) & Sees(Tiger, Lion) -> Eats(x, Lion))
TEXT: If someone sees the tiger and they are not blue then the tiger eats the lion.
FOL: all x. (Sees(x, Tiger) & -Blue(x) -> Eats(Tiger, Lion))
TEXT: The bear does not like the lion.
FOL: -Likes(Bear, Lion)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 37 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle is green.
The bald eagle is young.
The bald eagle sees the dog.
The bear likes the dog.
The bear needs the cow.
The cow needs the dog.
The cow sees the dog.
The dog is blue.
The dog is green.
The dog is young.
The dog needs the bear.
The dog needs the cow.
If someone sees the bald eagle and they are nice then the bald eagle needs the bear.
If someone is nice and young then they need the dog.
If someone likes the cow and the cow needs the dog then the cow is kind.
If someone is young and blue then they like the bear.
If someone is blue and they like the bear then the bear likes the cow.
If someone is green and they need the bear then they need the dog.
If someone sees the bear then they are nice.
If someone is kind then they see the bear.
</PREMISES>
<CONCLUSION>
The bear likes the cow.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle is green.
FOL: Green(BaldEagle)
TEXT: The bald eagle is young.
FOL: Young(BaldEagle)
TEXT: The bald eagle sees the dog.
FOL: Sees(BaldEagle, Dog)
TEXT: The bear likes the dog.
FOL: Likes(Bear, Dog)
TEXT: The bear needs the cow.
FOL: Needs(Bear, Cow)
TEXT: The cow needs the dog.
FOL: Needs(Cow, Dog)
TEXT: The cow sees the dog.
FOL: Sees(Cow, Dog)
TEXT: The dog is blue.
FOL: Blue(Dog)
TEXT: The dog is green.
FOL: Green(Dog)
TEXT: The dog is young.
FOL: Young(Dog)
TEXT: The dog needs the bear.
FOL: Needs(Dog, Bear)
TEXT: The dog needs the cow.
FOL: Needs(Dog, Cow)
TEXT: If someone sees the bald eagle and they are nice then the bald eagle needs the bear.
FOL: all x. (Sees(x, BaldEagle) & Nice(x) -> Needs(BaldEagle, Bear))
TEXT: If someone is nice and young then they need the dog.
FOL: all x. (Nice(x) & Young(x) -> Needs(x, Dog))
TEXT: If someone likes the cow and the cow needs the dog then the cow is kind.
FOL: all x. (Likes(x, Cow) & Needs(Cow, Dog) -> Kind(Cow))
TEXT: If someone is young and blue then they like the bear.
FOL: all x. (Young(x) & Blue(x) -> Likes(x, Bear))
TEXT: If someone is blue and they like the bear then the bear likes the cow.
FOL: all x. (Blue(x) & Likes(x, Bear) -> Likes(Bear, Cow))
TEXT: If someone is green and they need the bear then they need the dog.
FOL: all x. (Green(x) & Needs(x, Bear) -> Needs(x, Dog))
TEXT: If someone sees the bear then they are nice.
FOL: all x. (Sees(x, Bear) -> Nice(x))
TEXT: If someone is kind then they see the bear.
FOL: all x. (Kind(x) -> Sees(x, Bear))
TEXT: The bear likes the cow.
FOL: Likes(Bear, Cow)
</EVALUATE>
Processed: True

Generation 2:
TEXT: The bald eagle is green.
FOL: Green(BaldEagle)
TEXT: The bald eagle is young.
FOL: Young(BaldEagle)
TEXT: The bald eagle sees the dog.
FOL: Sees(BaldEagle, Dog)
TEXT: The bear likes the dog.
FOL: Likes(Bear, Dog)
TEXT: The bear needs the cow.
FOL: Needs(Bear, Cow)
TEXT: The cow needs the dog.
FOL: Needs(Cow, Dog)
TEXT: The cow sees the dog.
FOL: Sees(Cow, Dog)
TEXT: The dog is blue.
FOL: Blue(Dog)
TEXT: The dog is green.
FOL: Green(Dog)
TEXT: The dog is young.
FOL: Young(Dog)
TEXT: The dog needs the bear.
FOL: Needs(Dog, Bear)
TEXT: The dog needs the cow.
FOL: Needs(Dog, Cow)
TEXT: If someone sees the bald eagle and they are nice then the bald eagle needs the bear.
FOL: all x. (Sees(x, BaldEagle) & Nice(x) -> Needs(BaldEagle, Bear))
TEXT: If someone is nice and young then they need the dog.
FOL: all x. (Nice(x) & Young(x) -> Needs(x, Dog))
TEXT: If someone likes the cow and the cow needs the dog then the cow is kind.
FOL: all x. (Likes(x, Cow) & Needs(Cow, Dog) -> Kind(Cow))
TEXT: If someone is young and blue then they like the bear.
FOL: all x. (Young(x) & Blue(x) -> Likes(x, Bear))
TEXT: If someone is blue and they like the bear then the bear likes the cow.
FOL: all x. (Blue(x) & Likes(x, Bear) -> Likes(Bear, Cow))
TEXT: If someone is green and they need the bear then they need the dog.
FOL: all x. (Green(x) & Needs(x, Bear) -> Needs(x, Dog))
TEXT: If someone sees the bear then they are nice.
FOL: all x. (Sees(x, Bear) -> Nice(x))
TEXT: If someone is kind then they see the bear.
FOL: all x. (Kind(x) -> Sees(x, Bear))
TEXT: The bear likes the cow.
FOL: Likes(Bear, Cow)
</EVALUATE>
Processed: True

Generation 3:
TEXT: The bald eagle is green.
FOL: Green(BaldEagle)
TEXT: The bald eagle is young.
FOL: Young(BaldEagle)
TEXT: The bald eagle sees the dog.
FOL: Sees(BaldEagle, Dog)
TEXT: The bear likes the dog.
FOL: Likes(Bear, Dog)
TEXT: The bear needs the cow.
FOL: Needs(Bear, Cow)
TEXT: The cow needs the dog.
FOL: Needs(Cow, Dog)
TEXT: The cow sees the dog.
FOL: Sees(Cow, Dog)
TEXT: The dog is blue.
FOL: Blue(Dog)
TEXT: The dog is green.
FOL: Green(Dog)
TEXT: The dog is young.
FOL: Young(Dog)
TEXT: The dog needs the bear.
FOL: Needs(Dog, Bear)
TEXT: The dog needs the cow.
FOL: Needs(Dog, Cow)
TEXT: If someone sees the bald eagle and they are nice then the bald eagle needs the bear.
FOL: all x. (Sees(x, BaldEagle) & Nice(x) -> Needs(BaldEagle, Bear))
TEXT: If someone is nice and young then they need the dog.
FOL: all x. (Nice(x) & Young(x) -> Needs(x, Dog))
TEXT: If someone likes the cow and the cow needs the dog then the cow is kind.
FOL: all x. (Likes(x, Cow) & Needs(Cow, Dog) -> Kind(Cow))
TEXT: If someone is young and blue then they like the bear.
FOL: all x. (Young(x) & Blue(x) -> Likes(x, Bear))
TEXT: If someone is blue and they like the bear then the bear likes the cow.
FOL: all x. (Blue(x) & Likes(x, Bear) -> Likes(Bear, Cow))
TEXT: If someone is green and they need the bear then they need the dog.
FOL: all x. (Green(x) & Needs(x, Bear) -> Needs(x, Dog))
TEXT: If someone sees the bear then they are nice.
FOL: all x. (Sees(x, Bear) -> Nice(x))
TEXT: If someone is kind then they see the bear.
FOL: all x. (Kind(x) -> Sees(x, Bear))
TEXT: The bear likes the cow.
FOL: Likes(Bear, Cow)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 38 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is kind.
Anne is nice.
Charlie is kind.
Charlie is quiet.
Charlie is red.
Erin is furry.
Erin is quiet.
Erin is red.
Harry is kind.
Harry is nice.
Harry is quiet.
All cold, nice people are furry.
If Harry is quiet then Harry is furry.
Red, cold people are big.
If someone is kind then they are quiet.
All kind, nice people are quiet.
All furry, cold people are red.
If Anne is quiet and Anne is kind then Anne is cold.
</PREMISES>
<CONCLUSION>
Anne is not quiet.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is kind.
FOL: Kind(Anne)
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Charlie is kind.
FOL: Kind(Charlie)
TEXT: Charlie is quiet.
FOL: Quiet(Charlie)
TEXT: Charlie is red.
FOL: Red(Charlie)
TEXT: Erin is furry.
FOL: Furry(Erin)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Erin is red.
FOL: Red(Erin)
TEXT: Harry is kind.
FOL: Kind(Harry)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: Harry is quiet.
FOL: Quiet(Harry)
TEXT: All cold, nice people are furry.
FOL: all x. (Cold(x) & Nice(x) -> Furry(x))
TEXT: If Harry is quiet then Harry is furry.
FOL: Quiet(Harry) -> Furry(Harry)
TEXT: Red, cold people are big.
FOL: all x. (Red(x) & Cold(x) -> Big(x))
TEXT: If someone is kind then they are quiet.
FOL: all x. (Kind(x) -> Quiet(x))
TEXT: All kind, nice people are quiet.
FOL: all x. (Kind(x) & Nice(x) -> Quiet(x))
TEXT: All furry, cold people are red.
FOL: all x. (Furry(x) & Cold(x) -> Red(x))
TEXT: If Anne is quiet and Anne is kind then Anne is cold.
FOL: (Quiet(Anne) & Kind(Anne)) -> Cold(Anne)
TEXT: Anne is not quiet.
FOL: -Quiet(Anne)
Processed: False

Generation 2:
TEXT: Anne is kind.
FOL: Kind(Anne)
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Charlie is kind.
FOL: Kind(Charlie)
TEXT: Charlie is quiet.
FOL: Quiet(Charlie)
TEXT: Charlie is red.
FOL: Red(Charlie)
TEXT: Erin is furry.
FOL: Furry(Erin)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Erin is red.
FOL: Red(Erin)
TEXT: Harry is kind.
FOL: Kind(Harry)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: Harry is quiet.
FOL: Quiet(Harry)
TEXT: All cold, nice people are furry.
FOL: all x. (Cold(x) & Nice(x) -> Furry(x))
TEXT: If Harry is quiet then Harry is furry.
FOL: Quiet(Harry) -> Furry(Harry)
TEXT: Red, cold people are big.
FOL: all x. (Red(x) & Cold(x) -> Big(x))
TEXT: If someone is kind then they are quiet.
FOL: all x. (Kind(x) -> Quiet(x))
TEXT: All kind, nice people are quiet.
FOL: all x. (Kind(x) & Nice(x) -> Quiet(x))
TEXT: All furry, cold people are red.
FOL: all x. (Furry(x) & Cold(x) -> Red(x))
TEXT: If Anne is quiet and Anne is kind then Anne is cold.
FOL: (Quiet(Anne) & Kind(Anne)) -> Cold(Anne)
TEXT: Anne is not quiet.
FOL: -Quiet(Anne)
Processed: False

Generation 3:
TEXT: Anne is kind.
FOL: Kind(Anne)
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Charlie is kind.
FOL: Kind(Charlie)
TEXT: Charlie is quiet.
FOL: Quiet(Charlie)
TEXT: Charlie is red.
FOL: Red(Charlie)
TEXT: Erin is furry.
FOL: Furry(Erin)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Erin is red.
FOL: Red(Erin)
TEXT: Harry is kind.
FOL: Kind(Harry)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: Harry is quiet.
FOL: Quiet(Harry)
TEXT: All cold, nice people are furry.
FOL: all x. (Cold(x) & Nice(x) -> Furry(x))
TEXT: If Harry is quiet then Harry is furry.
FOL: Quiet(Harry) -> Furry(Harry)
TEXT: Red, cold people are big.
FOL: all x. (Red(x) & Cold(x) -> Big(x))
TEXT: If someone is kind then they are quiet.
FOL: all x. (Kind(x) -> Quiet(x))
TEXT: All kind, nice people are quiet.
FOL: all x. (Kind(x) & Nice(x) -> Quiet(x))
TEXT: All furry, cold people are red.
FOL: all x. (Furry(x) & Cold(x) -> Red(x))
TEXT: If Anne is quiet and Anne is kind then Anne is cold.
FOL: (Quiet(Anne) & Kind(Anne)) -> Cold(Anne)
TEXT: Anne is not quiet.
FOL: -Quiet(Anne)
Processed: False

Reference: False
========================================

=== Example 39 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is cold.
Bob is green.
Bob is red.
Bob is round.
Fiona is green.
Fiona is smart.
Gary is green.
Gary is red.
Harry is green.
Harry is smart.
All smart people are cold.
If someone is red then they are rough.
All nice, red people are green.
All red, rough people are round.
If someone is rough and round then they are smart.
If Gary is smart and Gary is cold then Gary is nice.
Green, smart people are red.
</PREMISES>
<CONCLUSION>
Harry is not smart.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is cold.
FOL: Cold(Bob)
TEXT: Bob is green.
FOL: Green(Bob)
TEXT: Bob is red.
FOL: Red(Bob)
TEXT: Bob is round.
FOL: Round(Bob)
TEXT: Fiona is green.
FOL: Green(Fiona)
TEXT: Fiona is smart.
FOL: Smart(Fiona)
TEXT: Gary is green.
FOL: Green(Gary)
TEXT: Gary is red.
FOL: Red(Gary)
TEXT: Harry is green.
FOL: Green(Harry)
TEXT: Harry is smart.
FOL: Smart(Harry)
TEXT: All smart people are cold.
FOL: all x. (Smart(x) -> Cold(x))
TEXT: If someone is red then they are rough.
FOL: all x. (Red(x) -> Rough(x))
TEXT: All nice, red people are green.
FOL: all x. (Nice(x) & Red(x) -> Green(x))
TEXT: All red, rough people are round.
FOL: all x. (Red(x) & Rough(x) -> Round(x))
TEXT: If someone is rough and round then they are smart.
FOL: all x. (Rough(x) & Round(x) -> Smart(x))
TEXT: If Gary is smart and Gary is cold then Gary is nice.
FOL: (Smart(Gary) & Cold(Gary) -> Nice(Gary))
TEXT: Green, smart people are red.
FOL: all x. (Green(x) & Smart(x) -> Red(x))
TEXT: Harry is not smart.
FOL: -Smart(Harry)
</EVALUATE>
Processed: False

Generation 2:
TEXT: Bob is cold.
FOL: Cold(Bob)
TEXT: Bob is green.
FOL: Green(Bob)
TEXT: Bob is red.
FOL: Red(Bob)
TEXT: Bob is round.
FOL: Round(Bob)
TEXT: Fiona is green.
FOL: Green(Fiona)
TEXT: Fiona is smart.
FOL: Smart(Fiona)
TEXT: Gary is green.
FOL: Green(Gary)
TEXT: Gary is red.
FOL: Red(Gary)
TEXT: Harry is green.
FOL: Green(Harry)
TEXT: Harry is smart.
FOL: Smart(Harry)
TEXT: All smart people are cold.
FOL: all x. (Smart(x) -> Cold(x))
TEXT: If someone is red then they are rough.
FOL: all x. (Red(x) -> Rough(x))
TEXT: All nice, red people are green.
FOL: all x. ((Nice(x) & Red(x)) -> Green(x))
TEXT: All red, rough people are round.
FOL: all x. ((Red(x) & Rough(x)) -> Round(x))
TEXT: If someone is rough and round then they are smart.
FOL: all x. ((Rough(x) & Round(x)) -> Smart(x))
TEXT: If Gary is smart and Gary is cold then Gary is nice.
FOL: (Smart(Gary) & Cold(Gary)) -> Nice(Gary)
TEXT: Green, smart people are red.
FOL: all x. ((Green(x) & Smart(x)) -> Red(x))
TEXT: Harry is not smart.
FOL: -Smart(Harry)
Processed: False

Generation 3:
TEXT: Bob is cold.
FOL: Cold(Bob)
TEXT: Bob is green.
FOL: Green(Bob)
TEXT: Bob is red.
FOL: Red(Bob)
TEXT: Bob is round.
FOL: Round(Bob)
TEXT: Fiona is green.
FOL: Green(Fiona)
TEXT: Fiona is smart.
FOL: Smart(Fiona)
TEXT: Gary is green.
FOL: Green(Gary)
TEXT: Gary is red.
FOL: Red(Gary)
TEXT: Harry is green.
FOL: Green(Harry)
TEXT: Harry is smart.
FOL: Smart(Harry)
TEXT: All smart people are cold.
FOL: all x. (Smart(x) -> Cold(x))
TEXT: If someone is red then they are rough.
FOL: all x. (Red(x) -> Rough(x))
TEXT: All nice, red people are green.
FOL: all x. ((Nice(x) & Red(x)) -> Green(x))
TEXT: All red, rough people are round.
FOL: all x. ((Red(x) & Rough(x)) -> Round(x))
TEXT: If someone is rough and round then they are smart.
FOL: all x. ((Rough(x) & Round(x)) -> Smart(x))
TEXT: If Gary is smart and Gary is cold then Gary is nice.
FOL: ((Smart(Gary) & Cold(Gary)) -> Nice(Gary))
TEXT: Green, smart people are red.
FOL: all x. ((Green(x) & Smart(x)) -> Red(x))
TEXT: Harry is not smart.
FOL: -Smart(Harry)
</EVALUATE>
Processed: False

Reference: False
========================================

=== Example 40 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is green.
Bob is not green.
Bob is red.
Bob is round.
Fiona is not kind.
Fiona is young.
Gary is cold.
Young, round people are kind.
If someone is quiet and green then they are round.
If someone is cold and red then they are not round.
Red people are young.
If Gary is round and Gary is young then Gary is kind.
If Anne is quiet and Anne is round then Anne is red.
Green people are quiet.
If Bob is cold then Bob is not quiet.
</PREMISES>
<CONCLUSION>
Bob is young.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is green.
FOL: Green(Anne)
TEXT: Bob is not green.
FOL: -Green(Bob)
TEXT: Bob is red.
FOL: Red(Bob)
TEXT: Bob is round.
FOL: Round(Bob)
TEXT: Fiona is not kind.
FOL: -Kind(Fiona)
TEXT: Fiona is young.
FOL: Young(Fiona)
TEXT: Gary is cold.
FOL: Cold(Gary)
TEXT: Young, round people are kind.
FOL: all x. (Young(x) & Round(x) -> Kind(x))
TEXT: If someone is quiet and green then they are round.
FOL: all x. (Quiet(x) & Green(x) -> Round(x))
TEXT: If someone is cold and red then they are not round.
FOL: all x. (Cold(x) & Red(x) -> -Round(x))
TEXT: Red people are young.
FOL: all x. (Red(x) -> Young(x))
TEXT: If Gary is round and Gary is young then Gary is kind.
FOL: (Round(Gary) & Young(Gary) -> Kind(Gary))
TEXT: If Anne is quiet and Anne is round then Anne is red.
FOL: (Quiet(Anne) & Round(Anne) -> Red(Anne))
TEXT: Green people are quiet.
FOL: all x. (Green(x) -> Quiet(x))
TEXT: If Bob is cold then Bob is not quiet.
FOL: (Cold(Bob) -> -Quiet(Bob))
TEXT: Bob is young.
FOL: Young(Bob)
Processed: True

Generation 2:
TEXT: Anne is green.
FOL: Green(Anne)
TEXT: Bob is not green.
FOL: -Green(Bob)
TEXT: Bob is red.
FOL: Red(Bob)
TEXT: Bob is round.
FOL: Round(Bob)
TEXT: Fiona is not kind.
FOL: -Kind(Fiona)
TEXT: Fiona is young.
FOL: Young(Fiona)
TEXT: Gary is cold.
FOL: Cold(Gary)
TEXT: Young, round people are kind.
FOL: all x. (Young(x) & Round(x) -> Kind(x))
TEXT: If someone is quiet and green then they are round.
FOL: all x. (Quiet(x) & Green(x) -> Round(x))
TEXT: If someone is cold and red then they are not round.
FOL: all x. (Cold(x) & Red(x) -> -Round(x))
TEXT: Red people are young.
FOL: all x. (Red(x) -> Young(x))
TEXT: If Gary is round and Gary is young then Gary is kind.
FOL: (Round(Gary) & Young(Gary) -> Kind(Gary))
TEXT: If Anne is quiet and Anne is round then Anne is red.
FOL: (Quiet(Anne) & Round(Anne) -> Red(Anne))
TEXT: Green people are quiet.
FOL: all x. (Green(x) -> Quiet(x))
TEXT: If Bob is cold then Bob is not quiet.
FOL: (Cold(Bob) -> -Quiet(Bob))
TEXT: Bob is young.
FOL: Young(Bob)
Processed: True

Generation 3:
TEXT: Anne is green.
FOL: Green(Anne)
TEXT: Bob is not green.
FOL: -Green(Bob)
TEXT: Bob is red.
FOL: Red(Bob)
TEXT: Bob is round.
FOL: Round(Bob)
TEXT: Fiona is not kind.
FOL: -Kind(Fiona)
TEXT: Fiona is young.
FOL: Young(Fiona)
TEXT: Gary is cold.
FOL: Cold(Gary)
TEXT: Young, round people are kind.
FOL: all x. (Young(x) & Round(x) -> Kind(x))
TEXT: If someone is quiet and green then they are round.
FOL: all x. (Quiet(x) & Green(x) -> Round(x))
TEXT: If someone is cold and red then they are not round.
FOL: all x. (Cold(x) & Red(x) -> -Round(x))
TEXT: Red people are young.
FOL: all x. (Red(x) -> Young(x))
TEXT: If Gary is round and Gary is young then Gary is kind.
FOL: (Round(Gary) & Young(Gary) -> Kind(Gary))
TEXT: If Anne is quiet and Anne is round then Anne is red.
FOL: (Quiet(Anne) & Round(Anne) -> Red(Anne))
TEXT: Green people are quiet.
FOL: all x. (Green(x) -> Quiet(x))
TEXT: If Bob is cold then Bob is not quiet.
FOL: (Cold(Bob) -> -Quiet(Bob))
TEXT: Bob is young.
FOL: Young(Bob)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 41 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bear chases the cow.
The bear eats the rabbit.
The bear is big.
The bear is round.
The bear sees the cow.
The bear sees the dog.
The cow eats the rabbit.
The dog chases the rabbit.
The dog eats the rabbit.
The rabbit chases the bear.
The rabbit chases the cow.
The rabbit is big.
The rabbit is red.
The rabbit is round.
If something sees the bear then it is cold.
If something eats the rabbit then the rabbit is round.
If something sees the rabbit and the rabbit chases the cow then the cow eats the bear.
If something sees the bear and it chases the dog then the dog eats the bear.
If something eats the bear then it sees the rabbit.
If something sees the rabbit and the rabbit chases the cow then it is big.
If something sees the dog and the dog eats the rabbit then the rabbit is round.
If something chases the bear then it eats the bear.
</PREMISES>
<CONCLUSION>
The cow sees the rabbit.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bear chases the cow.
FOL: Chases(Bear, Cow)
TEXT: The bear eats the rabbit.
FOL: Eats(Bear, Rabbit)
TEXT: The bear is big.
FOL: Big(Bear)
TEXT: The bear is round.
FOL: Round(Bear)
TEXT: The bear sees the cow.
FOL: Sees(Bear, Cow)
TEXT: The bear sees the dog.
FOL: Sees(Bear, Dog)
TEXT: The cow eats the rabbit.
FOL: Eats(Cow, Rabbit)
TEXT: The dog chases the rabbit.
FOL: Chases(Dog, Rabbit)
TEXT: The dog eats the rabbit.
FOL: Eats(Dog, Rabbit)
TEXT: The rabbit chases the bear.
FOL: Chases(Rabbit, Bear)
TEXT: The rabbit chases the cow.
FOL: Chases(Rabbit, Cow)
TEXT: The rabbit is big.
FOL: Big(Rabbit)
TEXT: The rabbit is red.
FOL: Red(Rabbit)
TEXT: The rabbit is round.
FOL: Round(Rabbit)
TEXT: If something sees the bear then it is cold.
FOL: all x. (Sees(x, Bear) -> Cold(x))
TEXT: If something eats the rabbit then the rabbit is round.
FOL: all x. (Eats(x, Rabbit) -> Round(Rabbit))
TEXT: If something sees the rabbit and the rabbit chases the cow then the cow eats the bear.
FOL: all x. ((Sees(x, Rabbit) & Chases(Rabbit, Cow)) -> Eats(Cow, Bear))
TEXT: If something sees the bear and it chases the dog then the dog eats the bear.
FOL: all x. ((Sees(x, Bear) & Chases(x, Dog)) -> Eats(Dog, Bear))
TEXT: If something eats the bear then it sees the rabbit.
FOL: all x. (Eats(x, Bear) -> Sees(x, Rabbit))
TEXT: If something sees the rabbit and the rabbit chases the cow then it is big.
FOL: all x. ((Sees(x, Rabbit) & Chases(Rabbit, Cow)) -> Big(x))
TEXT: If something sees the dog and the dog eats the rabbit then the rabbit is round.
FOL: all x. ((Sees(x, Dog) & Eats(Dog, Rabbit)) -> Round(Rabbit))
TEXT: If something chases the bear then it eats the bear.
FOL: all x. (Chases(x, Bear) -> Eats(x, Bear))
TEXT: The cow sees the rabbit.
FOL: Sees(Cow, Rabbit)
</EVALUATE>
Processed: True

Generation 2:
TEXT: The bear chases the cow.
FOL: Chases(Bear, Cow)
TEXT: The bear eats the rabbit.
FOL: Eats(Bear, Rabbit)
TEXT: The bear is big.
FOL: Big(Bear)
TEXT: The bear is round.
FOL: Round(Bear)
TEXT: The bear sees the cow.
FOL: Sees(Bear, Cow)
TEXT: The bear sees the dog.
FOL: Sees(Bear, Dog)
TEXT: The cow eats the rabbit.
FOL: Eats(Cow, Rabbit)
TEXT: The dog chases the rabbit.
FOL: Chases(Dog, Rabbit)
TEXT: The dog eats the rabbit.
FOL: Eats(Dog, Rabbit)
TEXT: The rabbit chases the bear.
FOL: Chases(Rabbit, Bear)
TEXT: The rabbit chases the cow.
FOL: Chases(Rabbit, Cow)
TEXT: The rabbit is big.
FOL: Big(Rabbit)
TEXT: The rabbit is red.
FOL: Red(Rabbit)
TEXT: The rabbit is round.
FOL: Round(Rabbit)
TEXT: If something sees the bear then it is cold.
FOL: all x. (Sees(x, Bear) -> Cold(x))
TEXT: If something eats the rabbit then the rabbit is round.
FOL: all x. (Eats(x, Rabbit) -> Round(Rabbit))
TEXT: If something sees the rabbit and the rabbit chases the cow then the cow eats the bear.
FOL: all x. ((Sees(x, Rabbit) & Chases(Rabbit, Cow)) -> Eats(Cow, Bear))
TEXT: If something sees the bear and it chases the dog then the dog eats the bear.
FOL: all x. ((Sees(x, Bear) & Chases(x, Dog)) -> Eats(Dog, Bear))
TEXT: If something eats the bear then it sees the rabbit.
FOL: all x. (Eats(x, Bear) -> Sees(x, Rabbit))
TEXT: If something sees the rabbit and the rabbit chases the cow then it is big.
FOL: all x. ((Sees(x, Rabbit) & Chases(Rabbit, Cow)) -> Big(x))
TEXT: If something sees the dog and the dog eats the rabbit then the rabbit is round.
FOL: all x. ((Sees(x, Dog) & Eats(Dog, Rabbit)) -> Round(Rabbit))
TEXT: If something chases the bear then it eats the bear.
FOL: all x. (Chases(x, Bear) -> Eats(x, Bear))
TEXT: The cow sees the rabbit.
FOL: Sees(Cow, Rabbit)
</EVALUATE>
Processed: True

Generation 3:
TEXT: The bear chases the cow.
FOL: Chases(Bear, Cow)

TEXT: The bear eats the rabbit.
FOL: Eats(Bear, Rabbit)

TEXT: The bear is big.
FOL: Big(Bear)

TEXT: The bear is round.
FOL: Round(Bear)

TEXT: The bear sees the cow.
FOL: Sees(Bear, Cow)

TEXT: The bear sees the dog.
FOL: Sees(Bear, Dog)

TEXT: The cow eats the rabbit.
FOL: Eats(Cow, Rabbit)

TEXT: The dog chases the rabbit.
FOL: Chases(Dog, Rabbit)

TEXT: The dog eats the rabbit.
FOL: Eats(Dog, Rabbit)

TEXT: The rabbit chases the bear.
FOL: Chases(Rabbit, Bear)

TEXT: The rabbit chases the cow.
FOL: Chases(Rabbit, Cow)

TEXT: The rabbit is big.
FOL: Big(Rabbit)

TEXT: The rabbit is red.
FOL: Red(Rabbit)

TEXT: The rabbit is round.
FOL: Round(Rabbit)

TEXT: If something sees the bear then it is cold.
FOL: all x. (Sees(x, Bear) -> Cold(x))

TEXT: If something eats the rabbit then the rabbit is round.
FOL: all x. (Eats(x, Rabbit) -> Round(Rabbit))

TEXT: If something sees the rabbit and the rabbit chases the cow then the cow eats the bear.
FOL: all x. ((Sees(x, Rabbit) & Chases(Rabbit, Cow)) -> Eats(Cow, Bear))

TEXT: If something sees the bear and it chases the dog then the dog eats the bear.
FOL: all x. ((Sees(x, Bear) & Chases(x, Dog)) -> Eats(Dog, Bear))

TEXT: If something eats the bear then it sees the rabbit.
FOL: all x. (Eats(x, Bear) -> Sees(x, Rabbit))

TEXT: If something sees the rabbit and the rabbit chases the cow then it is big.
FOL: all x. ((Sees(x, Rabbit) & Chases(Rabbit, Cow)) -> Big(x))

TEXT: If something sees the dog and the dog eats the rabbit then the rabbit is round.
FOL: all x. ((Sees(x, Dog) & Eats(Dog, Rabbit)) -> Round(Rabbit))

TEXT: If something chases the bear then it eats the bear.
FOL: all x. (Chases(x, Bear) -> Eats(x, Bear))

TEXT: The cow sees the rabbit.
FOL: Sees(Cow, Rabbit)
Processed: True

Reference: True
========================================

=== Example 42 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bear eats the dog.
The bear eats the rabbit.
The bear is round.
The bear needs the rabbit.
The bear needs the tiger.
The bear sees the rabbit.
The dog eats the bear.
The rabbit eats the tiger.
The rabbit is round.
The tiger eats the bear.
The tiger is cold.
The tiger is young.
If something eats the tiger then the tiger needs the dog.
If the bear sees the dog and the dog eats the tiger then the dog eats the bear.
If something eats the bear then it sees the tiger.
If the tiger sees the rabbit then the rabbit eats the bear.
If something eats the bear and the bear sees the rabbit then it sees the dog.
If something sees the dog then it sees the rabbit.
</PREMISES>
<CONCLUSION>
The tiger eats the dog.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bear eats the dog.
FOL: Eats(Bear, Dog)
TEXT: The bear eats the rabbit.
FOL: Eats(Bear, Rabbit)
TEXT: The bear is round.
FOL: Round(Bear)
TEXT: The bear needs the rabbit.
FOL: Needs(Bear, Rabbit)
TEXT: The bear needs the tiger.
FOL: Needs(Bear, Tiger)
TEXT: The bear sees the rabbit.
FOL: Sees(Bear, Rabbit)
TEXT: The dog eats the bear.
FOL: Eats(Dog, Bear)
TEXT: The rabbit eats the tiger.
FOL: Eats(Rabbit, Tiger)
TEXT: The rabbit is round.
FOL: Round(Rabbit)
TEXT: The tiger eats the bear.
FOL: Eats(Tiger, Bear)
TEXT: The tiger is cold.
FOL: Cold(Tiger)
TEXT: The tiger is young.
FOL: Young(Tiger)
TEXT: If something eats the tiger then the tiger needs the dog.
FOL: all x. (Eats(x, Tiger) -> Needs(Tiger, Dog))
TEXT: If the bear sees the dog and the dog eats the tiger then the dog eats the bear.
FOL: (Sees(Bear, Dog) & Eats(Dog, Tiger)) -> Eats(Dog, Bear)
TEXT: If something eats the bear then it sees the tiger.
FOL: all x. (Eats(x, Bear) -> Sees(x, Tiger))
TEXT: If the tiger sees the rabbit then the rabbit eats the bear.
FOL: (Sees(Tiger, Rabbit) -> Eats(Rabbit, Bear))
TEXT: If something eats the bear and the bear sees the rabbit then it sees the dog.
FOL: (all x. (Eats(x, Bear) & Sees(Bear, Rabbit)) -> Sees(x, Dog))
TEXT: If something sees the dog then it sees the rabbit.
FOL: all x. (Sees(x, Dog) -> Sees(x, Rabbit))
TEXT: The tiger eats the dog.
FOL: Eats(Tiger, Dog)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: The bear eats the dog.
FOL: Eats(Bear, Dog)
TEXT: The bear eats the rabbit.
FOL: Eats(Bear, Rabbit)
TEXT: The bear is round.
FOL: Round(Bear)
TEXT: The bear needs the rabbit.
FOL: Needs(Bear, Rabbit)
TEXT: The bear needs the tiger.
FOL: Needs(Bear, Tiger)
TEXT: The bear sees the rabbit.
FOL: Sees(Bear, Rabbit)
TEXT: The dog eats the bear.
FOL: Eats(Dog, Bear)
TEXT: The rabbit eats the tiger.
FOL: Eats(Rabbit, Tiger)
TEXT: The rabbit is round.
FOL: Round(Rabbit)
TEXT: The tiger eats the bear.
FOL: Eats(Tiger, Bear)
TEXT: The tiger is cold.
FOL: Cold(Tiger)
TEXT: The tiger is young.
FOL: Young(Tiger)
TEXT: If something eats the tiger then the tiger needs the dog.
FOL: all x. (Eats(x, Tiger) -> Needs(Tiger, Dog))
TEXT: If the bear sees the dog and the dog eats the tiger then the dog eats the bear.
FOL: (Sees(Bear, Dog) & Eats(Dog, Tiger)) -> Eats(Dog, Bear)
TEXT: If something eats the bear then it sees the tiger.
FOL: all x. (Eats(x, Bear) -> Sees(x, Tiger))
TEXT: If the tiger sees the rabbit then the rabbit eats the bear.
FOL: (Sees(Tiger, Rabbit) -> Eats(Rabbit, Bear))
TEXT: If something eats the bear and the bear sees the rabbit then it sees the dog.
FOL: all x. ((Eats(x, Bear) & Sees(Bear, Rabbit)) -> Sees(x, Dog))
TEXT: If something sees the dog then it sees the rabbit.
FOL: all x. (Sees(x, Dog) -> Sees(x, Rabbit))
TEXT: The tiger eats the dog.
FOL: Eats(Tiger, Dog)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: The bear eats the dog.
FOL: Eats(Bear, Dog)
TEXT: The bear eats the rabbit.
FOL: Eats(Bear, Rabbit)
TEXT: The bear is round.
FOL: Round(Bear)
TEXT: The bear needs the rabbit.
FOL: Needs(Bear, Rabbit)
TEXT: The bear needs the tiger.
FOL: Needs(Bear, Tiger)
TEXT: The bear sees the rabbit.
FOL: Sees(Bear, Rabbit)
TEXT: The dog eats the bear.
FOL: Eats(Dog, Bear)
TEXT: The rabbit eats the tiger.
FOL: Eats(Rabbit, Tiger)
TEXT: The rabbit is round.
FOL: Round(Rabbit)
TEXT: The tiger eats the bear.
FOL: Eats(Tiger, Bear)
TEXT: The tiger is cold.
FOL: Cold(Tiger)
TEXT: The tiger is young.
FOL: Young(Tiger)
TEXT: If something eats the tiger then the tiger needs the dog.
FOL: all x. (Eats(x, Tiger) -> Needs(Tiger, Dog))
TEXT: If the bear sees the dog and the dog eats the tiger then the dog eats the bear.
FOL: (Sees(Bear, Dog) & Eats(Dog, Tiger)) -> Eats(Dog, Bear)
TEXT: If something eats the bear then it sees the tiger.
FOL: all x. (Eats(x, Bear) -> Sees(x, Tiger))
TEXT: If the tiger sees the rabbit then the rabbit eats the bear.
FOL: (Sees(Tiger, Rabbit) -> Eats(Rabbit, Bear))
TEXT: If something eats the bear and the bear sees the rabbit then it sees the dog.
FOL: all x. (Eats(x, Bear) & Sees(Bear, Rabbit) -> Sees(x, Dog))
TEXT: If something sees the dog then it sees the rabbit.
FOL: all x. (Sees(x, Dog) -> Sees(x, Rabbit))
TEXT: The tiger eats the dog.
FOL: Eats(Tiger, Dog)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 43 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle chases the lion.
The bear sees the dog.
The dog is rough.
The dog does not visit the bald eagle.
The dog visits the bear.
The lion chases the dog.
The lion visits the bald eagle.
If something sees the bear then the bear sees the lion.
If the bear does not see the lion then the lion visits the bear.
Young things are kind.
If something is kind then it does not visit the lion.
If something visits the lion and it is young then it does not chase the bald eagle.
If something chases the bear then the bear is young.
If something visits the bear then the bear chases the bald eagle.
If something chases the bear then it visits the bald eagle.
If something chases the bald eagle then the bald eagle chases the bear.
</PREMISES>
<CONCLUSION>
The bald eagle is rough.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle chases the lion.
FOL: Chases(BaldEagle, Lion)
TEXT: The bear sees the dog.
FOL: Sees(Bear, Dog)
TEXT: The dog is rough.
FOL: Rough(Dog)
TEXT: The dog does not visit the bald eagle.
FOL: -Visits(Dog, BaldEagle)
TEXT: The dog visits the bear.
FOL: Visits(Dog, Bear)
TEXT: The lion chases the dog.
FOL: Chases(Lion, Dog)
TEXT: The lion visits the bald eagle.
FOL: Visits(Lion, BaldEagle)
TEXT: If something sees the bear then the bear sees the lion.
FOL: all x. (Sees(x, Bear) -> Sees(Bear, Lion))
TEXT: If the bear does not see the lion then the lion visits the bear.
FOL: -Sees(Bear, Lion) -> Visits(Lion, Bear)
TEXT: Young things are kind.
FOL: all x. (Young(x) -> Kind(x))
TEXT: If something is kind then it does not visit the lion.
FOL: all x. (Kind(x) -> -Visits(x, Lion))
TEXT: If something visits the lion and it is young then it does not chase the bald eagle.
FOL: all x. ((Visits(x, Lion) & Young(x)) -> -Chases(x, BaldEagle))
TEXT: If something chases the bear then the bear is young.
FOL: all x. (Chases(x, Bear) -> Young(Bear))
TEXT: If something visits the bear then the bear chases the bald eagle.
FOL: all x. (Visits(x, Bear) -> Chases(Bear, BaldEagle))
TEXT: If something chases the bear then it visits the bald eagle.
FOL: all x. (Chases(x, Bear) -> Visits(x, BaldEagle))
TEXT: If something chases the bald eagle then the bald eagle chases the bear.
FOL: all x. (Chases(x, BaldEagle) -> Chases(BaldEagle, Bear))
TEXT: The bald eagle is rough.
FOL: Rough(BaldEagle)
Processed: Uncertain

Generation 2:
TEXT: The bald eagle chases the lion.
FOL: Chases(BaldEagle, Lion)

TEXT: The bear sees the dog.
FOL: Sees(Bear, Dog)

TEXT: The dog is rough.
FOL: Rough(Dog)

TEXT: The dog does not visit the bald eagle.
FOL: -Visits(Dog, BaldEagle)

TEXT: The dog visits the bear.
FOL: Visits(Dog, Bear)

TEXT: The lion chases the dog.
FOL: Chases(Lion, Dog)

TEXT: The lion visits the bald eagle.
FOL: Visits(Lion, BaldEagle)

TEXT: If something sees the bear then the bear sees the lion.
FOL: all x. (Sees(x, Bear) -> Sees(Bear, Lion))

TEXT: If the bear does not see the lion then the lion visits the bear.
FOL: -Sees(Bear, Lion) -> Visits(Lion, Bear)

TEXT: Young things are kind.
FOL: all x. (Young(x) -> Kind(x))

TEXT: If something is kind then it does not visit the lion.
FOL: all x. (Kind(x) -> -Visits(x, Lion))

TEXT: If something visits the lion and it is young then it does not chase the bald eagle.
FOL: all x. ((Visits(x, Lion) & Young(x)) -> -Chases(x, BaldEagle))

TEXT: If something chases the bear then the bear is young.
FOL: all x. (Chases(x, Bear) -> Young(Bear))

TEXT: If something visits the bear then the bear chases the bald eagle.
FOL: all x. (Visits(x, Bear) -> Chases(Bear, BaldEagle))

TEXT: If something chases the bear then it visits the bald eagle.
FOL: all x. (Chases(x, Bear) -> Visits(x, BaldEagle))

TEXT: If something chases the bald eagle then the bald eagle chases the bear.
FOL: all x. (Chases(x, BaldEagle) -> Chases(BaldEagle, Bear))

TEXT: The bald eagle is rough.
FOL: Rough(BaldEagle)
Processed: Uncertain

Generation 3:
TEXT: The bald eagle chases the lion.
FOL: Chases(BaldEagle, Lion)

TEXT: The bear sees the dog.
FOL: Sees(Bear, Dog)

TEXT: The dog is rough.
FOL: Rough(Dog)

TEXT: The dog does not visit the bald eagle.
FOL: -Visits(Dog, BaldEagle)

TEXT: The dog visits the bear.
FOL: Visits(Dog, Bear)

TEXT: The lion chases the dog.
FOL: Chases(Lion, Dog)

TEXT: The lion visits the bald eagle.
FOL: Visits(Lion, BaldEagle)

TEXT: If something sees the bear then the bear sees the lion.
FOL: all x. (Sees(x, Bear) -> Sees(Bear, Lion))

TEXT: If the bear does not see the lion then the lion visits the bear.
FOL: -Sees(Bear, Lion) -> Visits(Lion, Bear)

TEXT: Young things are kind.
FOL: all x. (Young(x) -> Kind(x))

TEXT: If something is kind then it does not visit the lion.
FOL: all x. (Kind(x) -> -Visits(x, Lion))

TEXT: If something visits the lion and it is young then it does not chase the bald eagle.
FOL: all x. (Visits(x, Lion) & Young(x) -> -Chases(x, BaldEagle))

TEXT: If something chases the bear then the bear is young.
FOL: all x. (Chases(x, Bear) -> Young(Bear))

TEXT: If something visits the bear then the bear chases the bald eagle.
FOL: all x. (Visits(x, Bear) -> Chases(Bear, BaldEagle))

TEXT: If something chases the bear then it visits the bald eagle.
FOL: all x. (Chases(x, Bear) -> Visits(x, BaldEagle))

TEXT: If something chases the bald eagle then the bald eagle chases the bear.
FOL: all x. (Chases(x, BaldEagle) -> Chases(BaldEagle, Bear))

TEXT: The bald eagle is rough.
FOL: Rough(BaldEagle)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 44 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle chases the cat.
The bald eagle chases the dog.
The bald eagle does not eat the cat.
The bald eagle eats the dog.
The cat does not chase the bald eagle.
The cat eats the bald eagle.
The cat is young.
The cat sees the bald eagle.
The cat sees the tiger.
The dog chases the cat.
The dog eats the bald eagle.
The dog is blue.
The tiger chases the bald eagle.
The tiger chases the cat.
If something is young then it does not chase the cat.
If the cat chases the tiger then the tiger is nice.
Nice things are big.
If something chases the dog and the dog eats the bald eagle then it is nice.
If something is big and it chases the cat then the cat chases the dog.
</PREMISES>
<CONCLUSION>
The cat does not chase the dog.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle chases the cat.
FOL: Chases(BaldEagle, Cat)

TEXT: The bald eagle chases the dog.
FOL: Chases(BaldEagle, Dog)

TEXT: The bald eagle does not eat the cat.
FOL: -Eats(BaldEagle, Cat)

TEXT: The bald eagle eats the dog.
FOL: Eats(BaldEagle, Dog)

TEXT: The cat does not chase the bald eagle.
FOL: -Chases(Cat, BaldEagle)

TEXT: The cat eats the bald eagle.
FOL: Eats(Cat, BaldEagle)

TEXT: The cat is young.
FOL: Young(Cat)

TEXT: The cat sees the bald eagle.
FOL: Sees(Cat, BaldEagle)

TEXT: The cat sees the tiger.
FOL: Sees(Cat, Tiger)

TEXT: The dog chases the cat.
FOL: Chases(Dog, Cat)

TEXT: The dog eats the bald eagle.
FOL: Eats(Dog, BaldEagle)

TEXT: The dog is blue.
FOL: Blue(Dog)

TEXT: The tiger chases the bald eagle.
FOL: Chases(Tiger, BaldEagle)

TEXT: The tiger chases the cat.
FOL: Chases(Tiger, Cat)

TEXT: If something is young then it does not chase the cat.
FOL: all x. (Young(x) -> -Chases(x, Cat))

TEXT: If the cat chases the tiger then the tiger is nice.
FOL: (Chases(Cat, Tiger) -> Nice(Tiger))

TEXT: Nice things are big.
FOL: all x. (Nice(x) -> Big(x))

TEXT: If something chases the dog and the dog eats the bald eagle then it is nice.
FOL: all x. ((Chases(x, Dog) & Eats(Dog, BaldEagle)) -> Nice(x))

TEXT: If something is big and it chases the cat then the cat chases the dog.
FOL: all x. ((Big(x) & Chases(x, Cat)) -> Chases(Cat, Dog))

TEXT: The cat does not chase the dog.
FOL: -Chases(Cat, Dog)
Processed: False

Generation 2:
TEXT: The bald eagle chases the cat.
FOL: Chases(BaldEagle, Cat)

TEXT: The bald eagle chases the dog.
FOL: Chases(BaldEagle, Dog)

TEXT: The bald eagle does not eat the cat.
FOL: -Eats(BaldEagle, Cat)

TEXT: The bald eagle eats the dog.
FOL: Eats(BaldEagle, Dog)

TEXT: The cat does not chase the bald eagle.
FOL: -Chases(Cat, BaldEagle)

TEXT: The cat eats the bald eagle.
FOL: Eats(Cat, BaldEagle)

TEXT: The cat is young.
FOL: Young(Cat)

TEXT: The cat sees the bald eagle.
FOL: Sees(Cat, BaldEagle)

TEXT: The cat sees the tiger.
FOL: Sees(Cat, Tiger)

TEXT: The dog chases the cat.
FOL: Chases(Dog, Cat)

TEXT: The dog eats the bald eagle.
FOL: Eats(Dog, BaldEagle)

TEXT: The dog is blue.
FOL: Blue(Dog)

TEXT: The tiger chases the bald eagle.
FOL: Chases(Tiger, BaldEagle)

TEXT: The tiger chases the cat.
FOL: Chases(Tiger, Cat)

TEXT: If something is young then it does not chase the cat.
FOL: all x. (Young(x) -> -Chases(x, Cat))

TEXT: If the cat chases the tiger then the tiger is nice.
FOL: (Chases(Cat, Tiger) -> Nice(Tiger))

TEXT: Nice things are big.
FOL: all x. (Nice(x) -> Big(x))

TEXT: If something chases the dog and the dog eats the bald eagle then it is nice.
FOL: all x. ((Chases(x, Dog) & Eats(Dog, BaldEagle)) -> Nice(x))

TEXT: If something is big and it chases the cat then the cat chases the dog.
FOL: all x. ((Big(x) & Chases(x, Cat)) -> Chases(Cat, Dog))

TEXT: The cat does not chase the dog.
FOL: -Chases(Cat, Dog)
Processed: False

Generation 3:
TEXT: The bald eagle chases the cat.
FOL: Chases(BaldEagle, Cat)
TEXT: The bald eagle chases the dog.
FOL: Chases(BaldEagle, Dog)
TEXT: The bald eagle does not eat the cat.
FOL: -Eats(BaldEagle, Cat)
TEXT: The bald eagle eats the dog.
FOL: Eats(BaldEagle, Dog)
TEXT: The cat does not chase the bald eagle.
FOL: -Chases(Cat, BaldEagle)
TEXT: The cat eats the bald eagle.
FOL: Eats(Cat, BaldEagle)
TEXT: The cat is young.
FOL: Young(Cat)
TEXT: The cat sees the bald eagle.
FOL: Sees(Cat, BaldEagle)
TEXT: The cat sees the tiger.
FOL: Sees(Cat, Tiger)
TEXT: The dog chases the cat.
FOL: Chases(Dog, Cat)
TEXT: The dog eats the bald eagle.
FOL: Eats(Dog, BaldEagle)
TEXT: The dog is blue.
FOL: Blue(Dog)
TEXT: The tiger chases the bald eagle.
FOL: Chases(Tiger, BaldEagle)
TEXT: The tiger chases the cat.
FOL: Chases(Tiger, Cat)
TEXT: If something is young then it does not chase the cat.
FOL: all x. (Young(x) -> -Chases(x, Cat))
TEXT: If the cat chases the tiger then the tiger is nice.
FOL: (Chases(Cat, Tiger) -> Nice(Tiger))
TEXT: Nice things are big.
FOL: all x. (Nice(x) -> Big(x))
TEXT: If something chases the dog and the dog eats the bald eagle then it is nice.
FOL: all x. ((Chases(x, Dog) & Eats(Dog, BaldEagle)) -> Nice(x))
TEXT: If something is big and it chases the cat then the cat chases the dog.
FOL: all x. ((Big(x) & Chases(x, Cat)) -> Chases(Cat, Dog))
TEXT: The cat does not chase the dog.
FOL: -Chases(Cat, Dog)
Processed: False

Reference: False
========================================

=== Example 45 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bear is not kind.
The bear needs the dog.
The bear visits the dog.
The dog needs the tiger.
The rabbit needs the bear.
The rabbit needs the tiger.
The tiger chases the rabbit.
The tiger is not rough.
The tiger does not need the dog.
The tiger needs the rabbit.
If someone is rough then they are green.
If someone visits the bear and the bear is green then the bear is kind.
If someone is cold and they need the dog then they do not chase the tiger.
If someone visits the bear and they are not blue then the bear visits the rabbit.
If someone visits the dog and the dog is green then they chase the dog.
If someone needs the dog then the dog is rough.
If someone chases the dog then they are cold.
If someone visits the bear and they are not rough then the bear does not chase the rabbit.
</PREMISES>
<CONCLUSION>
The tiger chases the dog.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bear is not kind.
FOL: -Kind(Bear)

TEXT: The bear needs the dog.
FOL: Needs(Bear, Dog)

TEXT: The bear visits the dog.
FOL: Visits(Bear, Dog)

TEXT: The dog needs the tiger.
FOL: Needs(Dog, Tiger)

TEXT: The rabbit needs the bear.
FOL: Needs(Rabbit, Bear)

TEXT: The rabbit needs the tiger.
FOL: Needs(Rabbit, Tiger)

TEXT: The tiger chases the rabbit.
FOL: Chases(Tiger, Rabbit)

TEXT: The tiger is not rough.
FOL: -Rough(Tiger)

TEXT: The tiger does not need the dog.
FOL: -Needs(Tiger, Dog)

TEXT: The tiger needs the rabbit.
FOL: Needs(Tiger, Rabbit)

TEXT: If someone is rough then they are green.
FOL: all x. (Rough(x) -> Green(x))

TEXT: If someone visits the bear and the bear is green then the bear is kind.
FOL: all x. (Visits(x, Bear) & Green(Bear) -> Kind(Bear))

TEXT: If someone is cold and they need the dog then they do not chase the tiger.
FOL: all x. (Cold(x) & Needs(x, Dog) -> -Chases(x, Tiger))

TEXT: If someone visits the bear and they are not blue then the bear visits the rabbit.
FOL: all x. (Visits(x, Bear) & -Blue(x) -> Visits(Bear, Rabbit))

TEXT: If someone visits the dog and the dog is green then they chase the dog.
FOL: all x. (Visits(x, Dog) & Green(Dog) -> Chases(x, Dog))

TEXT: If someone needs the dog then the dog is rough.
FOL: all x. (Needs(x, Dog) -> Rough(Dog))

TEXT: If someone chases the dog then they are cold.
FOL: all x. (Chases(x, Dog) -> Cold(x))

TEXT: If someone visits the bear and they are not rough then the bear does not chase the rabbit.
FOL: all x. (Visits(x, Bear) & -Rough(x) -> -Chases(Bear, Rabbit))

TEXT: The tiger chases the dog.
FOL: Chases(Tiger, Dog)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: The bear is not kind.
FOL: -Kind(Bear)

TEXT: The bear needs the dog.
FOL: Needs(Bear, Dog)

TEXT: The bear visits the dog.
FOL: Visits(Bear, Dog)

TEXT: The dog needs the tiger.
FOL: Needs(Dog, Tiger)

TEXT: The rabbit needs the bear.
FOL: Needs(Rabbit, Bear)

TEXT: The rabbit needs the tiger.
FOL: Needs(Rabbit, Tiger)

TEXT: The tiger chases the rabbit.
FOL: Chases(Tiger, Rabbit)

TEXT: The tiger is not rough.
FOL: -Rough(Tiger)

TEXT: The tiger does not need the dog.
FOL: -Needs(Tiger, Dog)

TEXT: The tiger needs the rabbit.
FOL: Needs(Tiger, Rabbit)

TEXT: If someone is rough then they are green.
FOL: all x. (Rough(x) -> Green(x))

TEXT: If someone visits the bear and the bear is green then the bear is kind.
FOL: all x. (Visits(x, Bear) & Green(Bear) -> Kind(Bear))

TEXT: If someone is cold and they need the dog then they do not chase the tiger.
FOL: all x. (Cold(x) & Needs(x, Dog) -> -Chases(x, Tiger))

TEXT: If someone visits the bear and they are not blue then the bear visits the rabbit.
FOL: all x. (Visits(x, Bear) & -Blue(x) -> Visits(Bear, Rabbit))

TEXT: If someone visits the dog and the dog is green then they chase the dog.
FOL: all x. (Visits(x, Dog) & Green(Dog) -> Chases(x, Dog))

TEXT: If someone needs the dog then the dog is rough.
FOL: all x. (Needs(x, Dog) -> Rough(Dog))

TEXT: If someone chases the dog then they are cold.
FOL: all x. (Chases(x, Dog) -> Cold(x))

TEXT: If someone visits the bear and they are not rough then the bear does not chase the rabbit.
FOL: all x. (Visits(x, Bear) & -Rough(x) -> -Chases(Bear, Rabbit))

TEXT: The tiger chases the dog.
FOL: Chases(Tiger, Dog)
Processed: Uncertain

Generation 3:
TEXT: The bear is not kind.
FOL: -Kind(Bear)
TEXT: The bear needs the dog.
FOL: Needs(Bear, Dog)
TEXT: The bear visits the dog.
FOL: Visits(Bear, Dog)
TEXT: The dog needs the tiger.
FOL: Needs(Dog, Tiger)
TEXT: The rabbit needs the bear.
FOL: Needs(Rabbit, Bear)
TEXT: The rabbit needs the tiger.
FOL: Needs(Rabbit, Tiger)
TEXT: The tiger chases the rabbit.
FOL: Chases(Tiger, Rabbit)
TEXT: The tiger is not rough.
FOL: -Rough(Tiger)
TEXT: The tiger does not need the dog.
FOL: -Needs(Tiger, Dog)
TEXT: The tiger needs the rabbit.
FOL: Needs(Tiger, Rabbit)
TEXT: If someone is rough then they are green.
FOL: all x. (Rough(x) -> Green(x))
TEXT: If someone visits the bear and the bear is green then the bear is kind.
FOL: all x. ((Visits(x, Bear) & Green(Bear)) -> Kind(Bear))
TEXT: If someone is cold and they need the dog then they do not chase the tiger.
FOL: all x. ((Cold(x) & Needs(x, Dog)) -> -Chases(x, Tiger))
TEXT: If someone visits the bear and they are not blue then the bear visits the rabbit.
FOL: all x. ((Visits(x, Bear) & -Blue(x)) -> Visits(Bear, Rabbit))
TEXT: If someone visits the dog and the dog is green then they chase the dog.
FOL: all x. ((Visits(x, Dog) & Green(Dog)) -> Chases(x, Dog))
TEXT: If someone needs the dog then the dog is rough.
FOL: all x. (Needs(x, Dog) -> Rough(Dog))
TEXT: If someone chases the dog then they are cold.
FOL: all x. (Chases(x, Dog) -> Cold(x))
TEXT: If someone visits the bear and they are not rough then the bear does not chase the rabbit.
FOL: all x. ((Visits(x, Bear) & -Rough(x)) -> -Chases(Bear, Rabbit))
TEXT: The tiger chases the dog.
FOL: Chases(Tiger, Dog)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 46 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The cow is not big.
The cow is not green.
The lion eats the tiger.
The lion sees the cow.
The lion visits the cow.
The lion does not visit the squirrel.
The lion visits the tiger.
The squirrel is big.
The squirrel is round.
The tiger is not green.
The tiger does not see the cow.
If something sees the squirrel and the squirrel eats the cow then the cow is round.
If something is green then it eats the tiger.
If the squirrel is round then the squirrel visits the cow.
If something eats the cow then it sees the squirrel.
If something sees the tiger and the tiger visits the squirrel then it is nice.
If something is round then it eats the cow.
If something is kind then it eats the cow.
If the tiger visits the cow then the cow sees the squirrel.
If something sees the cow then the cow eats the tiger.
</PREMISES>
<CONCLUSION>
The cow sees the squirrel.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The cow is not big.
FOL: -Big(Cow)

TEXT: The cow is not green.
FOL: -Green(Cow)

TEXT: The lion eats the tiger.
FOL: Eats(Lion, Tiger)

TEXT: The lion sees the cow.
FOL: Sees(Lion, Cow)

TEXT: The lion visits the cow.
FOL: Visits(Lion, Cow)

TEXT: The lion does not visit the squirrel.
FOL: -Visits(Lion, Squirrel)

TEXT: The lion visits the tiger.
FOL: Visits(Lion, Tiger)

TEXT: The squirrel is big.
FOL: Big(Squirrel)

TEXT: The squirrel is round.
FOL: Round(Squirrel)

TEXT: The tiger is not green.
FOL: -Green(Tiger)

TEXT: The tiger does not see the cow.
FOL: -Sees(Tiger, Cow)

TEXT: If something sees the squirrel and the squirrel eats the cow then the cow is round.
FOL: all x. (Sees(x, Squirrel) & Eats(Squirrel, Cow) -> Round(Cow))

TEXT: If something is green then it eats the tiger.
FOL: all x. (Green(x) -> Eats(x, Tiger))

TEXT: If the squirrel is round then the squirrel visits the cow.
FOL: Round(Squirrel) -> Visits(Squirrel, Cow)

TEXT: If something eats the cow then it sees the squirrel.
FOL: all x. (Eats(x, Cow) -> Sees(x, Squirrel))

TEXT: If something sees the tiger and the tiger visits the squirrel then it is nice.
FOL: all x. (Sees(x, Tiger) & Visits(Tiger, Squirrel) -> Nice(x))

TEXT: If something is round then it eats the cow.
FOL: all x. (Round(x) -> Eats(x, Cow))

TEXT: If something is kind then it eats the cow.
FOL: all x. (Kind(x) -> Eats(x, Cow))

TEXT: If the tiger visits the cow then the cow sees the squirrel.
FOL: Visits(Tiger, Cow) -> Sees(Cow, Squirrel)

TEXT: If something sees the cow then the cow eats the tiger.
FOL: all x. (Sees(x, Cow) -> Eats(Cow, Tiger))

TEXT: The cow sees the squirrel.
FOL: Sees(Cow, Squirrel)
Processed: True

Generation 2:
TEXT: The cow is not big.
FOL: -Big(Cow)
TEXT: The cow is not green.
FOL: -Green(Cow)
TEXT: The lion eats the tiger.
FOL: Eats(Lion, Tiger)
TEXT: The lion sees the cow.
FOL: Sees(Lion, Cow)
TEXT: The lion visits the cow.
FOL: Visits(Lion, Cow)
TEXT: The lion does not visit the squirrel.
FOL: -Visits(Lion, Squirrel)
TEXT: The lion visits the tiger.
FOL: Visits(Lion, Tiger)
TEXT: The squirrel is big.
FOL: Big(Squirrel)
TEXT: The squirrel is round.
FOL: Round(Squirrel)
TEXT: The tiger is not green.
FOL: -Green(Tiger)
TEXT: The tiger does not see the cow.
FOL: -Sees(Tiger, Cow)
TEXT: If something sees the squirrel and the squirrel eats the cow then the cow is round.
FOL: all x. (Sees(x, Squirrel) & Eats(Squirrel, Cow) -> Round(Cow))
TEXT: If something is green then it eats the tiger.
FOL: all x. (Green(x) -> Eats(x, Tiger))
TEXT: If the squirrel is round then the squirrel visits the cow.
FOL: Round(Squirrel) -> Visits(Squirrel, Cow)
TEXT: If something eats the cow then it sees the squirrel.
FOL: all x. (Eats(x, Cow) -> Sees(x, Squirrel))
TEXT: If something sees the tiger and the tiger visits the squirrel then it is nice.
FOL: all x. (Sees(x, Tiger) & Visits(Tiger, Squirrel) -> Nice(x))
TEXT: If something is round then it eats the cow.
FOL: all x. (Round(x) -> Eats(x, Cow))
TEXT: If something is kind then it eats the cow.
FOL: all x. (Kind(x) -> Eats(x, Cow))
TEXT: If the tiger visits the cow then the cow sees the squirrel.
FOL: Visits(Tiger, Cow) -> Sees(Cow, Squirrel)
TEXT: If something sees the cow then the cow eats the tiger.
FOL: all x. (Sees(x, Cow) -> Eats(Cow, Tiger))
TEXT: The cow sees the squirrel.
FOL: Sees(Cow, Squirrel)
</EVALUATE>
Processed: True

Generation 3:
TEXT: The cow is not big.
FOL: -Big(Cow)
TEXT: The cow is not green.
FOL: -Green(Cow)
TEXT: The lion eats the tiger.
FOL: Eats(Lion, Tiger)
TEXT: The lion sees the cow.
FOL: Sees(Lion, Cow)
TEXT: The lion visits the cow.
FOL: Visits(Lion, Cow)
TEXT: The lion does not visit the squirrel.
FOL: -Visits(Lion, Squirrel)
TEXT: The lion visits the tiger.
FOL: Visits(Lion, Tiger)
TEXT: The squirrel is big.
FOL: Big(Squirrel)
TEXT: The squirrel is round.
FOL: Round(Squirrel)
TEXT: The tiger is not green.
FOL: -Green(Tiger)
TEXT: The tiger does not see the cow.
FOL: -Sees(Tiger, Cow)
TEXT: If something sees the squirrel and the squirrel eats the cow then the cow is round.
FOL: all x. (Sees(x, Squirrel) & Eats(Squirrel, Cow) -> Round(Cow))
TEXT: If something is green then it eats the tiger.
FOL: all x. (Green(x) -> Eats(x, Tiger))
TEXT: If the squirrel is round then the squirrel visits the cow.
FOL: Round(Squirrel) -> Visits(Squirrel, Cow)
TEXT: If something eats the cow then it sees the squirrel.
FOL: all x. (Eats(x, Cow) -> Sees(x, Squirrel))
TEXT: If something sees the tiger and the tiger visits the squirrel then it is nice.
FOL: all x. (Sees(x, Tiger) & Visits(Tiger, Squirrel) -> Nice(x))
TEXT: If something is round then it eats the cow.
FOL: all x. (Round(x) -> Eats(x, Cow))
TEXT: If something is kind then it eats the cow.
FOL: all x. (Kind(x) -> Eats(x, Cow))
TEXT: If the tiger visits the cow then the cow sees the squirrel.
FOL: Visits(Tiger, Cow) -> Sees(Cow, Squirrel)
TEXT: If something sees the cow then the cow eats the tiger.
FOL: all x. (Sees(x, Cow) -> Eats(Cow, Tiger))
TEXT: The cow sees the squirrel.
FOL: Sees(Cow, Squirrel)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 47 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The cow chases the squirrel.
The cow eats the dog.
The cow needs the squirrel.
The dog eats the squirrel.
The dog is big.
The dog is cold.
The dog needs the tiger.
The squirrel eats the dog.
The squirrel is cold.
The squirrel needs the cow.
The tiger eats the squirrel.
If someone chases the tiger then the tiger is kind.
If someone is kind then they chase the tiger.
If someone is cold then they chase the tiger.
If the dog chases the squirrel then the squirrel needs the tiger.
If someone is cold and they need the dog then they do not chase the squirrel.
If someone eats the cow then they are big.
If someone chases the cow and they are kind then they are big.
If someone eats the squirrel and the squirrel needs the tiger then they need the squirrel.
If someone chases the tiger then they chase the cow.
</PREMISES>
<CONCLUSION>
The squirrel needs the squirrel.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The cow chases the squirrel.
FOL: Chases(Cow, Squirrel)
TEXT: The cow eats the dog.
FOL: Eats(Cow, Dog)
TEXT: The cow needs the squirrel.
FOL: Needs(Cow, Squirrel)
TEXT: The dog eats the squirrel.
FOL: Eats(Dog, Squirrel)
TEXT: The dog is big.
FOL: Big(Dog)
TEXT: The dog is cold.
FOL: Cold(Dog)
TEXT: The dog needs the tiger.
FOL: Needs(Dog, Tiger)
TEXT: The squirrel eats the dog.
FOL: Eats(Squirrel, Dog)
TEXT: The squirrel is cold.
FOL: Cold(Squirrel)
TEXT: The squirrel needs the cow.
FOL: Needs(Squirrel, Cow)
TEXT: The tiger eats the squirrel.
FOL: Eats(Tiger, Squirrel)
TEXT: If someone chases the tiger then the tiger is kind.
FOL: all x. (Chases(x, Tiger) -> Kind(Tiger))
TEXT: If someone is kind then they chase the tiger.
FOL: all x. (Kind(x) -> Chases(x, Tiger))
TEXT: If someone is cold then they chase the tiger.
FOL: all x. (Cold(x) -> Chases(x, Tiger))
TEXT: If the dog chases the squirrel then the squirrel needs the tiger.
FOL: Chases(Dog, Squirrel) -> Needs(Squirrel, Tiger)
TEXT: If someone is cold and they need the dog then they do not chase the squirrel.
FOL: all x. ((Cold(x) & Needs(x, Dog)) -> -Chases(x, Squirrel))
TEXT: If someone eats the cow then they are big.
FOL: all x. (Eats(x, Cow) -> Big(x))
TEXT: If someone chases the cow and they are kind then they are big.
FOL: all x. ((Chases(x, Cow) & Kind(x)) -> Big(x))
TEXT: If someone eats the squirrel and the squirrel needs the tiger then they need the squirrel.
FOL: all x. ((Eats(x, Squirrel) & Needs(Squirrel, Tiger)) -> Needs(x, Squirrel))
TEXT: If someone chases the tiger then they chase the cow.
FOL: all x. (Chases(x, Tiger) -> Chases(x, Cow))
TEXT: The squirrel needs the squirrel.
FOL: Needs(Squirrel, Squirrel)
Processed: Uncertain

Generation 2:
TEXT: The cow chases the squirrel.
FOL: Chases(Cow, Squirrel)
TEXT: The cow eats the dog.
FOL: Eats(Cow, Dog)
TEXT: The cow needs the squirrel.
FOL: Needs(Cow, Squirrel)
TEXT: The dog eats the squirrel.
FOL: Eats(Dog, Squirrel)
TEXT: The dog is big.
FOL: Big(Dog)
TEXT: The dog is cold.
FOL: Cold(Dog)
TEXT: The dog needs the tiger.
FOL: Needs(Dog, Tiger)
TEXT: The squirrel eats the dog.
FOL: Eats(Squirrel, Dog)
TEXT: The squirrel is cold.
FOL: Cold(Squirrel)
TEXT: The squirrel needs the cow.
FOL: Needs(Squirrel, Cow)
TEXT: The tiger eats the squirrel.
FOL: Eats(Tiger, Squirrel)
TEXT: If someone chases the tiger then the tiger is kind.
FOL: all x. (Chases(x, Tiger) -> Kind(Tiger))
TEXT: If someone is kind then they chase the tiger.
FOL: all x. (Kind(x) -> Chases(x, Tiger))
TEXT: If someone is cold then they chase the tiger.
FOL: all x. (Cold(x) -> Chases(x, Tiger))
TEXT: If the dog chases the squirrel then the squirrel needs the tiger.
FOL: (Chases(Dog, Squirrel) -> Needs(Squirrel, Tiger))
TEXT: If someone is cold and they need the dog then they do not chase the squirrel.
FOL: all x. ((Cold(x) & Needs(x, Dog)) -> -Chases(x, Squirrel))
TEXT: If someone eats the cow then they are big.
FOL: all x. (Eats(x, Cow) -> Big(x))
TEXT: If someone chases the cow and they are kind then they are big.
FOL: all x. ((Chases(x, Cow) & Kind(x)) -> Big(x))
TEXT: If someone eats the squirrel and the squirrel needs the tiger then they need the squirrel.
FOL: all x. ((Eats(x, Squirrel) & Needs(Squirrel, Tiger)) -> Needs(x, Squirrel))
TEXT: If someone chases the tiger then they chase the cow.
FOL: all x. (Chases(x, Tiger) -> Chases(x, Cow))
TEXT: The squirrel needs the squirrel.
FOL: Needs(Squirrel, Squirrel)
Processed: Uncertain

Generation 3:
TEXT: The cow chases the squirrel.
FOL: Chases(Cow, Squirrel)
TEXT: The cow eats the dog.
FOL: Eats(Cow, Dog)
TEXT: The cow needs the squirrel.
FOL: Needs(Cow, Squirrel)
TEXT: The dog eats the squirrel.
FOL: Eats(Dog, Squirrel)
TEXT: The dog is big.
FOL: Big(Dog)
TEXT: The dog is cold.
FOL: Cold(Dog)
TEXT: The dog needs the tiger.
FOL: Needs(Dog, Tiger)
TEXT: The squirrel eats the dog.
FOL: Eats(Squirrel, Dog)
TEXT: The squirrel is cold.
FOL: Cold(Squirrel)
TEXT: The squirrel needs the cow.
FOL: Needs(Squirrel, Cow)
TEXT: The tiger eats the squirrel.
FOL: Eats(Tiger, Squirrel)
TEXT: If someone chases the tiger then the tiger is kind.
FOL: all x. (Chases(x, Tiger) -> Kind(Tiger))
TEXT: If someone is kind then they chase the tiger.
FOL: all x. (Kind(x) -> Chases(x, Tiger))
TEXT: If someone is cold then they chase the tiger.
FOL: all x. (Cold(x) -> Chases(x, Tiger))
TEXT: If the dog chases the squirrel then the squirrel needs the tiger.
FOL: (Chases(Dog, Squirrel) -> Needs(Squirrel, Tiger))
TEXT: If someone is cold and they need the dog then they do not chase the squirrel.
FOL: all x. ((Cold(x) & Needs(x, Dog)) -> -Chases(x, Squirrel))
TEXT: If someone eats the cow then they are big.
FOL: all x. (Eats(x, Cow) -> Big(x))
TEXT: If someone chases the cow and they are kind then they are big.
FOL: all x. ((Chases(x, Cow) & Kind(x)) -> Big(x))
TEXT: If someone eats the squirrel and the squirrel needs the tiger then they need the squirrel.
FOL: all x. ((Eats(x, Squirrel) & Needs(Squirrel, Tiger)) -> Needs(x, Squirrel))
TEXT: If someone chases the tiger then they chase the cow.
FOL: all x. (Chases(x, Tiger) -> Chases(x, Cow))
TEXT: The squirrel needs the squirrel.
FOL: Needs(Squirrel, Squirrel)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 48 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is blue.
Bob is green.
Bob is young.
Charlie is white.
Gary is white.
Gary is young.
Harry is big.
Harry is furry.
Harry is red.
Harry is white.
All red people are blue.
Big, white people are green.
If someone is green and red then they are big.
Blue people are big.
If someone is white then they are furry.
All furry people are red.
</PREMISES>
<CONCLUSION>
Bob is not red.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is blue.
FOL: Blue(Bob)
TEXT: Bob is green.
FOL: Green(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Charlie is white.
FOL: White(Charlie)
TEXT: Gary is white.
FOL: White(Gary)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: Harry is big.
FOL: Big(Harry)
TEXT: Harry is furry.
FOL: Furry(Harry)
TEXT: Harry is red.
FOL: Red(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: All red people are blue.
FOL: all x. (Red(x) -> Blue(x))
TEXT: Big, white people are green.
FOL: all x. ((Big(x) & White(x)) -> Green(x))
TEXT: If someone is green and red then they are big.
FOL: all x. ((Green(x) & Red(x)) -> Big(x))
TEXT: Blue people are big.
FOL: all x. (Blue(x) -> Big(x))
TEXT: If someone is white then they are furry.
FOL: all x. (White(x) -> Furry(x))
TEXT: All furry people are red.
FOL: all x. (Furry(x) -> Red(x))
TEXT: Bob is not red.
FOL: -Red(Bob)
Processed: Uncertain

Generation 2:
TEXT: Bob is blue.
FOL: Color(Bob, Blue)
TEXT: Bob is green.
FOL: Color(Bob, Green)
TEXT: Bob is young.
FOL: Age(Bob, Young)
TEXT: Charlie is white.
FOL: Color(Charlie, White)
TEXT: Gary is white.
FOL: Color(Gary, White)
TEXT: Gary is young.
FOL: Age(Gary, Young)
TEXT: Harry is big.
FOL: Size(Harry, Big)
TEXT: Harry is furry.
FOL: Fur(Harry)
TEXT: Harry is red.
FOL: Color(Harry, Red)
TEXT: Harry is white.
FOL: Color(Harry, White)
TEXT: All red people are blue.
FOL: all x. (Color(x, Red) -> Color(x, Blue))
TEXT: Big, white people are green.
FOL: all x. (Size(x, Big) & Color(x, White) -> Color(x, Green))
TEXT: If someone is green and red then they are big.
FOL: all x. (Color(x, Green) & Color(x, Red) -> Size(x, Big))
TEXT: Blue people are big.
FOL: all x. (Color(x, Blue) -> Size(x, Big))
TEXT: If someone is white then they are furry.
FOL: all x. (Color(x, White) -> Fur(x))
TEXT: All furry people are red.
FOL: all x. (Fur(x) -> Color(x, Red))
TEXT: Bob is not red.
FOL: -Color(Bob, Red)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: Bob is blue.
FOL: Blue(Bob)
TEXT: Bob is green.
FOL: Green(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Charlie is white.
FOL: White(Charlie)
TEXT: Gary is white.
FOL: White(Gary)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: Harry is big.
FOL: Big(Harry)
TEXT: Harry is furry.
FOL: Furry(Harry)
TEXT: Harry is red.
FOL: Red(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: All red people are blue.
FOL: all x. (Red(x) -> Blue(x))
TEXT: Big, white people are green.
FOL: all x. (Big(x) & White(x) -> Green(x))
TEXT: If someone is green and red then they are big.
FOL: all x. (Green(x) & Red(x) -> Big(x))
TEXT: Blue people are big.
FOL: all x. (Blue(x) -> Big(x))
TEXT: If someone is white then they are furry.
FOL: all x. (White(x) -> Furry(x))
TEXT: All furry people are red.
FOL: all x. (Furry(x) -> Red(x))
TEXT: Bob is not red.
FOL: -Red(Bob)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 49 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is big.
Bob is blue.
Bob is furry.
Bob is young.
Dave is red.
Fiona is white.
Harry is big.
Harry is red.
Harry is round.
Harry is white.
White, round things are furry.
All blue, young things are big.
If something is white and young then it is blue.
If Dave is round then Dave is white.
If something is blue and white then it is round.
If Harry is big and Harry is white then Harry is red.
All furry, red things are young.
Red things are round.
If something is blue then it is red.
</PREMISES>
<CONCLUSION>
Fiona is not young.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is big.
FOL: Big(Bob)
TEXT: Bob is blue.
FOL: Blue(Bob)
TEXT: Bob is furry.
FOL: Furry(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Dave is red.
FOL: Red(Dave)
TEXT: Fiona is white.
FOL: White(Fiona)
TEXT: Harry is big.
FOL: Big(Harry)
TEXT: Harry is red.
FOL: Red(Harry)
TEXT: Harry is round.
FOL: Round(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: White, round things are furry.
FOL: all x. (White(x) & Round(x) -> Furry(x))
TEXT: All blue, young things are big.
FOL: all x. (Blue(x) & Young(x) -> Big(x))
TEXT: If something is white and young then it is blue.
FOL: all x. (White(x) & Young(x) -> Blue(x))
TEXT: If Dave is round then Dave is white.
FOL: (Round(Dave) -> White(Dave))
TEXT: If something is blue and white then it is round.
FOL: all x. (Blue(x) & White(x) -> Round(x))
TEXT: If Harry is big and Harry is white then Harry is red.
FOL: (Big(Harry) & White(Harry) -> Red(Harry))
TEXT: All furry, red things are young.
FOL: all x. (Furry(x) & Red(x) -> Young(x))
TEXT: Red things are round.
FOL: all x. (Red(x) -> Round(x))
TEXT: If something is blue then it is red.
FOL: all x. (Blue(x) -> Red(x))
TEXT: Fiona is not young.
FOL: -Young(Fiona)
Processed: Uncertain

Generation 2:
TEXT: Bob is big.
FOL: Big(Bob)
TEXT: Bob is blue.
FOL: Blue(Bob)
TEXT: Bob is furry.
FOL: Furry(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Dave is red.
FOL: Red(Dave)
TEXT: Fiona is white.
FOL: White(Fiona)
TEXT: Harry is big.
FOL: Big(Harry)
TEXT: Harry is red.
FOL: Red(Harry)
TEXT: Harry is round.
FOL: Round(Harry)
TEXT: Harry is white.
FOL: White(Harry)
TEXT: White, round things are furry.
FOL: all x. (White(x) & Round(x) -> Furry(x))
TEXT: All blue, young things are big.
FOL: all x. (Blue(x) & Young(x) -> Big(x))
TEXT: If something is white and young then it is blue.
FOL: all x. (White(x) & Young(x) -> Blue(x))
TEXT: If Dave is round then Dave is white.
FOL: (Round(Dave) -> White(Dave))
TEXT: If something is blue and white then it is round.
FOL: all x. (Blue(x) & White(x) -> Round(x))
TEXT: If Harry is big and Harry is white then Harry is red.
FOL: (Big(Harry) & White(Harry) -> Red(Harry))
TEXT: All furry, red things are young.
FOL: all x. (Furry(x) & Red(x) -> Young(x))
TEXT: Red things are round.
FOL: all x. (Red(x) -> Round(x))
TEXT: If something is blue then it is red.
FOL: all x. (Blue(x) -> Red(x))
TEXT: Fiona is not young.
FOL: -Young(Fiona)
Processed: Uncertain

Generation 3:
TEXT: Bob is big.
FOL: Big(Bob)

TEXT: Bob is blue.
FOL: Blue(Bob)

TEXT: Bob is furry.
FOL: Furry(Bob)

TEXT: Bob is young.
FOL: Young(Bob)

TEXT: Dave is red.
FOL: Red(Dave)

TEXT: Fiona is white.
FOL: White(Fiona)

TEXT: Harry is big.
FOL: Big(Harry)

TEXT: Harry is red.
FOL: Red(Harry)

TEXT: Harry is round.
FOL: Round(Harry)

TEXT: Harry is white.
FOL: White(Harry)

TEXT: White, round things are furry.
FOL: all x. (White(x) & Round(x) -> Furry(x))

TEXT: All blue, young things are big.
FOL: all x. (Blue(x) & Young(x) -> Big(x))

TEXT: If something is white and young then it is blue.
FOL: all x. (White(x) & Young(x) -> Blue(x))

TEXT: If Dave is round then Dave is white.
FOL: Round(Dave) -> White(Dave)

TEXT: If something is blue and white then it is round.
FOL: all x. (Blue(x) & White(x) -> Round(x))

TEXT: If Harry is big and Harry is white then Harry is red.
FOL: (Big(Harry) & White(Harry)) -> Red(Harry)

TEXT: All furry, red things are young.
FOL: all x. (Furry(x) & Red(x) -> Young(x))

TEXT: Red things are round.
FOL: all x. (Red(x) -> Round(x))

TEXT: If something is blue then it is red.
FOL: all x. (Blue(x) -> Red(x))

TEXT: Fiona is not young.
FOL: -Young(Fiona)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 50 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The lion is blue.
The lion needs the mouse.
The lion sees the squirrel.
The mouse eats the tiger.
The mouse is rough.
The mouse needs the lion.
The mouse needs the squirrel.
The mouse does not see the tiger.
The squirrel needs the mouse.
The squirrel needs the tiger.
The tiger does not eat the mouse.
The tiger is nice.
If the squirrel needs the tiger and the tiger eats the lion then the lion is nice.
If something is cold then it eats the mouse.
If something sees the squirrel and it sees the tiger then the tiger sees the squirrel.
If something is cold then it is rough.
If something eats the lion then it is rough.
If something is nice then it eats the lion.
If the lion needs the squirrel and the lion eats the tiger then the lion is green.
If the lion is rough then the lion does not eat the mouse.
If something eats the lion then the lion eats the tiger.
</PREMISES>
<CONCLUSION>
The lion does not need the squirrel.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The lion is blue.
FOL: Color(lion, Blue)
TEXT: The lion needs the mouse.
FOL: Needs(lion, mouse)
TEXT: The lion sees the squirrel.
FOL: Sees(lion, squirrel)
TEXT: The mouse eats the tiger.
FOL: Eats(mouse, tiger)
TEXT: The mouse is rough.
FOL: IsRough(mouse)
TEXT: The mouse needs the lion.
FOL: Needs(mouse, lion)
TEXT: The mouse needs the squirrel.
FOL: Needs(mouse, squirrel)
TEXT: The mouse does not see the tiger.
FOL: -Sees(mouse, tiger)
TEXT: The squirrel needs the mouse.
FOL: Needs(squirrel, mouse)
TEXT: The squirrel needs the tiger.
FOL: Needs(squirrel, tiger)
TEXT: The tiger does not eat the mouse.
FOL: -Eats(tiger, mouse)
TEXT: The tiger is nice.
FOL: Nice(tiger)
TEXT: If the squirrel needs the tiger and the tiger eats the lion then the lion is nice.
FOL: (Needs(squirrel, tiger) & Eats(tiger, lion)) -> Nice(lion)
TEXT: If something is cold then it eats the mouse.
FOL: all x. (IsCold(x) -> Eats(x, mouse))
TEXT: If something sees the squirrel and it sees the tiger then the tiger sees the squirrel.
FOL: all x. ((Sees(x, squirrel) & Sees(x, tiger)) -> Sees(tiger, squirrel))
TEXT: If something is cold then it is rough.
FOL: all x. (IsCold(x) -> IsRough(x))
TEXT: If something eats the lion then it is rough.
FOL: all x. (Eats(x, lion) -> IsRough(x))
TEXT: If something is nice then it eats the lion.
FOL: all x. (Nice(x) -> Eats(x, lion))
TEXT: If the lion needs the squirrel and the lion eats the tiger then the lion is green.
FOL: (Needs(lion, squirrel) & Eats(lion, tiger)) -> Color(lion, Green)
TEXT: If the lion is rough then the lion does not eat the mouse.
FOL: (IsRough(lion) -> -Eats(lion, mouse))
TEXT: If something eats the lion then the lion eats the tiger.
FOL: all x. (Eats(x, lion) -> Eats(lion, tiger))
TEXT: The lion does not need the squirrel.
FOL: -Needs(lion, squirrel)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: The lion is blue.
FOL: Color(lion, Blue)
TEXT: The lion needs the mouse.
FOL: Needs(lion, mouse)
TEXT: The lion sees the squirrel.
FOL: Sees(lion, squirrel)
TEXT: The mouse eats the tiger.
FOL: Eats(mouse, tiger)
TEXT: The mouse is rough.
FOL: Rough(mouse)
TEXT: The mouse needs the lion.
FOL: Needs(mouse, lion)
TEXT: The mouse needs the squirrel.
FOL: Needs(mouse, squirrel)
TEXT: The mouse does not see the tiger.
FOL: -Sees(mouse, tiger)
TEXT: The squirrel needs the mouse.
FOL: Needs(squirrel, mouse)
TEXT: The squirrel needs the tiger.
FOL: Needs(squirrel, tiger)
TEXT: The tiger does not eat the mouse.
FOL: -Eats(tiger, mouse)
TEXT: The tiger is nice.
FOL: Nice(tiger)
TEXT: If the squirrel needs the tiger and the tiger eats the lion then the lion is nice.
FOL: (Needs(squirrel, tiger) & Eats(tiger, lion)) -> Nice(lion)
TEXT: If something is cold then it eats the mouse.
FOL: all x. (Cold(x) -> Eats(x, mouse))
TEXT: If something sees the squirrel and it sees the tiger then the tiger sees the squirrel.
FOL: all x. ((Sees(x, squirrel) & Sees(x, tiger)) -> Sees(tiger, squirrel))
TEXT: If something is cold then it is rough.
FOL: all x. (Cold(x) -> Rough(x))
TEXT: If something eats the lion then it is rough.
FOL: all x. (Eats(x, lion) -> Rough(x))
TEXT: If something is nice then it eats the lion.
FOL: all x. (Nice(x) -> Eats(x, lion))
TEXT: If the lion needs the squirrel and the lion eats the tiger then the lion is green.
FOL: (Needs(lion, squirrel) & Eats(lion, tiger)) -> Green(lion)
TEXT: If the lion is rough then the lion does not eat the mouse.
FOL: (Rough(lion) -> -Eats(lion, mouse))
TEXT: If something eats the lion then the lion eats the tiger.
FOL: all x. (Eats(x, lion) -> Eats(lion, tiger))
TEXT: The lion does not need the squirrel.
FOL: -Needs(lion, squirrel)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: The lion is blue.
FOL: Color(lion, Blue)
TEXT: The lion needs the mouse.
FOL: Needs(lion, mouse)
TEXT: The lion sees the squirrel.
FOL: Sees(lion, squirrel)
TEXT: The mouse eats the tiger.
FOL: Eats(mouse, tiger)
TEXT: The mouse is rough.
FOL: Rough(mouse)
TEXT: The mouse needs the lion.
FOL: Needs(mouse, lion)
TEXT: The mouse needs the squirrel.
FOL: Needs(mouse, squirrel)
TEXT: The mouse does not see the tiger.
FOL: -Sees(mouse, tiger)
TEXT: The squirrel needs the mouse.
FOL: Needs(squirrel, mouse)
TEXT: The squirrel needs the tiger.
FOL: Needs(squirrel, tiger)
TEXT: The tiger does not eat the mouse.
FOL: -Eats(tiger, mouse)
TEXT: The tiger is nice.
FOL: Nice(tiger)
TEXT: If the squirrel needs the tiger and the tiger eats the lion then the lion is nice.
FOL: (Needs(squirrel, tiger) & Eats(tiger, lion)) -> Nice(lion)
TEXT: If something is cold then it eats the mouse.
FOL: all x. (Cold(x) -> Eats(x, mouse))
TEXT: If something sees the squirrel and it sees the tiger then the tiger sees the squirrel.
FOL: all x. ((Sees(x, squirrel) & Sees(x, tiger)) -> Sees(tiger, squirrel))
TEXT: If something is cold then it is rough.
FOL: all x. (Cold(x) -> Rough(x))
TEXT: If something eats the lion then it is rough.
FOL: all x. (Eats(x, lion) -> Rough(x))
TEXT: If something is nice then it eats the lion.
FOL: all x. (Nice(x) -> Eats(x, lion))
TEXT: If the lion needs the squirrel and the lion eats the tiger then the lion is green.
FOL: (Needs(lion, squirrel) & Eats(lion, tiger)) -> Color(lion, Green)
TEXT: If the lion is rough then the lion does not eat the mouse.
FOL: (Rough(lion) -> -Eats(lion, mouse))
TEXT: If something eats the lion then the lion eats the tiger.
FOL: all x. (Eats(x, lion) -> Eats(lion, tiger))
TEXT: The lion does not need the squirrel.
FOL: -Needs(lion, squirrel)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 51 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Charlie is smart.
Erin is not blue.
Erin is green.
Erin is red.
Erin is white.
Fiona is red.
Gary is white.
If something is white and nice then it is kind.
All smart things are nice.
If something is green then it is white.
If something is white then it is smart.
If something is green and blue then it is not smart.
All red, white things are not blue.
All green things are not blue.
If Fiona is smart then Fiona is not blue.
Nice, kind things are red.
</PREMISES>
<CONCLUSION>
Charlie is not red.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Charlie is smart.
FOL: Smart(Charlie)
TEXT: Erin is not blue.
FOL: -Blue(Erin)
TEXT: Erin is green.
FOL: Green(Erin)
TEXT: Erin is red.
FOL: Red(Erin)
TEXT: Erin is white.
FOL: White(Erin)
TEXT: Fiona is red.
FOL: Red(Fiona)
TEXT: Gary is white.
FOL: White(Gary)
TEXT: If something is white and nice then it is kind.
FOL: all x. ((White(x) & Nice(x)) -> Kind(x))
TEXT: All smart things are nice.
FOL: all x. (Smart(x) -> Nice(x))
TEXT: If something is green then it is white.
FOL: all x. (Green(x) -> White(x))
TEXT: If something is white then it is smart.
FOL: all x. (White(x) -> Smart(x))
TEXT: If something is green and blue then it is not smart.
FOL: all x. ((Green(x) & Blue(x)) -> -Smart(x))
TEXT: All red, white things are not blue.
FOL: all x. ((Red(x) & White(x)) -> -Blue(x))
TEXT: All green things are not blue.
FOL: all x. (Green(x) -> -Blue(x))
TEXT: If Fiona is smart then Fiona is not blue.
FOL: (Smart(Fiona) -> -Blue(Fiona))
TEXT: Nice, kind things are red.
FOL: all x. ((Nice(x) & Kind(x)) -> Red(x))
TEXT: Charlie is not red.
FOL: -Red(Charlie)
Processed: Uncertain

Generation 2:
TEXT: Charlie is smart.
FOL: Smart(Charlie)
TEXT: Erin is not blue.
FOL: -Blue(Erin)
TEXT: Erin is green.
FOL: Green(Erin)
TEXT: Erin is red.
FOL: Red(Erin)
TEXT: Erin is white.
FOL: White(Erin)
TEXT: Fiona is red.
FOL: Red(Fiona)
TEXT: Gary is white.
FOL: White(Gary)
TEXT: If something is white and nice then it is kind.
FOL: all x. ((White(x) & Nice(x)) -> Kind(x))
TEXT: All smart things are nice.
FOL: all x. (Smart(x) -> Nice(x))
TEXT: If something is green then it is white.
FOL: all x. (Green(x) -> White(x))
TEXT: If something is white then it is smart.
FOL: all x. (White(x) -> Smart(x))
TEXT: If something is green and blue then it is not smart.
FOL: all x. ((Green(x) & Blue(x)) -> -Smart(x))
TEXT: All red, white things are not blue.
FOL: all x. ((Red(x) & White(x)) -> -Blue(x))
TEXT: All green things are not blue.
FOL: all x. (Green(x) -> -Blue(x))
TEXT: If Fiona is smart then Fiona is not blue.
FOL: (Smart(Fiona) -> -Blue(Fiona))
TEXT: Nice, kind things are red.
FOL: all x. ((Nice(x) & Kind(x)) -> Red(x))
TEXT: Charlie is not red.
FOL: -Red(Charlie)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: Charlie is smart.
FOL: Smart(Charlie)

TEXT: Erin is not blue.
FOL: -Blue(Erin)

TEXT: Erin is green.
FOL: Green(Erin)

TEXT: Erin is red.
FOL: Red(Erin)

TEXT: Erin is white.
FOL: White(Erin)

TEXT: Fiona is red.
FOL: Red(Fiona)

TEXT: Gary is white.
FOL: White(Gary)

TEXT: If something is white and nice then it is kind.
FOL: all x. (White(x) & Nice(x) -> Kind(x))

TEXT: All smart things are nice.
FOL: all x. (Smart(x) -> Nice(x))

TEXT: If something is green then it is white.
FOL: all x. (Green(x) -> White(x))

TEXT: If something is white then it is smart.
FOL: all x. (White(x) -> Smart(x))

TEXT: If something is green and blue then it is not smart.
FOL: all x. (Green(x) & Blue(x) -> -Smart(x))

TEXT: All red, white things are not blue.
FOL: all x. (Red(x) & White(x) -> -Blue(x))

TEXT: All green things are not blue.
FOL: all x. (Green(x) -> -Blue(x))

TEXT: If Fiona is smart then Fiona is not blue.
FOL: (Smart(Fiona) -> -Blue(Fiona))

TEXT: Nice, kind things are red.
FOL: all x. (Nice(x) & Kind(x) -> Red(x))

TEXT: Charlie is not red.
FOL: -Red(Charlie)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 52 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Dave is blue.
Dave is rough.
Dave is young.
Erin is blue.
Erin is round.
Erin is young.
Fiona is rough.
Gary is green.
Gary is nice.
Gary is young.
Rough things are round.
Green, nice things are quiet.
Round, rough things are green.
All quiet things are green.
All green things are nice.
All quiet things are rough.
All rough, nice things are quiet.
All quiet, green things are rough.
If something is nice and quiet then it is blue.
</PREMISES>
<CONCLUSION>
Fiona is not blue.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Dave is blue.
FOL: Blue(Dave)
TEXT: Dave is rough.
FOL: Rough(Dave)
TEXT: Dave is young.
FOL: Young(Dave)
TEXT: Erin is blue.
FOL: Blue(Erin)
TEXT: Erin is round.
FOL: Round(Erin)
TEXT: Erin is young.
FOL: Young(Erin)
TEXT: Fiona is rough.
FOL: Rough(Fiona)
TEXT: Gary is green.
FOL: Green(Gary)
TEXT: Gary is nice.
FOL: Nice(Gary)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: Rough things are round.
FOL: all x. (Rough(x) -> Round(x))
TEXT: Green, nice things are quiet.
FOL: all x. ((Green(x) & Nice(x)) -> Quiet(x))
TEXT: Round, rough things are green.
FOL: all x. ((Round(x) & Rough(x)) -> Green(x))
TEXT: All quiet things are green.
FOL: all x. (Quiet(x) -> Green(x))
TEXT: All green things are nice.
FOL: all x. (Green(x) -> Nice(x))
TEXT: All quiet things are rough.
FOL: all x. (Quiet(x) -> Rough(x))
TEXT: All rough, nice things are quiet.
FOL: all x. ((Rough(x) & Nice(x)) -> Quiet(x))
TEXT: All quiet, green things are rough.
FOL: all x. ((Quiet(x) & Green(x)) -> Rough(x))
TEXT: If something is nice and quiet then it is blue.
FOL: all x. ((Nice(x) & Quiet(x)) -> Blue(x))
TEXT: Fiona is not blue.
FOL: -Blue(Fiona)
</EVALUATE>
Processed: False

Generation 2:
TEXT: Dave is blue.
FOL: Blue(Dave)
TEXT: Dave is rough.
FOL: Rough(Dave)
TEXT: Dave is young.
FOL: Young(Dave)
TEXT: Erin is blue.
FOL: Blue(Erin)
TEXT: Erin is round.
FOL: Round(Erin)
TEXT: Erin is young.
FOL: Young(Erin)
TEXT: Fiona is rough.
FOL: Rough(Fiona)
TEXT: Gary is green.
FOL: Green(Gary)
TEXT: Gary is nice.
FOL: Nice(Gary)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: Rough things are round.
FOL: all x. (Rough(x) -> Round(x))
TEXT: Green, nice things are quiet.
FOL: all x. (Green(x) & Nice(x) -> Quiet(x))
TEXT: Round, rough things are green.
FOL: all x. (Round(x) & Rough(x) -> Green(x))
TEXT: All quiet things are green.
FOL: all x. (Quiet(x) -> Green(x))
TEXT: All green things are nice.
FOL: all x. (Green(x) -> Nice(x))
TEXT: All quiet things are rough.
FOL: all x. (Quiet(x) -> Rough(x))
TEXT: All rough, nice things are quiet.
FOL: all x. (Rough(x) & Nice(x) -> Quiet(x))
TEXT: All quiet, green things are rough.
FOL: all x. (Quiet(x) & Green(x) -> Rough(x))
TEXT: If something is nice and quiet then it is blue.
FOL: all x. (Nice(x) & Quiet(x) -> Blue(x))
TEXT: Fiona is not blue.
FOL: -Blue(Fiona)
Processed: False

Generation 3:
TEXT: Dave is blue.
FOL: Blue(Dave)
TEXT: Dave is rough.
FOL: Rough(Dave)
TEXT: Dave is young.
FOL: Young(Dave)
TEXT: Erin is blue.
FOL: Blue(Erin)
TEXT: Erin is round.
FOL: Round(Erin)
TEXT: Erin is young.
FOL: Young(Erin)
TEXT: Fiona is rough.
FOL: Rough(Fiona)
TEXT: Gary is green.
FOL: Green(Gary)
TEXT: Gary is nice.
FOL: Nice(Gary)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: Rough things are round.
FOL: all x. (Rough(x) -> Round(x))
TEXT: Green, nice things are quiet.
FOL: all x. ((Green(x) & Nice(x)) -> Quiet(x))
TEXT: Round, rough things are green.
FOL: all x. ((Round(x) & Rough(x)) -> Green(x))
TEXT: All quiet things are green.
FOL: all x. (Quiet(x) -> Green(x))
TEXT: All green things are nice.
FOL: all x. (Green(x) -> Nice(x))
TEXT: All quiet things are rough.
FOL: all x. (Quiet(x) -> Rough(x))
TEXT: All rough, nice things are quiet.
FOL: all x. ((Rough(x) & Nice(x)) -> Quiet(x))
TEXT: All quiet, green things are rough.
FOL: all x. ((Quiet(x) & Green(x)) -> Rough(x))
TEXT: If something is nice and quiet then it is blue.
FOL: all x. ((Nice(x) & Quiet(x)) -> Blue(x))
TEXT: Fiona is not blue.
FOL: -Blue(Fiona)
</EVALUATE>
Processed: False

Reference: False
========================================

=== Example 53 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle chases the mouse.
The bald eagle is round.
The bald eagle needs the cat.
The bald eagle needs the mouse.
The bald eagle visits the cow.
The cat visits the cow.
The cow chases the cat.
The cow is nice.
The cow needs the bald eagle.
The cow visits the bald eagle.
The mouse visits the cat.
If something chases the cat and it chases the cow then the cow visits the mouse.
If something visits the mouse then the mouse chases the cow.
If the cow is blue then the cow needs the cat.
If something visits the cow and it needs the cat then the cat is blue.
If something visits the mouse and it visits the bald eagle then the mouse is nice.
If something is cold then it needs the mouse.
If something is nice and it needs the bald eagle then it chases the cow.
If the mouse chases the bald eagle then the bald eagle visits the mouse.
If the mouse is nice then the mouse chases the bald eagle.
</PREMISES>
<CONCLUSION>
The mouse does not chase the bald eagle.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle chases the mouse.
FOL: Chases(BaldEagle, Mouse)

TEXT: The bald eagle is round.
FOL: IsRound(BaldEagle)

TEXT: The bald eagle needs the cat.
FOL: Needs(BaldEagle, Cat)

TEXT: The bald eagle needs the mouse.
FOL: Needs(BaldEagle, Mouse)

TEXT: The bald eagle visits the cow.
FOL: Visits(BaldEagle, Cow)

TEXT: The cat visits the cow.
FOL: Visits(Cat, Cow)

TEXT: The cow chases the cat.
FOL: Chases(Cow, Cat)

TEXT: The cow is nice.
FOL: IsNice(Cow)

TEXT: The cow needs the bald eagle.
FOL: Needs(Cow, BaldEagle)

TEXT: The cow visits the bald eagle.
FOL: Visits(Cow, BaldEagle)

TEXT: The mouse visits the cat.
FOL: Visits(Mouse, Cat)

TEXT: If something chases the cat and it chases the cow then the cow visits the mouse.
FOL: all x. ((Chases(x, Cat) & Chases(x, Cow)) -> Visits(Cow, Mouse))

TEXT: If something visits the mouse then the mouse chases the cow.
FOL: all x. (Visits(x, Mouse) -> Chases(Mouse, Cow))

TEXT: If the cow is blue then the cow needs the cat.
FOL: IsBlue(Cow) -> Needs(Cow, Cat)

TEXT: If something visits the cow and it needs the cat then the cat is blue.
FOL: all x. ((Visits(x, Cow) & Needs(x, Cat)) -> IsBlue(Cat))

TEXT: If something visits the mouse and it visits the bald eagle then the mouse is nice.
FOL: all x. ((Visits(x, Mouse) & Visits(x, BaldEagle)) -> IsNice(Mouse))

TEXT: If something is cold then it needs the mouse.
FOL: IsCold(x) -> Needs(x, Mouse)

TEXT: If something is nice and it needs the bald eagle then it chases the cow.
FOL: all x. ((IsNice(x) & Needs(x, BaldEagle)) -> Chases(x, Cow))

TEXT: If the mouse chases the bald eagle then the bald eagle visits the mouse.
FOL: Chases(Mouse, BaldEagle) -> Visits(BaldEagle, Mouse)

TEXT: If the mouse is nice then the mouse chases the bald eagle.
FOL: IsNice(Mouse) -> Chases(Mouse, BaldEagle)

TEXT: The mouse does not chase the bald eagle.
FOL: -Chases(Mouse, BaldEagle)
Processed: False

Generation 2:
TEXT: The bald eagle chases the mouse.
FOL: Chases(BaldEagle, Mouse)
TEXT: The bald eagle is round.
FOL: Round(BaldEagle)
TEXT: The bald eagle needs the cat.
FOL: Needs(BaldEagle, Cat)
TEXT: The bald eagle needs the mouse.
FOL: Needs(BaldEagle, Mouse)
TEXT: The bald eagle visits the cow.
FOL: Visits(BaldEagle, Cow)
TEXT: The cat visits the cow.
FOL: Visits(Cat, Cow)
TEXT: The cow chases the cat.
FOL: Chases(Cow, Cat)
TEXT: The cow is nice.
FOL: Nice(Cow)
TEXT: The cow needs the bald eagle.
FOL: Needs(Cow, BaldEagle)
TEXT: The cow visits the bald eagle.
FOL: Visits(Cow, BaldEagle)
TEXT: The mouse visits the cat.
FOL: Visits(Mouse, Cat)
TEXT: If something chases the cat and it chases the cow then the cow visits the mouse.
FOL: all x. ((Chases(x, Cat) & Chases(x, Cow)) -> Visits(Cow, Mouse))
TEXT: If something visits the mouse then the mouse chases the cow.
FOL: all x. (Visits(x, Mouse) -> Chases(Mouse, Cow))
TEXT: If the cow is blue then the cow needs the cat.
FOL: Blue(Cow) -> Needs(Cow, Cat)
TEXT: If something visits the cow and it needs the cat then the cat is blue.
FOL: all x. ((Visits(x, Cow) & Needs(x, Cat)) -> Blue(Cat))
TEXT: If something visits the mouse and it visits the bald eagle then the mouse is nice.
FOL: all x. ((Visits(x, Mouse) & Visits(x, BaldEagle)) -> Nice(Mouse))
TEXT: If something is cold then it needs the mouse.
FOL: all x. (Cold(x) -> Needs(x, Mouse))
TEXT: If something is nice and it needs the bald eagle then it chases the cow.
FOL: all x. ((Nice(x) & Needs(x, BaldEagle)) -> Chases(x, Cow))
TEXT: If the mouse chases the bald eagle then the bald eagle visits the mouse.
FOL: Chases(Mouse, BaldEagle) -> Visits(BaldEagle, Mouse)
TEXT: If the mouse is nice then the mouse chases the bald eagle.
FOL: Nice(Mouse) -> Chases(Mouse, BaldEagle)
TEXT: The mouse does not chase the bald eagle.
FOL: -Chases(Mouse, BaldEagle)
</EVALUATE>
Processed: False

Generation 3:
TEXT: The bald eagle chases the mouse.
FOL: Chases(BaldEagle, Mouse)
TEXT: The bald eagle is round.
FOL: Round(BaldEagle)
TEXT: The bald eagle needs the cat.
FOL: Needs(BaldEagle, Cat)
TEXT: The bald eagle needs the mouse.
FOL: Needs(BaldEagle, Mouse)
TEXT: The bald eagle visits the cow.
FOL: Visits(BaldEagle, Cow)
TEXT: The cat visits the cow.
FOL: Visits(Cat, Cow)
TEXT: The cow chases the cat.
FOL: Chases(Cow, Cat)
TEXT: The cow is nice.
FOL: Nice(Cow)
TEXT: The cow needs the bald eagle.
FOL: Needs(Cow, BaldEagle)
TEXT: The cow visits the bald eagle.
FOL: Visits(Cow, BaldEagle)
TEXT: The mouse visits the cat.
FOL: Visits(Mouse, Cat)
TEXT: If something chases the cat and it chases the cow then the cow visits the mouse.
FOL: all x. ((Chases(x, Cat) & Chases(x, Cow)) -> Visits(Cow, Mouse))
TEXT: If something visits the mouse then the mouse chases the cow.
FOL: all x. (Visits(x, Mouse) -> Chases(Mouse, Cow))
TEXT: If the cow is blue then the cow needs the cat.
FOL: Blue(Cow) -> Needs(Cow, Cat)
TEXT: If something visits the cow and it needs the cat then the cat is blue.
FOL: all x. ((Visits(x, Cow) & Needs(x, Cat)) -> Blue(Cat))
TEXT: If something visits the mouse and it visits the bald eagle then the mouse is nice.
FOL: all x. ((Visits(x, Mouse) & Visits(x, BaldEagle)) -> Nice(Mouse))
TEXT: If something is cold then it needs the mouse.
FOL: all x. (Cold(x) -> Needs(x, Mouse))
TEXT: If something is nice and it needs the bald eagle then it chases the cow.
FOL: all x. ((Nice(x) & Needs(x, BaldEagle)) -> Chases(x, Cow))
TEXT: If the mouse chases the bald eagle then the bald eagle visits the mouse.
FOL: Chases(Mouse, BaldEagle) -> Visits(BaldEagle, Mouse)
TEXT: If the mouse is nice then the mouse chases the bald eagle.
FOL: Nice(Mouse) -> Chases(Mouse, BaldEagle)
TEXT: The mouse does not chase the bald eagle.
FOL: -Chases(Mouse, BaldEagle)
</EVALUATE>
Processed: False

Reference: False
========================================

=== Example 54 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is not cold.
Anne is rough.
Bob is round.
Erin is rough.
Erin is round.
Gary is furry.
Gary is green.
All nice things are green.
Furry things are green.
If something is green and not round then it is white.
Cold, round things are nice.
If Bob is furry then Bob is white.
Round things are cold.
If Anne is white then Anne is furry.
All nice things are rough.
Rough things are furry.
</PREMISES>
<CONCLUSION>
Gary is not round.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is not cold.
FOL: -Cold(Anne)

TEXT: Anne is rough.
FOL: Rough(Anne)

TEXT: Bob is round.
FOL: Round(Bob)

TEXT: Erin is rough.
FOL: Rough(Erin)

TEXT: Erin is round.
FOL: Round(Erin)

TEXT: Gary is furry.
FOL: Furry(Gary)

TEXT: Gary is green.
FOL: Green(Gary)

TEXT: All nice things are green.
FOL: all x. (Nice(x) -> Green(x))

TEXT: Furry things are green.
FOL: all x. (Furry(x) -> Green(x))

TEXT: If something is green and not round then it is white.
FOL: all x. ((Green(x) & -Round(x)) -> White(x))

TEXT: Cold, round things are nice.
FOL: all x. ((Cold(x) & Round(x)) -> Nice(x))

TEXT: If Bob is furry then Bob is white.
FOL: Furry(Bob) -> White(Bob)

TEXT: Round things are cold.
FOL: all x. (Round(x) -> Cold(x))

TEXT: If Anne is white then Anne is furry.
FOL: White(Anne) -> Furry(Anne)

TEXT: All nice things are rough.
FOL: all x. (Nice(x) -> Rough(x))

TEXT: Rough things are furry.
FOL: all x. (Rough(x) -> Furry(x))

TEXT: Gary is not round.
FOL: -Round(Gary)
Processed: Uncertain

Generation 2:
TEXT: Anne is not cold.
FOL: -Cold(Anne)
TEXT: Anne is rough.
FOL: Rough(Anne)
TEXT: Bob is round.
FOL: Round(Bob)
TEXT: Erin is rough.
FOL: Rough(Erin)
TEXT: Erin is round.
FOL: Round(Erin)
TEXT: Gary is furry.
FOL: Furry(Gary)
TEXT: Gary is green.
FOL: Green(Gary)
TEXT: All nice things are green.
FOL: all x. (Nice(x) -> Green(x))
TEXT: Furry things are green.
FOL: all x. (Furry(x) -> Green(x))
TEXT: If something is green and not round then it is white.
FOL: all x. ((Green(x) & -Round(x)) -> White(x))
TEXT: Cold, round things are nice.
FOL: all x. ((Cold(x) & Round(x)) -> Nice(x))
TEXT: If Bob is furry then Bob is white.
FOL: Furry(Bob) -> White(Bob)
TEXT: Round things are cold.
FOL: all x. (Round(x) -> Cold(x))
TEXT: If Anne is white then Anne is furry.
FOL: White(Anne) -> Furry(Anne)
TEXT: All nice things are rough.
FOL: all x. (Nice(x) -> Rough(x))
TEXT: Rough things are furry.
FOL: all x. (Rough(x) -> Furry(x))
TEXT: Gary is not round.
FOL: -Round(Gary)
Processed: Uncertain

Generation 3:
TEXT: Anne is not cold.
FOL: -Cold(Anne)
TEXT: Anne is rough.
FOL: Rough(Anne)
TEXT: Bob is round.
FOL: Round(Bob)
TEXT: Erin is rough.
FOL: Rough(Erin)
TEXT: Erin is round.
FOL: Round(Erin)
TEXT: Gary is furry.
FOL: Furry(Gary)
TEXT: Gary is green.
FOL: Green(Gary)
TEXT: All nice things are green.
FOL: all x. (Nice(x) -> Green(x))
TEXT: Furry things are green.
FOL: all x. (Furry(x) -> Green(x))
TEXT: If something is green and not round then it is white.
FOL: all x. ((Green(x) & -Round(x)) -> White(x))
TEXT: Cold, round things are nice.
FOL: all x. ((Cold(x) & Round(x)) -> Nice(x))
TEXT: If Bob is furry then Bob is white.
FOL: Furry(Bob) -> White(Bob)
TEXT: Round things are cold.
FOL: all x. (Round(x) -> Cold(x))
TEXT: If Anne is white then Anne is furry.
FOL: White(Anne) -> Furry(Anne)
TEXT: All nice things are rough.
FOL: all x. (Nice(x) -> Rough(x))
TEXT: Rough things are furry.
FOL: all x. (Rough(x) -> Furry(x))
TEXT: Gary is not round.
FOL: -Round(Gary)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 55 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is not kind.
Anne is quiet.
Dave is not green.
Dave is rough.
Dave is round.
Dave is smart.
Fiona is quiet.
Fiona is round.
Gary is smart.
Gary is young.
Round people are rough.
If someone is smart then they are rough.
All young, rough people are smart.
If someone is rough then they are kind.
Rough people are kind.
If Fiona is smart and Fiona is kind then Fiona is green.
If Anne is round then Anne is quiet.
Round, rough people are quiet.
All kind people are young.
</PREMISES>
<CONCLUSION>
Gary is not quiet.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is not kind.
FOL: -Kind(Anne)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
TEXT: Dave is not green.
FOL: -Green(Dave)
TEXT: Dave is rough.
FOL: Rough(Dave)
TEXT: Dave is round.
FOL: Round(Dave)
TEXT: Dave is smart.
FOL: Smart(Dave)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Fiona is round.
FOL: Round(Fiona)
TEXT: Gary is smart.
FOL: Smart(Gary)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: Round people are rough.
FOL: all x. (Round(x) -> Rough(x))
TEXT: If someone is smart then they are rough.
FOL: all x. (Smart(x) -> Rough(x))
TEXT: All young, rough people are smart.
FOL: all x. ((Young(x) & Rough(x)) -> Smart(x))
TEXT: If someone is rough then they are kind.
FOL: all x. (Rough(x) -> Kind(x))
TEXT: Rough people are kind.
FOL: all x. (Rough(x) -> Kind(x))
TEXT: If Fiona is smart and Fiona is kind then Fiona is green.
FOL: ((Smart(Fiona) & Kind(Fiona)) -> Green(Fiona))
TEXT: If Anne is round then Anne is quiet.
FOL: (Round(Anne) -> Quiet(Anne))
TEXT: Round, rough people are quiet.
FOL: all x. ((Round(x) & Rough(x)) -> Quiet(x))
TEXT: All kind people are young.
FOL: all x. (Kind(x) -> Young(x))
TEXT: Gary is not quiet.
FOL: -Quiet(Gary)
Processed: Uncertain

Generation 2:
TEXT: Anne is not kind.
FOL: -Kind(Anne)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
TEXT: Dave is not green.
FOL: -Green(Dave)
TEXT: Dave is rough.
FOL: Rough(Dave)
TEXT: Dave is round.
FOL: Round(Dave)
TEXT: Dave is smart.
FOL: Smart(Dave)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Fiona is round.
FOL: Round(Fiona)
TEXT: Gary is smart.
FOL: Smart(Gary)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: Round people are rough.
FOL: all x. (Round(x) -> Rough(x))
TEXT: If someone is smart then they are rough.
FOL: all x. (Smart(x) -> Rough(x))
TEXT: All young, rough people are smart.
FOL: all x. ((Young(x) & Rough(x)) -> Smart(x))
TEXT: If someone is rough then they are kind.
FOL: all x. (Rough(x) -> Kind(x))
TEXT: Rough people are kind.
FOL: all x. (Rough(x) -> Kind(x))
TEXT: If Fiona is smart and Fiona is kind then Fiona is green.
FOL: ((Smart(Fiona) & Kind(Fiona)) -> Green(Fiona))
TEXT: If Anne is round then Anne is quiet.
FOL: (Round(Anne) -> Quiet(Anne))
TEXT: Round, rough people are quiet.
FOL: all x. ((Round(x) & Rough(x)) -> Quiet(x))
TEXT: All kind people are young.
FOL: all x. (Kind(x) -> Young(x))
TEXT: Gary is not quiet.
FOL: -Quiet(Gary)
Processed: Uncertain

Generation 3:
TEXT: Anne is not kind.
FOL: -Kind(Anne)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
TEXT: Dave is not green.
FOL: -Green(Dave)
TEXT: Dave is rough.
FOL: Rough(Dave)
TEXT: Dave is round.
FOL: Round(Dave)
TEXT: Dave is smart.
FOL: Smart(Dave)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Fiona is round.
FOL: Round(Fiona)
TEXT: Gary is smart.
FOL: Smart(Gary)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: Round people are rough.
FOL: all x. (Round(x) -> Rough(x))
TEXT: If someone is smart then they are rough.
FOL: all x. (Smart(x) -> Rough(x))
TEXT: All young, rough people are smart.
FOL: all x. ((Young(x) & Rough(x)) -> Smart(x))
TEXT: If someone is rough then they are kind.
FOL: all x. (Rough(x) -> Kind(x))
TEXT: Rough people are kind.
FOL: all x. (Rough(x) -> Kind(x))
TEXT: If Fiona is smart and Fiona is kind then Fiona is green.
FOL: ((Smart(Fiona) & Kind(Fiona)) -> Green(Fiona))
TEXT: If Anne is round then Anne is quiet.
FOL: (Round(Anne) -> Quiet(Anne))
TEXT: Round, rough people are quiet.
FOL: all x. ((Round(x) & Rough(x)) -> Quiet(x))
TEXT: All kind people are young.
FOL: all x. (Kind(x) -> Young(x))
TEXT: Gary is not quiet.
FOL: -Quiet(Gary)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 56 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The cat is blue.
The cat is nice.
The cat is round.
The cat visits the tiger.
The mouse likes the cat.
The mouse likes the tiger.
The mouse sees the cat.
The mouse visits the tiger.
The squirrel likes the mouse.
The tiger is cold.
The tiger is kind.
The tiger likes the mouse.
The tiger likes the squirrel.
The tiger sees the cat.
The tiger sees the mouse.
The tiger visits the squirrel.
If someone is cold then they like the tiger.
If someone visits the squirrel then they visit the mouse.
If someone is nice then they see the cat.
If someone sees the tiger then they are blue.
If someone visits the mouse then the mouse sees the tiger.
If someone visits the squirrel then they are cold.
If someone is blue then they visit the squirrel.
</PREMISES>
<CONCLUSION>
The squirrel visits the mouse.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The cat is blue.
FOL: Blue(Cat)

TEXT: The cat is nice.
FOL: Nice(Cat)

TEXT: The cat is round.
FOL: Round(Cat)

TEXT: The cat visits the tiger.
FOL: Visits(Cat, Tiger)

TEXT: The mouse likes the cat.
FOL: Likes(Mouse, Cat)

TEXT: The mouse likes the tiger.
FOL: Likes(Mouse, Tiger)

TEXT: The mouse sees the cat.
FOL: Sees(Mouse, Cat)

TEXT: The mouse visits the tiger.
FOL: Visits(Mouse, Tiger)

TEXT: The squirrel likes the mouse.
FOL: Likes(Squirrel, Mouse)

TEXT: The tiger is cold.
FOL: Cold(Tiger)

TEXT: The tiger is kind.
FOL: Kind(Tiger)

TEXT: The tiger likes the mouse.
FOL: Likes(Tiger, Mouse)

TEXT: The tiger likes the squirrel.
FOL: Likes(Tiger, Squirrel)

TEXT: The tiger sees the cat.
FOL: Sees(Tiger, Cat)

TEXT: The tiger sees the mouse.
FOL: Sees(Tiger, Mouse)

TEXT: The tiger visits the squirrel.
FOL: Visits(Tiger, Squirrel)

TEXT: If someone is cold then they like the tiger.
FOL: all x. (Cold(x) -> Likes(x, Tiger))

TEXT: If someone visits the squirrel then they visit the mouse.
FOL: all x. (Visits(x, Squirrel) -> Visits(x, Mouse))

TEXT: If someone is nice then they see the cat.
FOL: all x. (Nice(x) -> Sees(x, Cat))

TEXT: If someone sees the tiger then they are blue.
FOL: all x. (Sees(x, Tiger) -> Blue(x))

TEXT: If someone visits the mouse then the mouse sees the tiger.
FOL: all x. (Visits(x, Mouse) -> Sees(Mouse, Tiger))

TEXT: If someone visits the squirrel then they are cold.
FOL: all x. (Visits(x, Squirrel) -> Cold(x))

TEXT: If someone is blue then they visit the squirrel.
FOL: all x. (Blue(x) -> Visits(x, Squirrel))

TEXT: The squirrel visits the mouse.
FOL: Visits(Squirrel, Mouse)
Processed: Uncertain

Generation 2:
TEXT: The cat is blue.
FOL: Blue(Cat)
TEXT: The cat is nice.
FOL: Nice(Cat)
TEXT: The cat is round.
FOL: Round(Cat)
TEXT: The cat visits the tiger.
FOL: Visits(Cat, Tiger)
TEXT: The mouse likes the cat.
FOL: Likes(Mouse, Cat)
TEXT: The mouse likes the tiger.
FOL: Likes(Mouse, Tiger)
TEXT: The mouse sees the cat.
FOL: Sees(Mouse, Cat)
TEXT: The mouse visits the tiger.
FOL: Visits(Mouse, Tiger)
TEXT: The squirrel likes the mouse.
FOL: Likes(Squirrel, Mouse)
TEXT: The tiger is cold.
FOL: Cold(Tiger)
TEXT: The tiger is kind.
FOL: Kind(Tiger)
TEXT: The tiger likes the mouse.
FOL: Likes(Tiger, Mouse)
TEXT: The tiger likes the squirrel.
FOL: Likes(Tiger, Squirrel)
TEXT: The tiger sees the cat.
FOL: Sees(Tiger, Cat)
TEXT: The tiger sees the mouse.
FOL: Sees(Tiger, Mouse)
TEXT: The tiger visits the squirrel.
FOL: Visits(Tiger, Squirrel)
TEXT: If someone is cold then they like the tiger.
FOL: all x. (Cold(x) -> Likes(x, Tiger))
TEXT: If someone visits the squirrel then they visit the mouse.
FOL: all x. (Visits(x, Squirrel) -> Visits(x, Mouse))
TEXT: If someone is nice then they see the cat.
FOL: all x. (Nice(x) -> Sees(x, Cat))
TEXT: If someone sees the tiger then they are blue.
FOL: all x. (Sees(x, Tiger) -> Blue(x))
TEXT: If someone visits the mouse then the mouse sees the tiger.
FOL: all x. (Visits(x, Mouse) -> Sees(Mouse, Tiger))
TEXT: If someone visits the squirrel then they are cold.
FOL: all x. (Visits(x, Squirrel) -> Cold(x))
TEXT: If someone is blue then they visit the squirrel.
FOL: all x. (Blue(x) -> Visits(x, Squirrel))
TEXT: The squirrel visits the mouse.
FOL: Visits(Squirrel, Mouse)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: The cat is blue.
FOL: Blue(Cat)
TEXT: The cat is nice.
FOL: Nice(Cat)
TEXT: The cat is round.
FOL: Round(Cat)
TEXT: The cat visits the tiger.
FOL: Visits(Cat, Tiger)
TEXT: The mouse likes the cat.
FOL: Likes(Mouse, Cat)
TEXT: The mouse likes the tiger.
FOL: Likes(Mouse, Tiger)
TEXT: The mouse sees the cat.
FOL: Sees(Mouse, Cat)
TEXT: The mouse visits the tiger.
FOL: Visits(Mouse, Tiger)
TEXT: The squirrel likes the mouse.
FOL: Likes(Squirrel, Mouse)
TEXT: The tiger is cold.
FOL: Cold(Tiger)
TEXT: The tiger is kind.
FOL: Kind(Tiger)
TEXT: The tiger likes the mouse.
FOL: Likes(Tiger, Mouse)
TEXT: The tiger likes the squirrel.
FOL: Likes(Tiger, Squirrel)
TEXT: The tiger sees the cat.
FOL: Sees(Tiger, Cat)
TEXT: The tiger sees the mouse.
FOL: Sees(Tiger, Mouse)
TEXT: The tiger visits the squirrel.
FOL: Visits(Tiger, Squirrel)
TEXT: If someone is cold then they like the tiger.
FOL: all x. (Cold(x) -> Likes(x, Tiger))
TEXT: If someone visits the squirrel then they visit the mouse.
FOL: all x. (Visits(x, Squirrel) -> Visits(x, Mouse))
TEXT: If someone is nice then they see the cat.
FOL: all x. (Nice(x) -> Sees(x, Cat))
TEXT: If someone sees the tiger then they are blue.
FOL: all x. (Sees(x, Tiger) -> Blue(x))
TEXT: If someone visits the mouse then the mouse sees the tiger.
FOL: all x. (Visits(x, Mouse) -> Sees(Mouse, Tiger))
TEXT: If someone visits the squirrel then they are cold.
FOL: all x. (Visits(x, Squirrel) -> Cold(x))
TEXT: If someone is blue then they visit the squirrel.
FOL: all x. (Blue(x) -> Visits(x, Squirrel))
TEXT: The squirrel visits the mouse.
FOL: Visits(Squirrel, Mouse)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 57 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle chases the dog.
The bald eagle is red.
The bald eagle does not like the bear.
The bear does not chase the bald eagle.
The bear does not chase the dog.
The bear does not chase the tiger.
The bear is green.
The bear likes the dog.
The bear visits the tiger.
The dog does not chase the bear.
The dog chases the tiger.
The dog is blue.
The tiger is red.
The tiger is rough.
If someone visits the bald eagle and they like the tiger then the bald eagle chases the tiger.
If someone likes the bear and they are not green then the bear chases the tiger.
If someone chases the dog and the dog is not nice then they do not chase the tiger.
If someone chases the bear and they are red then they visit the dog.
If someone chases the bear then the bear is red.
If someone visits the dog then the dog visits the tiger.
If someone is blue and they visit the tiger then they are rough.
If someone is green and they visit the tiger then they chase the bear.
</PREMISES>
<CONCLUSION>
The bald eagle does not visit the dog.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle chases the dog.
FOL: Chases(BaldEagle, Dog)
TEXT: The bald eagle is red.
FOL: Color(BaldEagle, Red)
TEXT: The bald eagle does not like the bear.
FOL: -Likes(BaldEagle, Bear)
TEXT: The bear does not chase the bald eagle.
FOL: -Chases(Bear, BaldEagle)
TEXT: The bear does not chase the dog.
FOL: -Chases(Bear, Dog)
TEXT: The bear does not chase the tiger.
FOL: -Chases(Bear, Tiger)
TEXT: The bear is green.
FOL: Color(Bear, Green)
TEXT: The bear likes the dog.
FOL: Likes(Bear, Dog)
TEXT: The bear visits the tiger.
FOL: Visits(Bear, Tiger)
TEXT: The dog does not chase the bear.
FOL: -Chases(Dog, Bear)
TEXT: The dog chases the tiger.
FOL: Chases(Dog, Tiger)
TEXT: The dog is blue.
FOL: Color(Dog, Blue)
TEXT: The tiger is red.
FOL: Color(Tiger, Red)
TEXT: The tiger is rough.
FOL: Rough(Tiger)
TEXT: If someone visits the bald eagle and they like the tiger then the bald eagle chases the tiger.
FOL: all x. (Visits(x, BaldEagle) & Likes(x, Tiger) -> Chases(BaldEagle, Tiger))
TEXT: If someone likes the bear and they are not green then the bear chases the tiger.
FOL: all x. (Likes(x, Bear) & -Color(x, Green) -> Chases(Bear, Tiger))
TEXT: If someone chases the dog and the dog is not nice then they do not chase the tiger.
FOL: all x. (Chases(x, Dog) & -Nice(Dog) -> -Chases(x, Tiger))
TEXT: If someone chases the bear and they are red then they visit the dog.
FOL: all x. (Chases(x, Bear) & Color(x, Red) -> Visits(x, Dog))
TEXT: If someone chases the bear then the bear is red.
FOL: all x. (Chases(x, Bear) -> Color(Bear, Red))
TEXT: If someone visits the dog then the dog visits the tiger.
FOL: all x. (Visits(x, Dog) -> Visits(Dog, Tiger))
TEXT: If someone is blue and they visit the tiger then they are rough.
FOL: all x. (Color(x, Blue) & Visits(x, Tiger) -> Rough(x))
TEXT: If someone is green and they visit the tiger then they chase the bear.
FOL: all x. (Color(x, Green) & Visits(x, Tiger) -> Chases(x, Bear))
TEXT: The bald eagle does not visit the dog.
FOL: -Visits(BaldEagle, Dog)
Processed: Uncertain

Generation 2:
TEXT: The bald eagle chases the dog.
FOL: Chases(BaldEagle, Dog)
TEXT: The bald eagle is red.
FOL: IsColor(BaldEagle, Red)
TEXT: The bald eagle does not like the bear.
FOL: -Likes(BaldEagle, Bear)
TEXT: The bear does not chase the bald eagle.
FOL: -Chases(Bear, BaldEagle)
TEXT: The bear does not chase the dog.
FOL: -Chases(Bear, Dog)
TEXT: The bear does not chase the tiger.
FOL: -Chases(Bear, Tiger)
TEXT: The bear is green.
FOL: IsColor(Bear, Green)
TEXT: The bear likes the dog.
FOL: Likes(Bear, Dog)
TEXT: The bear visits the tiger.
FOL: Visits(Bear, Tiger)
TEXT: The dog does not chase the bear.
FOL: -Chases(Dog, Bear)
TEXT: The dog chases the tiger.
FOL: Chases(Dog, Tiger)
TEXT: The dog is blue.
FOL: IsColor(Dog, Blue)
TEXT: The tiger is red.
FOL: IsColor(Tiger, Red)
TEXT: The tiger is rough.
FOL: IsTexture(Tiger, Rough)
TEXT: If someone visits the bald eagle and they like the tiger then the bald eagle chases the tiger.
FOL: all x. (Visits(x, BaldEagle) & Likes(x, Tiger) -> Chases(BaldEagle, Tiger))
TEXT: If someone likes the bear and they are not green then the bear chases the tiger.
FOL: all x. (Likes(x, Bear) & -IsColor(x, Green) -> Chases(Bear, Tiger))
TEXT: If someone chases the dog and the dog is not nice then they do not chase the tiger.
FOL: all x. (Chases(x, Dog) & -Nice(Dog) -> -Chases(x, Tiger))
TEXT: If someone chases the bear and they are red then they visit the dog.
FOL: all x. (Chases(x, Bear) & IsColor(x, Red) -> Visits(x, Dog))
TEXT: If someone chases the bear then the bear is red.
FOL: all x. (Chases(x, Bear) -> IsColor(Bear, Red))
TEXT: If someone visits the dog then the dog visits the tiger.
FOL: all x. (Visits(x, Dog) -> Visits(Dog, Tiger))
TEXT: If someone is blue and they visit the tiger then they are rough.
FOL: all x. (IsColor(x, Blue) & Visits(x, Tiger) -> IsTexture(x, Rough))
TEXT: If someone is green and they visit the tiger then they chase the bear.
FOL: all x. (IsColor(x, Green) & Visits(x, Tiger) -> Chases(x, Bear))
TEXT: The bald eagle does not visit the dog.
FOL: -Visits(BaldEagle, Dog)
Processed: Uncertain

Generation 3:
TEXT: The bald eagle chases the dog.
FOL: Chases(BaldEagle, Dog)

TEXT: The bald eagle is red.
FOL: IsColor(BaldEagle, Red)

TEXT: The bald eagle does not like the bear.
FOL: -Likes(BaldEagle, Bear)

TEXT: The bear does not chase the bald eagle.
FOL: -Chases(Bear, BaldEagle)

TEXT: The bear does not chase the dog.
FOL: -Chases(Bear, Dog)

TEXT: The bear does not chase the tiger.
FOL: -Chases(Bear, Tiger)

TEXT: The bear is green.
FOL: IsColor(Bear, Green)

TEXT: The bear likes the dog.
FOL: Likes(Bear, Dog)

TEXT: The bear visits the tiger.
FOL: Visits(Bear, Tiger)

TEXT: The dog does not chase the bear.
FOL: -Chases(Dog, Bear)

TEXT: The dog chases the tiger.
FOL: Chases(Dog, Tiger)

TEXT: The dog is blue.
FOL: IsColor(Dog, Blue)

TEXT: The tiger is red.
FOL: IsColor(Tiger, Red)

TEXT: The tiger is rough.
FOL: IsTexture(Tiger, Rough)

TEXT: If someone visits the bald eagle and they like the tiger then the bald eagle chases the tiger.
FOL: all x. (Visits(x, BaldEagle) & Likes(x, Tiger) -> Chases(BaldEagle, Tiger))

TEXT: If someone likes the bear and they are not green then the bear chases the tiger.
FOL: all x. (Likes(x, Bear) & -IsColor(x, Green) -> Chases(Bear, Tiger))

TEXT: If someone chases the dog and the dog is not nice then they do not chase the tiger.
FOL: all x. (Chases(x, Dog) & -IsNice(Dog) -> -Chases(x, Tiger))

TEXT: If someone chases the bear and they are red then they visit the dog.
FOL: all x. (Chases(x, Bear) & IsColor(x, Red) -> Visits(x, Dog))

TEXT: If someone chases the bear then the bear is red.
FOL: all x. (Chases(x, Bear) -> IsColor(Bear, Red))

TEXT: If someone visits the dog then the dog visits the tiger.
FOL: all x. (Visits(x, Dog) -> Visits(Dog, Tiger))

TEXT: If someone is blue and they visit the tiger then they are rough.
FOL: all x. (IsColor(x, Blue) & Visits(x, Tiger) -> IsTexture(x, Rough))

TEXT: If someone is green and they visit the tiger then they chase the bear.
FOL: all x. (IsColor(x, Green) & Visits(x, Tiger) -> Chases(x, Bear))

TEXT: The bald eagle does not visit the dog.
FOL: -Visits(BaldEagle, Dog)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 58 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle chases the cow.
The bald eagle is kind.
The bald eagle is rough.
The bald eagle needs the rabbit.
The cow chases the rabbit.
The cow is cold.
The cow is green.
The cow is red.
The rabbit does not chase the bald eagle.
The rabbit chases the cow.
The rabbit does not eat the bald eagle.
The rabbit eats the cow.
The rabbit is cold.
The rabbit is green.
The squirrel eats the cow.
The squirrel does not eat the rabbit.
If something needs the bald eagle then the bald eagle chases the rabbit.
If the squirrel is rough and the squirrel is not kind then the squirrel is green.
If something chases the bald eagle then it needs the squirrel.
If something needs the rabbit then it chases the bald eagle.
If something chases the cow then the cow eats the bald eagle.
If something chases the bald eagle and it does not need the bald eagle then it is red.
If something needs the squirrel then the squirrel needs the rabbit.
</PREMISES>
<CONCLUSION>
The cow does not chase the bald eagle.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle chases the cow.
FOL: Chases(BaldEagle, Cow)

TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)

TEXT: The bald eagle is rough.
FOL: Rough(BaldEagle)

TEXT: The bald eagle needs the rabbit.
FOL: Needs(BaldEagle, Rabbit)

TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)

TEXT: The cow is cold.
FOL: Cold(Cow)

TEXT: The cow is green.
FOL: Green(Cow)

TEXT: The cow is red.
FOL: Red(Cow)

TEXT: The rabbit does not chase the bald eagle.
FOL: -Chases(Rabbit, BaldEagle)

TEXT: The rabbit chases the cow.
FOL: Chases(Rabbit, Cow)

TEXT: The rabbit does not eat the bald eagle.
FOL: -Eats(Rabbit, BaldEagle)

TEXT: The rabbit eats the cow.
FOL: Eats(Rabbit, Cow)

TEXT: The rabbit is cold.
FOL: Cold(Rabbit)

TEXT: The rabbit is green.
FOL: Green(Rabbit)

TEXT: The squirrel eats the cow.
FOL: Eats(Squirrel, Cow)

TEXT: The squirrel does not eat the rabbit.
FOL: -Eats(Squirrel, Rabbit)

TEXT: If something needs the bald eagle then the bald eagle chases the rabbit.
FOL: all x. (Needs(x, BaldEagle) -> Chases(BaldEagle, Rabbit))

TEXT: If the squirrel is rough and the squirrel is not kind then the squirrel is green.
FOL: (Rough(Squirrel) & -Kind(Squirrel)) -> Green(Squirrel)

TEXT: If something chases the bald eagle then it needs the squirrel.
FOL: all x. (Chases(x, BaldEagle) -> Needs(x, Squirrel))

TEXT: If something needs the rabbit then it chases the bald eagle.
FOL: all x. (Needs(x, Rabbit) -> Chases(x, BaldEagle))

TEXT: If something chases the cow then the cow eats the bald eagle.
FOL: all x. (Chases(x, Cow) -> Eats(Cow, BaldEagle))

TEXT: If something chases the bald eagle and it does not need the bald eagle then it is red.
FOL: all x. ((Chases(x, BaldEagle) & -Needs(x, BaldEagle)) -> Red(x))

TEXT: If something needs the squirrel then the squirrel needs the rabbit.
FOL: all x. (Needs(x, Squirrel) -> Needs(Squirrel, Rabbit))

TEXT: The cow does not chase the bald eagle.
FOL: -Chases(Cow, BaldEagle)
Processed: Uncertain

Generation 2:
TEXT: The bald eagle chases the cow.
FOL: Chases(BaldEagle, Cow)
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)
TEXT: The bald eagle is rough.
FOL: Rough(BaldEagle)
TEXT: The bald eagle needs the rabbit.
FOL: Needs(BaldEagle, Rabbit)
TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)
TEXT: The cow is cold.
FOL: Cold(Cow)
TEXT: The cow is green.
FOL: Green(Cow)
TEXT: The cow is red.
FOL: Red(Cow)
TEXT: The rabbit does not chase the bald eagle.
FOL: -Chases(Rabbit, BaldEagle)
TEXT: The rabbit chases the cow.
FOL: Chases(Rabbit, Cow)
TEXT: The rabbit does not eat the bald eagle.
FOL: -Eats(Rabbit, BaldEagle)
TEXT: The rabbit eats the cow.
FOL: Eats(Rabbit, Cow)
TEXT: The rabbit is cold.
FOL: Cold(Rabbit)
TEXT: The rabbit is green.
FOL: Green(Rabbit)
TEXT: The squirrel eats the cow.
FOL: Eats(Squirrel, Cow)
TEXT: The squirrel does not eat the rabbit.
FOL: -Eats(Squirrel, Rabbit)
TEXT: If something needs the bald eagle then the bald eagle chases the rabbit.
FOL: all x. (Needs(x, BaldEagle) -> Chases(BaldEagle, Rabbit))
TEXT: If the squirrel is rough and the squirrel is not kind then the squirrel is green.
FOL: (Rough(Squirrel) & -Kind(Squirrel)) -> Green(Squirrel)
TEXT: If something chases the bald eagle then it needs the squirrel.
FOL: all x. (Chases(x, BaldEagle) -> Needs(x, Squirrel))
TEXT: If something needs the rabbit then it chases the bald eagle.
FOL: all x. (Needs(x, Rabbit) -> Chases(x, BaldEagle))
TEXT: If something chases the cow then the cow eats the bald eagle.
FOL: all x. (Chases(x, Cow) -> Eats(Cow, BaldEagle))
TEXT: If something chases the bald eagle and it does not need the bald eagle then it is red.
FOL: all x. ((Chases(x, BaldEagle) & -Needs(x, BaldEagle)) -> Red(x))
TEXT: If something needs the squirrel then the squirrel needs the rabbit.
FOL: all x. (Needs(x, Squirrel) -> Needs(Squirrel, Rabbit))
TEXT: The cow does not chase the bald eagle.
FOL: -Chases(Cow, BaldEagle)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: The bald eagle chases the cow.
FOL: Chases(BaldEagle, Cow)

TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)

TEXT: The bald eagle is rough.
FOL: Rough(BaldEagle)

TEXT: The bald eagle needs the rabbit.
FOL: Needs(BaldEagle, Rabbit)

TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)

TEXT: The cow is cold.
FOL: Cold(Cow)

TEXT: The cow is green.
FOL: Green(Cow)

TEXT: The cow is red.
FOL: Red(Cow)

TEXT: The rabbit does not chase the bald eagle.
FOL: -Chases(Rabbit, BaldEagle)

TEXT: The rabbit chases the cow.
FOL: Chases(Rabbit, Cow)

TEXT: The rabbit does not eat the bald eagle.
FOL: -Eats(Rabbit, BaldEagle)

TEXT: The rabbit eats the cow.
FOL: Eats(Rabbit, Cow)

TEXT: The rabbit is cold.
FOL: Cold(Rabbit)

TEXT: The rabbit is green.
FOL: Green(Rabbit)

TEXT: The squirrel eats the cow.
FOL: Eats(Squirrel, Cow)

TEXT: The squirrel does not eat the rabbit.
FOL: -Eats(Squirrel, Rabbit)

TEXT: If something needs the bald eagle then the bald eagle chases the rabbit.
FOL: all x. (Needs(x, BaldEagle) -> Chases(BaldEagle, Rabbit))

TEXT: If the squirrel is rough and the squirrel is not kind then the squirrel is green.
FOL: (Rough(Squirrel) & -Kind(Squirrel)) -> Green(Squirrel)

TEXT: If something chases the bald eagle then it needs the squirrel.
FOL: all x. (Chases(x, BaldEagle) -> Needs(x, Squirrel))

TEXT: If something needs the rabbit then it chases the bald eagle.
FOL: all x. (Needs(x, Rabbit) -> Chases(x, BaldEagle))

TEXT: If something chases the cow then the cow eats the bald eagle.
FOL: all x. (Chases(x, Cow) -> Eats(Cow, BaldEagle))

TEXT: If something chases the bald eagle and it does not need the bald eagle then it is red.
FOL: all x. ((Chases(x, BaldEagle) & -Needs(x, BaldEagle)) -> Red(x))

TEXT: If something needs the squirrel then the squirrel needs the rabbit.
FOL: all x. (Needs(x, Squirrel) -> Needs(Squirrel, Rabbit))

TEXT: The cow does not chase the bald eagle.
FOL: -Chases(Cow, BaldEagle)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 59 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bear is kind.
The bear visits the mouse.
The cow sees the lion.
The cow visits the mouse.
The lion is round.
The lion sees the bear.
The lion visits the bear.
The lion visits the mouse.
The mouse needs the bear.
The mouse sees the bear.
The mouse sees the cow.
If something needs the bear then it is green.
If the bear sees the lion then the lion is big.
If something sees the mouse and the mouse sees the cow then the mouse needs the cow.
If something needs the cow then it is round.
If something is green then it sees the mouse.
If something is green then it visits the bear.
If something sees the mouse and it sees the bear then the bear is green.
If something sees the cow and it is round then the cow visits the lion.
If something is blue and it visits the cow then the cow sees the bear.
</PREMISES>
<CONCLUSION>
The mouse is not green.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bear is kind.
FOL: Kind(Bear)
TEXT: The bear visits the mouse.
FOL: Visits(Bear, Mouse)
TEXT: The cow sees the lion.
FOL: Sees(Cow, Lion)
TEXT: The cow visits the mouse.
FOL: Visits(Cow, Mouse)
TEXT: The lion is round.
FOL: Round(Lion)
TEXT: The lion sees the bear.
FOL: Sees(Lion, Bear)
TEXT: The lion visits the bear.
FOL: Visits(Lion, Bear)
TEXT: The lion visits the mouse.
FOL: Visits(Lion, Mouse)
TEXT: The mouse needs the bear.
FOL: Needs(Mouse, Bear)
TEXT: The mouse sees the bear.
FOL: Sees(Mouse, Bear)
TEXT: The mouse sees the cow.
FOL: Sees(Mouse, Cow)
TEXT: If something needs the bear then it is green.
FOL: all x. (Needs(x, Bear) -> Green(x))
TEXT: If the bear sees the lion then the lion is big.
FOL: (Sees(Bear, Lion) -> Big(Lion))
TEXT: If something sees the mouse and the mouse sees the cow then the mouse needs the cow.
FOL: all x. ((Sees(x, Mouse) & Sees(Mouse, Cow)) -> Needs(Mouse, Cow))
TEXT: If something needs the cow then it is round.
FOL: all x. (Needs(x, Cow) -> Round(x))
TEXT: If something is green then it sees the mouse.
FOL: all x. (Green(x) -> Sees(x, Mouse))
TEXT: If something is green then it visits the bear.
FOL: all x. (Green(x) -> Visits(x, Bear))
TEXT: If something sees the mouse and it sees the bear then the bear is green.
FOL: all x. ((Sees(x, Mouse) & Sees(x, Bear)) -> Green(Bear))
TEXT: If something sees the cow and it is round then the cow visits the lion.
FOL: all x. ((Sees(x, Cow) & Round(x)) -> Visits(Cow, Lion))
TEXT: If something is blue and it visits the cow then the cow sees the bear.
FOL: all x. ((Blue(x) & Visits(x, Cow)) -> Sees(Cow, Bear))
TEXT: The mouse is not green.
FOL: -Green(Mouse)
</EVALUATE>
Processed: False

Generation 2:
TEXT: The bear is kind.
FOL: Kind(Bear)
TEXT: The bear visits the mouse.
FOL: Visits(Bear, Mouse)
TEXT: The cow sees the lion.
FOL: Sees(Cow, Lion)
TEXT: The cow visits the mouse.
FOL: Visits(Cow, Mouse)
TEXT: The lion is round.
FOL: Round(Lion)
TEXT: The lion sees the bear.
FOL: Sees(Lion, Bear)
TEXT: The lion visits the bear.
FOL: Visits(Lion, Bear)
TEXT: The lion visits the mouse.
FOL: Visits(Lion, Mouse)
TEXT: The mouse needs the bear.
FOL: Needs(Mouse, Bear)
TEXT: The mouse sees the bear.
FOL: Sees(Mouse, Bear)
TEXT: The mouse sees the cow.
FOL: Sees(Mouse, Cow)
TEXT: If something needs the bear then it is green.
FOL: all x. (Needs(x, Bear) -> Green(x))
TEXT: If the bear sees the lion then the lion is big.
FOL: (Sees(Bear, Lion) -> Big(Lion))
TEXT: If something sees the mouse and the mouse sees the cow then the mouse needs the cow.
FOL: all x. (Sees(x, Mouse) & Sees(Mouse, Cow) -> Needs(Mouse, Cow))
TEXT: If something needs the cow then it is round.
FOL: all x. (Needs(x, Cow) -> Round(x))
TEXT: If something is green then it sees the mouse.
FOL: all x. (Green(x) -> Sees(x, Mouse))
TEXT: If something is green then it visits the bear.
FOL: all x. (Green(x) -> Visits(x, Bear))
TEXT: If something sees the mouse and it sees the bear then the bear is green.
FOL: all x. (Sees(x, Mouse) & Sees(x, Bear) -> Green(Bear))
TEXT: If something sees the cow and it is round then the cow visits the lion.
FOL: all x. (Sees(x, Cow) & Round(x) -> Visits(Cow, Lion))
TEXT: If something is blue and it visits the cow then the cow sees the bear.
FOL: all x. (Blue(x) & Visits(x, Cow) -> Sees(Cow, Bear))
TEXT: The mouse is not green.
FOL: -Green(Mouse)
Processed: False

Generation 3:
TEXT: The bear is kind.
FOL: Kind(Bear)

TEXT: The bear visits the mouse.
FOL: Visits(Bear, Mouse)

TEXT: The cow sees the lion.
FOL: Sees(Cow, Lion)

TEXT: The cow visits the mouse.
FOL: Visits(Cow, Mouse)

TEXT: The lion is round.
FOL: Round(Lion)

TEXT: The lion sees the bear.
FOL: Sees(Lion, Bear)

TEXT: The lion visits the bear.
FOL: Visits(Lion, Bear)

TEXT: The lion visits the mouse.
FOL: Visits(Lion, Mouse)

TEXT: The mouse needs the bear.
FOL: Needs(Mouse, Bear)

TEXT: The mouse sees the bear.
FOL: Sees(Mouse, Bear)

TEXT: The mouse sees the cow.
FOL: Sees(Mouse, Cow)

TEXT: If something needs the bear then it is green.
FOL: all x. (Needs(x, Bear) -> Green(x))

TEXT: If the bear sees the lion then the lion is big.
FOL: (Sees(Bear, Lion) -> Big(Lion))

TEXT: If something sees the mouse and the mouse sees the cow then the mouse needs the cow.
FOL: all x. ((Sees(x, Mouse) & Sees(Mouse, Cow)) -> Needs(Mouse, Cow))

TEXT: If something needs the cow then it is round.
FOL: all x. (Needs(x, Cow) -> Round(x))

TEXT: If something is green then it sees the mouse.
FOL: all x. (Green(x) -> Sees(x, Mouse))

TEXT: If something is green then it visits the bear.
FOL: all x. (Green(x) -> Visits(x, Bear))

TEXT: If something sees the mouse and it sees the bear then the bear is green.
FOL: all x. ((Sees(x, Mouse) & Sees(x, Bear)) -> Green(Bear))

TEXT: If something sees the cow and it is round then the cow visits the lion.
FOL: all x. ((Sees(x, Cow) & Round(x)) -> Visits(Cow, Lion))

TEXT: If something is blue and it visits the cow then the cow sees the bear.
FOL: all x. ((Blue(x) & Visits(x, Cow)) -> Sees(Cow, Bear))

TEXT: The mouse is not green.
FOL: -Green(Mouse)
Processed: False

Reference: False
========================================

=== Example 60 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is not smart.
Charlie is white.
Dave is big.
Dave is nice.
Gary is furry.
Gary is kind.
Gary is white.
Kind people are not young.
If someone is nice then they are smart.
Young, kind people are smart.
All white, young people are kind.
If someone is kind then they are big.
If someone is smart then they are furry.
If someone is white then they are nice.
If Anne is smart then Anne is young.
If Charlie is furry then Charlie is kind.
</PREMISES>
<CONCLUSION>
Dave is kind.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is not smart.
FOL: -Smart(Anne)
TEXT: Charlie is white.
FOL: White(Charlie)
TEXT: Dave is big.
FOL: Big(Dave)
TEXT: Dave is nice.
FOL: Nice(Dave)
TEXT: Gary is furry.
FOL: Furry(Gary)
TEXT: Gary is kind.
FOL: Kind(Gary)
TEXT: Gary is white.
FOL: White(Gary)
TEXT: Kind people are not young.
FOL: all x. (Kind(x) -> -Young(x))
TEXT: If someone is nice then they are smart.
FOL: all x. (Nice(x) -> Smart(x))
TEXT: Young, kind people are smart.
FOL: all x. ((Young(x) & Kind(x)) -> Smart(x))
TEXT: All white, young people are kind.
FOL: all x. ((White(x) & Young(x)) -> Kind(x))
TEXT: If someone is kind then they are big.
FOL: all x. (Kind(x) -> Big(x))
TEXT: If someone is smart then they are furry.
FOL: all x. (Smart(x) -> Furry(x))
TEXT: If someone is white then they are nice.
FOL: all x. (White(x) -> Nice(x))
TEXT: If Anne is smart then Anne is young.
FOL: Smart(Anne) -> Young(Anne)
TEXT: If Charlie is furry then Charlie is kind.
FOL: Furry(Charlie) -> Kind(Charlie)
TEXT: Dave is kind.
FOL: Kind(Dave)
Processed: Uncertain

Generation 2:
TEXT: Anne is not smart.
FOL: -Smart(Anne)
TEXT: Charlie is white.
FOL: White(Charlie)
TEXT: Dave is big.
FOL: Big(Dave)
TEXT: Dave is nice.
FOL: Nice(Dave)
TEXT: Gary is furry.
FOL: Furry(Gary)
TEXT: Gary is kind.
FOL: Kind(Gary)
TEXT: Gary is white.
FOL: White(Gary)
TEXT: Kind people are not young.
FOL: all x. (Kind(x) -> -Young(x))
TEXT: If someone is nice then they are smart.
FOL: all x. (Nice(x) -> Smart(x))
TEXT: Young, kind people are smart.
FOL: all x. (Young(x) & Kind(x) -> Smart(x))
TEXT: All white, young people are kind.
FOL: all x. (White(x) & Young(x) -> Kind(x))
TEXT: If someone is kind then they are big.
FOL: all x. (Kind(x) -> Big(x))
TEXT: If someone is smart then they are furry.
FOL: all x. (Smart(x) -> Furry(x))
TEXT: If someone is white then they are nice.
FOL: all x. (White(x) -> Nice(x))
TEXT: If Anne is smart then Anne is young.
FOL: Smart(Anne) -> Young(Anne)
TEXT: If Charlie is furry then Charlie is kind.
FOL: Furry(Charlie) -> Kind(Charlie)
TEXT: Dave is kind.
FOL: Kind(Dave)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: Anne is not smart.
FOL: -Smart(Anne)
TEXT: Charlie is white.
FOL: White(Charlie)
TEXT: Dave is big.
FOL: Big(Dave)
TEXT: Dave is nice.
FOL: Nice(Dave)
TEXT: Gary is furry.
FOL: Furry(Gary)
TEXT: Gary is kind.
FOL: Kind(Gary)
TEXT: Gary is white.
FOL: White(Gary)
TEXT: Kind people are not young.
FOL: all x. (Kind(x) -> -Young(x))
TEXT: If someone is nice then they are smart.
FOL: all x. (Nice(x) -> Smart(x))
TEXT: Young, kind people are smart.
FOL: all x. ((Young(x) & Kind(x)) -> Smart(x))
TEXT: All white, young people are kind.
FOL: all x. ((White(x) & Young(x)) -> Kind(x))
TEXT: If someone is kind then they are big.
FOL: all x. (Kind(x) -> Big(x))
TEXT: If someone is smart then they are furry.
FOL: all x. (Smart(x) -> Furry(x))
TEXT: If someone is white then they are nice.
FOL: all x. (White(x) -> Nice(x))
TEXT: If Anne is smart then Anne is young.
FOL: (Smart(Anne) -> Young(Anne))
TEXT: If Charlie is furry then Charlie is kind.
FOL: (Furry(Charlie) -> Kind(Charlie))
TEXT: Dave is kind.
FOL: Kind(Dave)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 61 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is blue.
Anne is cold.
Bob is blue.
Bob is smart.
Gary is not blue.
Gary is kind.
Harry is blue.
All smart people are kind.
If someone is smart then they are kind.
If someone is blue and smart then they are kind.
Nice people are red.
If someone is kind and cold then they are furry.
All furry, kind people are smart.
Smart, furry people are nice.
If Gary is kind and Gary is not blue then Gary is cold.
</PREMISES>
<CONCLUSION>
Gary is nice.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is blue.
FOL: Blue(Anne)
TEXT: Anne is cold.
FOL: Cold(Anne)
TEXT: Bob is blue.
FOL: Blue(Bob)
TEXT: Bob is smart.
FOL: Smart(Bob)
TEXT: Gary is not blue.
FOL: -Blue(Gary)
TEXT: Gary is kind.
FOL: Kind(Gary)
TEXT: Harry is blue.
FOL: Blue(Harry)
TEXT: All smart people are kind.
FOL: all x. (Smart(x) -> Kind(x))
TEXT: If someone is smart then they are kind.
FOL: all x. (Smart(x) -> Kind(x))
TEXT: If someone is blue and smart then they are kind.
FOL: all x. ((Blue(x) & Smart(x)) -> Kind(x))
TEXT: Nice people are red.
FOL: all x. (Nice(x) -> Red(x))
TEXT: If someone is kind and cold then they are furry.
FOL: all x. ((Kind(x) & Cold(x)) -> Furry(x))
TEXT: All furry, kind people are smart.
FOL: all x. ((Furry(x) & Kind(x)) -> Smart(x))
TEXT: Smart, furry people are nice.
FOL: all x. ((Smart(x) & Furry(x)) -> Nice(x))
TEXT: If Gary is kind and Gary is not blue then Gary is cold.
FOL: ((Kind(Gary) & -Blue(Gary)) -> Cold(Gary))
TEXT: Gary is nice.
FOL: Nice(Gary)
</EVALUATE>
Processed: True

Generation 2:
TEXT: Anne is blue.
FOL: Blue(Anne)

TEXT: Anne is cold.
FOL: Cold(Anne)

TEXT: Bob is blue.
FOL: Blue(Bob)

TEXT: Bob is smart.
FOL: Smart(Bob)

TEXT: Gary is not blue.
FOL: -Blue(Gary)

TEXT: Gary is kind.
FOL: Kind(Gary)

TEXT: Harry is blue.
FOL: Blue(Harry)

TEXT: All smart people are kind.
FOL: all x. (Smart(x) -> Kind(x))

TEXT: If someone is smart then they are kind.
FOL: all x. (Smart(x) -> Kind(x))

TEXT: If someone is blue and smart then they are kind.
FOL: all x. ((Blue(x) & Smart(x)) -> Kind(x))

TEXT: Nice people are red.
FOL: all x. (Nice(x) -> Red(x))

TEXT: If someone is kind and cold then they are furry.
FOL: all x. ((Kind(x) & Cold(x)) -> Furry(x))

TEXT: All furry, kind people are smart.
FOL: all x. ((Furry(x) & Kind(x)) -> Smart(x))

TEXT: Smart, furry people are nice.
FOL: all x. ((Smart(x) & Furry(x)) -> Nice(x))

TEXT: If Gary is kind and Gary is not blue then Gary is cold.
FOL: (Kind(Gary) & -Blue(Gary)) -> Cold(Gary)

TEXT: Gary is nice.
FOL: Nice(Gary)
Processed: True

Generation 3:
TEXT: Anne is blue.
FOL: Blue(Anne)
TEXT: Anne is cold.
FOL: Cold(Anne)
TEXT: Bob is blue.
FOL: Blue(Bob)
TEXT: Bob is smart.
FOL: Smart(Bob)
TEXT: Gary is not blue.
FOL: -Blue(Gary)
TEXT: Gary is kind.
FOL: Kind(Gary)
TEXT: Harry is blue.
FOL: Blue(Harry)
TEXT: All smart people are kind.
FOL: all x. (Smart(x) -> Kind(x))
TEXT: If someone is smart then they are kind.
FOL: all x. (Smart(x) -> Kind(x))
TEXT: If someone is blue and smart then they are kind.
FOL: all x. ((Blue(x) & Smart(x)) -> Kind(x))
TEXT: Nice people are red.
FOL: all x. (Nice(x) -> Red(x))
TEXT: If someone is kind and cold then they are furry.
FOL: all x. ((Kind(x) & Cold(x)) -> Furry(x))
TEXT: All furry, kind people are smart.
FOL: all x. ((Furry(x) & Kind(x)) -> Smart(x))
TEXT: Smart, furry people are nice.
FOL: all x. ((Smart(x) & Furry(x)) -> Nice(x))
TEXT: If Gary is kind and Gary is not blue then Gary is cold.
FOL: (Kind(Gary) & -Blue(Gary)) -> Cold(Gary)
TEXT: Gary is nice.
FOL: Nice(Gary)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 62 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle eats the mouse.
The bald eagle is blue.
The lion is red.
The lion needs the bald eagle.
The lion needs the rabbit.
The mouse eats the lion.
The mouse visits the lion.
The mouse visits the rabbit.
The rabbit eats the bald eagle.
The rabbit is red.
The rabbit is round.
The rabbit needs the bald eagle.
If something is round and it needs the rabbit then the rabbit is big.
If something is big then it needs the rabbit.
If something visits the lion then the lion is green.
If something is green then it is round.
If something needs the bald eagle and the bald eagle needs the lion then it needs the lion.
If something needs the mouse and the mouse needs the rabbit then the rabbit is blue.
If something visits the bald eagle then it needs the lion.
If something needs the rabbit then it visits the bald eagle.
</PREMISES>
<CONCLUSION>
The bald eagle eats the bald eagle.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle eats the mouse.
FOL: Eats(BaldEagle, Mouse)
TEXT: The bald eagle is blue.
FOL: Color(BaldEagle, Blue)
TEXT: The lion is red.
FOL: Color(Lion, Red)
TEXT: The lion needs the bald eagle.
FOL: Needs(Lion, BaldEagle)
TEXT: The lion needs the rabbit.
FOL: Needs(Lion, Rabbit)
TEXT: The mouse eats the lion.
FOL: Eats(Mouse, Lion)
TEXT: The mouse visits the lion.
FOL: Visits(Mouse, Lion)
TEXT: The mouse visits the rabbit.
FOL: Visits(Mouse, Rabbit)
TEXT: The rabbit eats the bald eagle.
FOL: Eats(Rabbit, BaldEagle)
TEXT: The rabbit is red.
FOL: Color(Rabbit, Red)
TEXT: The rabbit is round.
FOL: Shape(Rabbit, Round)
TEXT: The rabbit needs the bald eagle.
FOL: Needs(Rabbit, BaldEagle)
TEXT: If something is round and it needs the rabbit then the rabbit is big.
FOL: all x. (Shape(x, Round) & Needs(x, Rabbit) -> Size(Rabbit, Big))
TEXT: If something is big then it needs the rabbit.
FOL: all x. (Size(x, Big) -> Needs(x, Rabbit))
TEXT: If something visits the lion then the lion is green.
FOL: all x. (Visits(x, Lion) -> Color(Lion, Green))
TEXT: If something is green then it is round.
FOL: all x. (Color(x, Green) -> Shape(x, Round))
TEXT: If something needs the bald eagle and the bald eagle needs the lion then it needs the lion.
FOL: all x. (Needs(x, BaldEagle) & Needs(BaldEagle, Lion) -> Needs(x, Lion))
TEXT: If something needs the mouse and the mouse needs the rabbit then the rabbit is blue.
FOL: all x. (Needs(x, Mouse) & Needs(Mouse, Rabbit) -> Color(Rabbit, Blue))
TEXT: If something visits the bald eagle then it needs the lion.
FOL: all x. (Visits(x, BaldEagle) -> Needs(x, Lion))
TEXT: If something needs the rabbit then it visits the bald eagle.
FOL: all x. (Needs(x, Rabbit) -> Visits(x, BaldEagle))
TEXT: The bald eagle eats the bald eagle.
FOL: Eats(BaldEagle, BaldEagle)
Processed: Uncertain

Generation 2:
TEXT: The bald eagle eats the mouse.
FOL: Eats(BaldEagle, Mouse)

TEXT: The bald eagle is blue.
FOL: IsBlue(BaldEagle)

TEXT: The lion is red.
FOL: IsRed(Lion)

TEXT: The lion needs the bald eagle.
FOL: Needs(Lion, BaldEagle)

TEXT: The lion needs the rabbit.
FOL: Needs(Lion, Rabbit)

TEXT: The mouse eats the lion.
FOL: Eats(Mouse, Lion)

TEXT: The mouse visits the lion.
FOL: Visits(Mouse, Lion)

TEXT: The mouse visits the rabbit.
FOL: Visits(Mouse, Rabbit)

TEXT: The rabbit eats the bald eagle.
FOL: Eats(Rabbit, BaldEagle)

TEXT: The rabbit is red.
FOL: IsRed(Rabbit)

TEXT: The rabbit is round.
FOL: IsRound(Rabbit)

TEXT: The rabbit needs the bald eagle.
FOL: Needs(Rabbit, BaldEagle)

TEXT: If something is round and it needs the rabbit then the rabbit is big.
FOL: all x. ((IsRound(x) & Needs(x, Rabbit)) -> IsBig(Rabbit))

TEXT: If something is big then it needs the rabbit.
FOL: all x. (IsBig(x) -> Needs(x, Rabbit))

TEXT: If something visits the lion then the lion is green.
FOL: all x. (Visits(x, Lion) -> IsGreen(Lion))

TEXT: If something is green then it is round.
FOL: all x. (IsGreen(x) -> IsRound(x))

TEXT: If something needs the bald eagle and the bald eagle needs the lion then it needs the lion.
FOL: all x. ((Needs(x, BaldEagle) & Needs(BaldEagle, Lion)) -> Needs(x, Lion))

TEXT: If something needs the mouse and the mouse needs the rabbit then the rabbit is blue.
FOL: all x. ((Needs(x, Mouse) & Needs(Mouse, Rabbit)) -> IsBlue(Rabbit))

TEXT: If something visits the bald eagle then it needs the lion.
FOL: all x. (Visits(x, BaldEagle) -> Needs(x, Lion))

TEXT: If something needs the rabbit then it visits the bald eagle.
FOL: all x. (Needs(x, Rabbit) -> Visits(x, BaldEagle))

TEXT: The bald eagle eats the bald eagle.
FOL: Eats(BaldEagle, BaldEagle)
Processed: Uncertain

Generation 3:
TEXT: The bald eagle eats the mouse.
FOL: Eats(BaldEagle, Mouse)
TEXT: The bald eagle is blue.
FOL: Color(BaldEagle, Blue)
TEXT: The lion is red.
FOL: Color(Lion, Red)
TEXT: The lion needs the bald eagle.
FOL: Needs(Lion, BaldEagle)
TEXT: The lion needs the rabbit.
FOL: Needs(Lion, Rabbit)
TEXT: The mouse eats the lion.
FOL: Eats(Mouse, Lion)
TEXT: The mouse visits the lion.
FOL: Visits(Mouse, Lion)
TEXT: The mouse visits the rabbit.
FOL: Visits(Mouse, Rabbit)
TEXT: The rabbit eats the bald eagle.
FOL: Eats(Rabbit, BaldEagle)
TEXT: The rabbit is red.
FOL: Color(Rabbit, Red)
TEXT: The rabbit is round.
FOL: Shape(Rabbit, Round)
TEXT: The rabbit needs the bald eagle.
FOL: Needs(Rabbit, BaldEagle)
TEXT: If something is round and it needs the rabbit then the rabbit is big.
FOL: all x. (Shape(x, Round) & Needs(x, Rabbit) -> Big(Rabbit))
TEXT: If something is big then it needs the rabbit.
FOL: all x. (Big(x) -> Needs(x, Rabbit))
TEXT: If something visits the lion then the lion is green.
FOL: all x. (Visits(x, Lion) -> Color(Lion, Green))
TEXT: If something is green then it is round.
FOL: all x. (Color(x, Green) -> Shape(x, Round))
TEXT: If something needs the bald eagle and the bald eagle needs the lion then it needs the lion.
FOL: all x. (Needs(x, BaldEagle) & Needs(BaldEagle, Lion) -> Needs(x, Lion))
TEXT: If something needs the mouse and the mouse needs the rabbit then the rabbit is blue.
FOL: all x. (Needs(x, Mouse) & Needs(Mouse, Rabbit) -> Color(Rabbit, Blue))
TEXT: If something visits the bald eagle then it needs the lion.
FOL: all x. (Visits(x, BaldEagle) -> Needs(x, Lion))
TEXT: If something needs the rabbit then it visits the bald eagle.
FOL: all x. (Needs(x, Rabbit) -> Visits(x, BaldEagle))
TEXT: The bald eagle eats the bald eagle.
FOL: Eats(BaldEagle, BaldEagle)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 63 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is big.
Anne is green.
Charlie is big.
Charlie is green.
Charlie is white.
Erin is red.
Fiona is white.
All white things are blue.
If Anne is big then Anne is not white.
If Charlie is cold and Charlie is blue then Charlie is white.
All big things are not smart.
If something is cold then it is big.
If something is red then it is big.
If Fiona is blue then Fiona is green.
If something is smart and cold then it is green.
Green things are red.
</PREMISES>
<CONCLUSION>
Fiona is big.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is big.
FOL: Big(Anne)
TEXT: Anne is green.
FOL: Green(Anne)
TEXT: Charlie is big.
FOL: Big(Charlie)
TEXT: Charlie is green.
FOL: Green(Charlie)
TEXT: Charlie is white.
FOL: White(Charlie)
TEXT: Erin is red.
FOL: Red(Erin)
TEXT: Fiona is white.
FOL: White(Fiona)
TEXT: All white things are blue.
FOL: all x. (White(x) -> Blue(x))
TEXT: If Anne is big then Anne is not white.
FOL: Big(Anne) -> -White(Anne)
TEXT: If Charlie is cold and Charlie is blue then Charlie is white.
FOL: (Cold(Charlie) & Blue(Charlie)) -> White(Charlie)
TEXT: All big things are not smart.
FOL: all x. (Big(x) -> -Smart(x))
TEXT: If something is cold then it is big.
FOL: all x. (Cold(x) -> Big(x))
TEXT: If something is red then it is big.
FOL: all x. (Red(x) -> Big(x))
TEXT: If Fiona is blue then Fiona is green.
FOL: Blue(Fiona) -> Green(Fiona)
TEXT: If something is smart and cold then it is green.
FOL: all x. ((Smart(x) & Cold(x)) -> Green(x))
TEXT: Green things are red.
FOL: all x. (Green(x) -> Red(x))
TEXT: Fiona is big.
FOL: Big(Fiona)
</EVALUATE>
Processed: True

Generation 2:
TEXT: Anne is big.
FOL: Big(Anne)
TEXT: Anne is green.
FOL: Green(Anne)
TEXT: Charlie is big.
FOL: Big(Charlie)
TEXT: Charlie is green.
FOL: Green(Charlie)
TEXT: Charlie is white.
FOL: White(Charlie)
TEXT: Erin is red.
FOL: Red(Erin)
TEXT: Fiona is white.
FOL: White(Fiona)
TEXT: All white things are blue.
FOL: all x. (White(x) -> Blue(x))
TEXT: If Anne is big then Anne is not white.
FOL: Big(Anne) -> -White(Anne)
TEXT: If Charlie is cold and Charlie is blue then Charlie is white.
FOL: (Cold(Charlie) & Blue(Charlie)) -> White(Charlie)
TEXT: All big things are not smart.
FOL: all x. (Big(x) -> -Smart(x))
TEXT: If something is cold then it is big.
FOL: all x. (Cold(x) -> Big(x))
TEXT: If something is red then it is big.
FOL: all x. (Red(x) -> Big(x))
TEXT: If Fiona is blue then Fiona is green.
FOL: Blue(Fiona) -> Green(Fiona)
TEXT: If something is smart and cold then it is green.
FOL: all x. ((Smart(x) & Cold(x)) -> Green(x))
TEXT: Green things are red.
FOL: all x. (Green(x) -> Red(x))
TEXT: Fiona is big.
FOL: Big(Fiona)
</EVALUATE>
Processed: True

Generation 3:
TEXT: Anne is big.
FOL: Big(Anne)
TEXT: Anne is green.
FOL: Green(Anne)
TEXT: Charlie is big.
FOL: Big(Charlie)
TEXT: Charlie is green.
FOL: Green(Charlie)
TEXT: Charlie is white.
FOL: White(Charlie)
TEXT: Erin is red.
FOL: Red(Erin)
TEXT: Fiona is white.
FOL: White(Fiona)
TEXT: All white things are blue.
FOL: all x. (White(x) -> Blue(x))
TEXT: If Anne is big then Anne is not white.
FOL: Big(Anne) -> -White(Anne)
TEXT: If Charlie is cold and Charlie is blue then Charlie is white.
FOL: Cold(Charlie) & Blue(Charlie) -> White(Charlie)
TEXT: All big things are not smart.
FOL: all x. (Big(x) -> -Smart(x))
TEXT: If something is cold then it is big.
FOL: all x. (Cold(x) -> Big(x))
TEXT: If something is red then it is big.
FOL: all x. (Red(x) -> Big(x))
TEXT: If Fiona is blue then Fiona is green.
FOL: Blue(Fiona) -> Green(Fiona)
TEXT: If something is smart and cold then it is green.
FOL: all x. (Smart(x) & Cold(x) -> Green(x))
TEXT: Green things are red.
FOL: all x. (Green(x) -> Red(x))
TEXT: Fiona is big.
FOL: Big(Fiona)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 64 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle does not chase the cow.
The bald eagle eats the tiger.
The bald eagle is kind.
The cat chases the cow.
The cat eats the bald eagle.
The cow chases the bald eagle.
The cow chases the cat.
The cow eats the bald eagle.
The cow eats the cat.
The cow is not kind.
The cow is red.
The tiger is not big.
The tiger is rough.
The tiger does not visit the cat.
If someone eats the cat and they do not eat the tiger then the tiger does not chase the cat.
If someone is kind and they visit the cow then they do not visit the tiger.
If someone chases the cat then they visit the tiger.
If someone visits the tiger then they visit the bald eagle.
If the tiger eats the bald eagle then the tiger eats the cow.
If someone visits the tiger and they visit the bald eagle then the bald eagle chases the cat.
</PREMISES>
<CONCLUSION>
The cat does not chase the tiger.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle does not chase the cow.
FOL: -Chases(BaldEagle, Cow)

TEXT: The bald eagle eats the tiger.
FOL: Eats(BaldEagle, Tiger)

TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)

TEXT: The cat chases the cow.
FOL: Chases(Cat, Cow)

TEXT: The cat eats the bald eagle.
FOL: Eats(Cat, BaldEagle)

TEXT: The cow chases the bald eagle.
FOL: Chases(Cow, BaldEagle)

TEXT: The cow chases the cat.
FOL: Chases(Cow, Cat)

TEXT: The cow eats the bald eagle.
FOL: Eats(Cow, BaldEagle)

TEXT: The cow eats the cat.
FOL: Eats(Cow, Cat)

TEXT: The cow is not kind.
FOL: -Kind(Cow)

TEXT: The cow is red.
FOL: Red(Cow)

TEXT: The tiger is not big.
FOL: -Big(Tiger)

TEXT: The tiger is rough.
FOL: Rough(Tiger)

TEXT: The tiger does not visit the cat.
FOL: -Visits(Tiger, Cat)

TEXT: If someone eats the cat and they do not eat the tiger then the tiger does not chase the cat.
FOL: all x. (Eats(x, Cat) & -Eats(x, Tiger) -> -Chases(Tiger, Cat))

TEXT: If someone is kind and they visit the cow then they do not visit the tiger.
FOL: all x. (Kind(x) & Visits(x, Cow) -> -Visits(x, Tiger))

TEXT: If someone chases the cat then they visit the tiger.
FOL: all x. (Chases(x, Cat) -> Visits(x, Tiger))

TEXT: If someone visits the tiger then they visit the bald eagle.
FOL: all x. (Visits(x, Tiger) -> Visits(x, BaldEagle))

TEXT: If the tiger eats the bald eagle then the tiger eats the cow.
FOL: Eats(Tiger, BaldEagle) -> Eats(Tiger, Cow)

TEXT: If someone visits the tiger and they visit the bald eagle then the bald eagle chases the cat.
FOL: all x. (Visits(x, Tiger) & Visits(x, BaldEagle) -> Chases(BaldEagle, Cat))

TEXT: The cat does not chase the tiger.
FOL: -Chases(Cat, Tiger)
Processed: Uncertain

Generation 2:
TEXT: The bald eagle does not chase the cow.
FOL: -Chase(BaldEagle, Cow)
TEXT: The bald eagle eats the tiger.
FOL: Eat(BaldEagle, Tiger)
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)
TEXT: The cat chases the cow.
FOL: Chase(Cat, Cow)
TEXT: The cat eats the bald eagle.
FOL: Eat(Cat, BaldEagle)
TEXT: The cow chases the bald eagle.
FOL: Chase(Cow, BaldEagle)
TEXT: The cow chases the cat.
FOL: Chase(Cow, Cat)
TEXT: The cow eats the bald eagle.
FOL: Eat(Cow, BaldEagle)
TEXT: The cow eats the cat.
FOL: Eat(Cow, Cat)
TEXT: The cow is not kind.
FOL: -Kind(Cow)
TEXT: The cow is red.
FOL: Red(Cow)
TEXT: The tiger is not big.
FOL: -Big(Tiger)
TEXT: The tiger is rough.
FOL: Rough(Tiger)
TEXT: The tiger does not visit the cat.
FOL: -Visit(Tiger, Cat)
TEXT: If someone eats the cat and they do not eat the tiger then the tiger does not chase the cat.
FOL: all x. (Eat(x, Cat) & -Eat(x, Tiger) -> -Chase(Tiger, Cat))
TEXT: If someone is kind and they visit the cow then they do not visit the tiger.
FOL: all x. (Kind(x) & Visit(x, Cow) -> -Visit(x, Tiger))
TEXT: If someone chases the cat then they visit the tiger.
FOL: all x. (Chase(x, Cat) -> Visit(x, Tiger))
TEXT: If someone visits the tiger then they visit the bald eagle.
FOL: all x. (Visit(x, Tiger) -> Visit(x, BaldEagle))
TEXT: If the tiger eats the bald eagle then the tiger eats the cow.
FOL: (Eat(Tiger, BaldEagle) -> Eat(Tiger, Cow))
TEXT: If someone visits the tiger and they visit the bald eagle then the bald eagle chases the cat.
FOL: all x. (Visit(x, Tiger) & Visit(x, BaldEagle) -> Chase(BaldEagle, Cat))
TEXT: The cat does not chase the tiger.
FOL: -Chase(Cat, Tiger)
Processed: Uncertain

Generation 3:
TEXT: The bald eagle does not chase the cow.
FOL: -Chases(BaldEagle, Cow)
TEXT: The bald eagle eats the tiger.
FOL: Eats(BaldEagle, Tiger)
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)
TEXT: The cat chases the cow.
FOL: Chases(Cat, Cow)
TEXT: The cat eats the bald eagle.
FOL: Eats(Cat, BaldEagle)
TEXT: The cow chases the bald eagle.
FOL: Chases(Cow, BaldEagle)
TEXT: The cow chases the cat.
FOL: Chases(Cow, Cat)
TEXT: The cow eats the bald eagle.
FOL: Eats(Cow, BaldEagle)
TEXT: The cow eats the cat.
FOL: Eats(Cow, Cat)
TEXT: The cow is not kind.
FOL: -Kind(Cow)
TEXT: The cow is red.
FOL: Red(Cow)
TEXT: The tiger is not big.
FOL: -Big(Tiger)
TEXT: The tiger is rough.
FOL: Rough(Tiger)
TEXT: The tiger does not visit the cat.
FOL: -Visits(Tiger, Cat)
TEXT: If someone eats the cat and they do not eat the tiger then the tiger does not chase the cat.
FOL: all x. (Eats(x, Cat) & -Eats(x, Tiger) -> -Chases(Tiger, Cat))
TEXT: If someone is kind and they visit the cow then they do not visit the tiger.
FOL: all x. (Kind(x) & Visits(x, Cow) -> -Visits(x, Tiger))
TEXT: If someone chases the cat then they visit the tiger.
FOL: all x. (Chases(x, Cat) -> Visits(x, Tiger))
TEXT: If someone visits the tiger then they visit the bald eagle.
FOL: all x. (Visits(x, Tiger) -> Visits(x, BaldEagle))
TEXT: If the tiger eats the bald eagle then the tiger eats the cow.
FOL: (Eats(Tiger, BaldEagle) -> Eats(Tiger, Cow))
TEXT: If someone visits the tiger and they visit the bald eagle then the bald eagle chases the cat.
FOL: all x. (Visits(x, Tiger) & Visits(x, BaldEagle) -> Chases(BaldEagle, Cat))
TEXT: The cat does not chase the tiger.
FOL: -Chases(Cat, Tiger)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 65 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is big.
Anne is quiet.
Anne is not smart.
Bob is blue.
Bob is quiet.
Dave is blue.
Fiona is big.
Fiona is cold.
Fiona is quiet.
Fiona is smart.
Smart people are big.
Blue, red people are big.
If someone is cold and not blue then they are red.
All cold people are smart.
Blue people are cold.
If Bob is big and Bob is cold then Bob is not red.
If someone is smart and not red then they are white.
</PREMISES>
<CONCLUSION>
Fiona is red.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is big.
FOL: Big(Anne)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
TEXT: Anne is not smart.
FOL: -Smart(Anne)
TEXT: Bob is blue.
FOL: Blue(Bob)
TEXT: Bob is quiet.
FOL: Quiet(Bob)
TEXT: Dave is blue.
FOL: Blue(Dave)
TEXT: Fiona is big.
FOL: Big(Fiona)
TEXT: Fiona is cold.
FOL: Cold(Fiona)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Fiona is smart.
FOL: Smart(Fiona)
TEXT: Smart people are big.
FOL: all x. (Smart(x) -> Big(x))
TEXT: Blue, red people are big.
FOL: all x. ((Blue(x) | Red(x)) -> Big(x))
TEXT: If someone is cold and not blue then they are red.
FOL: all x. ((Cold(x) & -Blue(x)) -> Red(x))
TEXT: All cold people are smart.
FOL: all x. (Cold(x) -> Smart(x))
TEXT: Blue people are cold.
FOL: all x. (Blue(x) -> Cold(x))
TEXT: If Bob is big and Bob is cold then Bob is not red.
FOL: ((Big(Bob) & Cold(Bob)) -> -Red(Bob))
TEXT: If someone is smart and not red then they are white.
FOL: all x. ((Smart(x) & -Red(x)) -> White(x))
TEXT: Fiona is red.
FOL: Red(Fiona)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: Anne is big.
FOL: Big(Anne)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
TEXT: Anne is not smart.
FOL: -Smart(Anne)
TEXT: Bob is blue.
FOL: Blue(Bob)
TEXT: Bob is quiet.
FOL: Quiet(Bob)
TEXT: Dave is blue.
FOL: Blue(Dave)
TEXT: Fiona is big.
FOL: Big(Fiona)
TEXT: Fiona is cold.
FOL: Cold(Fiona)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Fiona is smart.
FOL: Smart(Fiona)
TEXT: Smart people are big.
FOL: all x. (Smart(x) -> Big(x))
TEXT: Blue, red people are big.
FOL: all x. ((Blue(x) | Red(x)) -> Big(x))
TEXT: If someone is cold and not blue then they are red.
FOL: all x. ((Cold(x) & -Blue(x)) -> Red(x))
TEXT: All cold people are smart.
FOL: all x. (Cold(x) -> Smart(x))
TEXT: Blue people are cold.
FOL: all x. (Blue(x) -> Cold(x))
TEXT: If Bob is big and Bob is cold then Bob is not red.
FOL: (Big(Bob) & Cold(Bob)) -> -Red(Bob)
TEXT: If someone is smart and not red then they are white.
FOL: all x. ((Smart(x) & -Red(x)) -> White(x))
TEXT: Fiona is red.
FOL: Red(Fiona)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: Anne is big.
FOL: Big(Anne)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
TEXT: Anne is not smart.
FOL: -Smart(Anne)
TEXT: Bob is blue.
FOL: Blue(Bob)
TEXT: Bob is quiet.
FOL: Quiet(Bob)
TEXT: Dave is blue.
FOL: Blue(Dave)
TEXT: Fiona is big.
FOL: Big(Fiona)
TEXT: Fiona is cold.
FOL: Cold(Fiona)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Fiona is smart.
FOL: Smart(Fiona)
TEXT: Smart people are big.
FOL: all x. (Smart(x) -> Big(x))
TEXT: Blue, red people are big.
FOL: all x. ((Blue(x) | Red(x)) -> Big(x))
TEXT: If someone is cold and not blue then they are red.
FOL: all x. ((Cold(x) & -Blue(x)) -> Red(x))
TEXT: All cold people are smart.
FOL: all x. (Cold(x) -> Smart(x))
TEXT: Blue people are cold.
FOL: all x. (Blue(x) -> Cold(x))
TEXT: If Bob is big and Bob is cold then Bob is not red.
FOL: ((Big(Bob) & Cold(Bob)) -> -Red(Bob))
TEXT: If someone is smart and not red then they are white.
FOL: all x. ((Smart(x) & -Red(x)) -> White(x))
TEXT: Fiona is red.
FOL: Red(Fiona)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 66 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is kind.
Anne is white.
Erin is kind.
Fiona is quiet.
Fiona is not white.
Gary is cold.
Gary is furry.
If something is kind then it is not green.
All cold things are not green.
All quiet things are young.
All cold things are quiet.
Kind things are cold.
If something is white and not young then it is furry.
All young things are furry.
Furry, kind things are white.
</PREMISES>
<CONCLUSION>
Anne is not young.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is kind.
FOL: Kind(Anne)
TEXT: Anne is white.
FOL: White(Anne)
TEXT: Erin is kind.
FOL: Kind(Erin)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Fiona is not white.
FOL: -White(Fiona)
TEXT: Gary is cold.
FOL: Cold(Gary)
TEXT: Gary is furry.
FOL: Furry(Gary)
TEXT: If something is kind then it is not green.
FOL: all x. (Kind(x) -> -Green(x))
TEXT: All cold things are not green.
FOL: all x. (Cold(x) -> -Green(x))
TEXT: All quiet things are young.
FOL: all x. (Quiet(x) -> Young(x))
TEXT: All cold things are quiet.
FOL: all x. (Cold(x) -> Quiet(x))
TEXT: Kind things are cold.
FOL: all x. (Kind(x) -> Cold(x))
TEXT: If something is white and not young then it is furry.
FOL: all x. ((White(x) & -Young(x)) -> Furry(x))
TEXT: All young things are furry.
FOL: all x. (Young(x) -> Furry(x))
TEXT: Furry, kind things are white.
FOL: all x. ((Furry(x) & Kind(x)) -> White(x))
TEXT: Anne is not young.
FOL: -Young(Anne)
</EVALUATE>
Processed: False

Generation 2:
TEXT: Anne is kind.
FOL: Kind(Anne)
TEXT: Anne is white.
FOL: White(Anne)
TEXT: Erin is kind.
FOL: Kind(Erin)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Fiona is not white.
FOL: -White(Fiona)
TEXT: Gary is cold.
FOL: Cold(Gary)
TEXT: Gary is furry.
FOL: Furry(Gary)
TEXT: If something is kind then it is not green.
FOL: all x. (Kind(x) -> -Green(x))
TEXT: All cold things are not green.
FOL: all x. (Cold(x) -> -Green(x))
TEXT: All quiet things are young.
FOL: all x. (Quiet(x) -> Young(x))
TEXT: All cold things are quiet.
FOL: all x. (Cold(x) -> Quiet(x))
TEXT: Kind things are cold.
FOL: all x. (Kind(x) -> Cold(x))
TEXT: If something is white and not young then it is furry.
FOL: all x. ((White(x) & -Young(x)) -> Furry(x))
TEXT: All young things are furry.
FOL: all x. (Young(x) -> Furry(x))
TEXT: Furry, kind things are white.
FOL: all x. ((Furry(x) & Kind(x)) -> White(x))
TEXT: Anne is not young.
FOL: -Young(Anne)
Processed: False

Generation 3:
TEXT: Anne is kind.
FOL: Kind(Anne)
TEXT: Anne is white.
FOL: White(Anne)
TEXT: Erin is kind.
FOL: Kind(Erin)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Fiona is not white.
FOL: -White(Fiona)
TEXT: Gary is cold.
FOL: Cold(Gary)
TEXT: Gary is furry.
FOL: Furry(Gary)
TEXT: If something is kind then it is not green.
FOL: all x. (Kind(x) -> -Green(x))
TEXT: All cold things are not green.
FOL: all x. (Cold(x) -> -Green(x))
TEXT: All quiet things are young.
FOL: all x. (Quiet(x) -> Young(x))
TEXT: All cold things are quiet.
FOL: all x. (Cold(x) -> Quiet(x))
TEXT: Kind things are cold.
FOL: all x. (Kind(x) -> Cold(x))
TEXT: If something is white and not young then it is furry.
FOL: all x. ((White(x) & -Young(x)) -> Furry(x))
TEXT: All young things are furry.
FOL: all x. (Young(x) -> Furry(x))
TEXT: Furry, kind things are white.
FOL: all x. ((Furry(x) & Kind(x)) -> White(x))
TEXT: Anne is not young.
FOL: -Young(Anne)
</EVALUATE>
Processed: False

Reference: False
========================================

=== Example 67 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is big.
Anne is not furry.
Anne is green.
Anne is not kind.
Anne is quiet.
Anne is round.
Charlie is big.
Charlie is furry.
Dave is cold.
Dave is quiet.
Fiona is quiet.
Kind things are not furry.
If Dave is furry then Dave is cold.
Cold things are green.
All quiet, green things are round.
If Fiona is round then Fiona is kind.
All quiet things are cold.
All furry things are not cold.
</PREMISES>
<CONCLUSION>
Fiona is not round.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is big.
FOL: Big(Anne)
TEXT: Anne is not furry.
FOL: -Furry(Anne)
TEXT: Anne is green.
FOL: Green(Anne)
TEXT: Anne is not kind.
FOL: -Kind(Anne)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
TEXT: Anne is round.
FOL: Round(Anne)
TEXT: Charlie is big.
FOL: Big(Charlie)
TEXT: Charlie is furry.
FOL: Furry(Charlie)
TEXT: Dave is cold.
FOL: Cold(Dave)
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Kind things are not furry.
FOL: all x. (Kind(x) -> -Furry(x))
TEXT: If Dave is furry then Dave is cold.
FOL: Furry(Dave) -> Cold(Dave)
TEXT: Cold things are green.
FOL: all x. (Cold(x) -> Green(x))
TEXT: All quiet, green things are round.
FOL: all x. ((Quiet(x) & Green(x)) -> Round(x))
TEXT: If Fiona is round then Fiona is kind.
FOL: Round(Fiona) -> Kind(Fiona)
TEXT: All quiet things are cold.
FOL: all x. (Quiet(x) -> Cold(x))
TEXT: All furry things are not cold.
FOL: all x. (Furry(x) -> -Cold(x))
TEXT: Fiona is not round.
FOL: -Round(Fiona)
Processed: False

Generation 2:
TEXT: Anne is big.
FOL: Big(Anne)
TEXT: Anne is not furry.
FOL: -Furry(Anne)
TEXT: Anne is green.
FOL: Green(Anne)
TEXT: Anne is not kind.
FOL: -Kind(Anne)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
TEXT: Anne is round.
FOL: Round(Anne)
TEXT: Charlie is big.
FOL: Big(Charlie)
TEXT: Charlie is furry.
FOL: Furry(Charlie)
TEXT: Dave is cold.
FOL: Cold(Dave)
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Kind things are not furry.
FOL: all x. (Kind(x) -> -Furry(x))
TEXT: If Dave is furry then Dave is cold.
FOL: Furry(Dave) -> Cold(Dave)
TEXT: Cold things are green.
FOL: all x. (Cold(x) -> Green(x))
TEXT: All quiet, green things are round.
FOL: all x. (Quiet(x) & Green(x) -> Round(x))
TEXT: If Fiona is round then Fiona is kind.
FOL: Round(Fiona) -> Kind(Fiona)
TEXT: All quiet things are cold.
FOL: all x. (Quiet(x) -> Cold(x))
TEXT: All furry things are not cold.
FOL: all x. (Furry(x) -> -Cold(x))
TEXT: Fiona is not round.
FOL: -Round(Fiona)
Processed: False

Generation 3:
TEXT: Anne is big.
FOL: Big(Anne)
TEXT: Anne is not furry.
FOL: -Furry(Anne)
TEXT: Anne is green.
FOL: Green(Anne)
TEXT: Anne is not kind.
FOL: -Kind(Anne)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
TEXT: Anne is round.
FOL: Round(Anne)
TEXT: Charlie is big.
FOL: Big(Charlie)
TEXT: Charlie is furry.
FOL: Furry(Charlie)
TEXT: Dave is cold.
FOL: Cold(Dave)
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Kind things are not furry.
FOL: all x. (Kind(x) -> -Furry(x))
TEXT: If Dave is furry then Dave is cold.
FOL: (Furry(Dave) -> Cold(Dave))
TEXT: Cold things are green.
FOL: all x. (Cold(x) -> Green(x))
TEXT: All quiet, green things are round.
FOL: all x. (Quiet(x) & Green(x) -> Round(x))
TEXT: If Fiona is round then Fiona is kind.
FOL: (Round(Fiona) -> Kind(Fiona))
TEXT: All quiet things are cold.
FOL: all x. (Quiet(x) -> Cold(x))
TEXT: All furry things are not cold.
FOL: all x. (Furry(x) -> -Cold(x))
TEXT: Fiona is not round.
FOL: -Round(Fiona)
</EVALUATE>
Processed: False

Reference: False
========================================

=== Example 68 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The cat is blue.
The cat is rough.
The cat needs the dog.
The cow is red.
The cow likes the cat.
The cow likes the dog.
The dog is rough.
The dog visits the rabbit.
The rabbit is blue.
The rabbit is rough.
The rabbit needs the cow.
The rabbit visits the cow.
If someone visits the cat then they are cold.
If someone visits the cat then they need the rabbit.
If someone likes the dog then they visit the cat.
If someone is rough then they like the rabbit.
If someone needs the dog then they visit the cat.
If someone needs the rabbit then the rabbit likes the dog.
If the dog visits the rabbit and the rabbit visits the dog then the dog is nice.
</PREMISES>
<CONCLUSION>
The cat does not need the cat.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The cat is blue.
FOL: Color(Cat, Blue)
TEXT: The cat is rough.
FOL: Rough(Cat)
TEXT: The cat needs the dog.
FOL: Needs(Cat, Dog)
TEXT: The cow is red.
FOL: Color(Cow, Red)
TEXT: The cow likes the cat.
FOL: Likes(Cow, Cat)
TEXT: The cow likes the dog.
FOL: Likes(Cow, Dog)
TEXT: The dog is rough.
FOL: Rough(Dog)
TEXT: The dog visits the rabbit.
FOL: Visits(Dog, Rabbit)
TEXT: The rabbit is blue.
FOL: Color(Rabbit, Blue)
TEXT: The rabbit is rough.
FOL: Rough(Rabbit)
TEXT: The rabbit needs the cow.
FOL: Needs(Rabbit, Cow)
TEXT: The rabbit visits the cow.
FOL: Visits(Rabbit, Cow)
TEXT: If someone visits the cat then they are cold.
FOL: all x. (Visits(x, Cat) -> Cold(x))
TEXT: If someone visits the cat then they need the rabbit.
FOL: all x. (Visits(x, Cat) -> Needs(x, Rabbit))
TEXT: If someone likes the dog then they visit the cat.
FOL: all x. (Likes(x, Dog) -> Visits(x, Cat))
TEXT: If someone is rough then they like the rabbit.
FOL: all x. (Rough(x) -> Likes(x, Rabbit))
TEXT: If someone needs the dog then they visit the cat.
FOL: all x. (Needs(x, Dog) -> Visits(x, Cat))
TEXT: If someone needs the rabbit then the rabbit likes the dog.
FOL: all x. (Needs(x, Rabbit) -> Likes(Rabbit, Dog))
TEXT: If the dog visits the rabbit and the rabbit visits the dog then the dog is nice.
FOL: ((Visits(Dog, Rabbit) & Visits(Rabbit, Dog)) -> Nice(Dog))
TEXT: The cat does not need the cat.
FOL: -Needs(Cat, Cat)
Processed: Uncertain

Generation 2:
TEXT: The cat is blue.
FOL: Blue(Cat)

TEXT: The cat is rough.
FOL: Rough(Cat)

TEXT: The cat needs the dog.
FOL: Needs(Cat, Dog)

TEXT: The cow is red.
FOL: Red(Cow)

TEXT: The cow likes the cat.
FOL: Likes(Cow, Cat)

TEXT: The cow likes the dog.
FOL: Likes(Cow, Dog)

TEXT: The dog is rough.
FOL: Rough(Dog)

TEXT: The dog visits the rabbit.
FOL: Visits(Dog, Rabbit)

TEXT: The rabbit is blue.
FOL: Blue(Rabbit)

TEXT: The rabbit is rough.
FOL: Rough(Rabbit)

TEXT: The rabbit needs the cow.
FOL: Needs(Rabbit, Cow)

TEXT: The rabbit visits the cow.
FOL: Visits(Rabbit, Cow)

TEXT: If someone visits the cat then they are cold.
FOL: all x. (Visits(x, Cat) -> Cold(x))

TEXT: If someone visits the cat then they need the rabbit.
FOL: all x. (Visits(x, Cat) -> Needs(x, Rabbit))

TEXT: If someone likes the dog then they visit the cat.
FOL: all x. (Likes(x, Dog) -> Visits(x, Cat))

TEXT: If someone is rough then they like the rabbit.
FOL: all x. (Rough(x) -> Likes(x, Rabbit))

TEXT: If someone needs the dog then they visit the cat.
FOL: all x. (Needs(x, Dog) -> Visits(x, Cat))

TEXT: If someone needs the rabbit then the rabbit likes the dog.
FOL: all x. (Needs(x, Rabbit) -> Likes(Rabbit, Dog))

TEXT: If the dog visits the rabbit and the rabbit visits the dog then the dog is nice.
FOL: (Visits(Dog, Rabbit) & Visits(Rabbit, Dog)) -> Nice(Dog)

TEXT: The cat does not need the cat.
FOL: -Needs(Cat, Cat)
Processed: Uncertain

Generation 3:
TEXT: The cat is blue.
FOL: Color(Cat, Blue)
TEXT: The cat is rough.
FOL: Rough(Cat)
TEXT: The cat needs the dog.
FOL: Needs(Cat, Dog)
TEXT: The cow is red.
FOL: Color(Cow, Red)
TEXT: The cow likes the cat.
FOL: Likes(Cow, Cat)
TEXT: The cow likes the dog.
FOL: Likes(Cow, Dog)
TEXT: The dog is rough.
FOL: Rough(Dog)
TEXT: The dog visits the rabbit.
FOL: Visits(Dog, Rabbit)
TEXT: The rabbit is blue.
FOL: Color(Rabbit, Blue)
TEXT: The rabbit is rough.
FOL: Rough(Rabbit)
TEXT: The rabbit needs the cow.
FOL: Needs(Rabbit, Cow)
TEXT: The rabbit visits the cow.
FOL: Visits(Rabbit, Cow)
TEXT: If someone visits the cat then they are cold.
FOL: all x. (Visits(x, Cat) -> Cold(x))
TEXT: If someone visits the cat then they need the rabbit.
FOL: all x. (Visits(x, Cat) -> Needs(x, Rabbit))
TEXT: If someone likes the dog then they visit the cat.
FOL: all x. (Likes(x, Dog) -> Visits(x, Cat))
TEXT: If someone is rough then they like the rabbit.
FOL: all x. (Rough(x) -> Likes(x, Rabbit))
TEXT: If someone needs the dog then they visit the cat.
FOL: all x. (Needs(x, Dog) -> Visits(x, Cat))
TEXT: If someone needs the rabbit then the rabbit likes the dog.
FOL: all x. (Needs(x, Rabbit) -> Likes(Rabbit, Dog))
TEXT: If the dog visits the rabbit and the rabbit visits the dog then the dog is nice.
FOL: (Visits(Dog, Rabbit) & Visits(Rabbit, Dog)) -> Nice(Dog)
TEXT: The cat does not need the cat.
FOL: -Needs(Cat, Cat)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 69 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle is kind.
The bald eagle is red.
The bear eats the tiger.
The bear is round.
The bear likes the bald eagle.
The bear sees the lion.
The lion eats the tiger.
The lion is cold.
The lion sees the tiger.
The tiger is not nice.
The tiger likes the bald eagle.
The tiger sees the bald eagle.
If something is kind then it likes the bear.
If something is nice then it likes the tiger.
If something eats the lion then it does not like the tiger.
If the bald eagle likes the lion and the bald eagle sees the tiger then the lion is red.
If something eats the bald eagle then the bald eagle does not see the bear.
If something sees the tiger then the tiger likes the lion.
If something eats the bear and it is round then it is nice.
If something eats the tiger and it likes the bear then the bear is kind.
If something likes the lion then the lion is kind.
</PREMISES>
<CONCLUSION>
The bear is kind.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)
TEXT: The bald eagle is red.
FOL: Red(BaldEagle)
TEXT: The bear eats the tiger.
FOL: Eats(Bear, Tiger)
TEXT: The bear is round.
FOL: Round(Bear)
TEXT: The bear likes the bald eagle.
FOL: Likes(Bear, BaldEagle)
TEXT: The bear sees the lion.
FOL: Sees(Bear, Lion)
TEXT: The lion eats the tiger.
FOL: Eats(Lion, Tiger)
TEXT: The lion is cold.
FOL: Cold(Lion)
TEXT: The lion sees the tiger.
FOL: Sees(Lion, Tiger)
TEXT: The tiger is not nice.
FOL: -Nice(Tiger)
TEXT: The tiger likes the bald eagle.
FOL: Likes(Tiger, BaldEagle)
TEXT: The tiger sees the bald eagle.
FOL: Sees(Tiger, BaldEagle)
TEXT: If something is kind then it likes the bear.
FOL: all x. (Kind(x) -> Likes(x, Bear))
TEXT: If something is nice then it likes the tiger.
FOL: all x. (Nice(x) -> Likes(x, Tiger))
TEXT: If something eats the lion then it does not like the tiger.
FOL: all x. (Eats(x, Lion) -> -Likes(x, Tiger))
TEXT: If the bald eagle likes the lion and the bald eagle sees the tiger then the lion is red.
FOL: (Likes(BaldEagle, Lion) & Sees(BaldEagle, Tiger)) -> Red(Lion)
TEXT: If something eats the bald eagle then the bald eagle does not see the bear.
FOL: all x. (Eats(x, BaldEagle) -> -Sees(BaldEagle, Bear))
TEXT: If something sees the tiger then the tiger likes the lion.
FOL: all x. (Sees(x, Tiger) -> Likes(Tiger, Lion))
TEXT: If something eats the bear and it is round then it is nice.
FOL: all x. (Eats(x, Bear) & Round(x) -> Nice(x))
TEXT: If something eats the tiger and it likes the bear then the bear is kind.
FOL: all x. (Eats(x, Tiger) & Likes(x, Bear) -> Kind(Bear))
TEXT: If something likes the lion then the lion is kind.
FOL: all x. (Likes(x, Lion) -> Kind(Lion))
TEXT: The bear is kind.
FOL: Kind(Bear)
</EVALUATE>
Processed: True

Generation 2:
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)
TEXT: The bald eagle is red.
FOL: Red(BaldEagle)
TEXT: The bear eats the tiger.
FOL: Eats(Bear, Tiger)
TEXT: The bear is round.
FOL: Round(Bear)
TEXT: The bear likes the bald eagle.
FOL: Likes(Bear, BaldEagle)
TEXT: The bear sees the lion.
FOL: Sees(Bear, Lion)
TEXT: The lion eats the tiger.
FOL: Eats(Lion, Tiger)
TEXT: The lion is cold.
FOL: Cold(Lion)
TEXT: The lion sees the tiger.
FOL: Sees(Lion, Tiger)
TEXT: The tiger is not nice.
FOL: -Nice(Tiger)
TEXT: The tiger likes the bald eagle.
FOL: Likes(Tiger, BaldEagle)
TEXT: The tiger sees the bald eagle.
FOL: Sees(Tiger, BaldEagle)
TEXT: If something is kind then it likes the bear.
FOL: all x. (Kind(x) -> Likes(x, Bear))
TEXT: If something is nice then it likes the tiger.
FOL: all x. (Nice(x) -> Likes(x, Tiger))
TEXT: If something eats the lion then it does not like the tiger.
FOL: all x. (Eats(x, Lion) -> -Likes(x, Tiger))
TEXT: If the bald eagle likes the lion and the bald eagle sees the tiger then the lion is red.
FOL: (Likes(BaldEagle, Lion) & Sees(BaldEagle, Tiger)) -> Red(Lion)
TEXT: If something eats the bald eagle then the bald eagle does not see the bear.
FOL: all x. (Eats(x, BaldEagle) -> -Sees(BaldEagle, Bear))
TEXT: If something sees the tiger then the tiger likes the lion.
FOL: all x. (Sees(x, Tiger) -> Likes(Tiger, Lion))
TEXT: If something eats the bear and it is round then it is nice.
FOL: all x. (Eats(x, Bear) & Round(x) -> Nice(x))
TEXT: If something eats the tiger and it likes the bear then the bear is kind.
FOL: all x. (Eats(x, Tiger) & Likes(x, Bear) -> Kind(Bear))
TEXT: If something likes the lion then the lion is kind.
FOL: all x. (Likes(x, Lion) -> Kind(Lion))
TEXT: The bear is kind.
FOL: Kind(Bear)
Processed: True

Generation 3:
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)
TEXT: The bald eagle is red.
FOL: Red(BaldEagle)
TEXT: The bear eats the tiger.
FOL: Eats(Bear, Tiger)
TEXT: The bear is round.
FOL: Round(Bear)
TEXT: The bear likes the bald eagle.
FOL: Likes(Bear, BaldEagle)
TEXT: The bear sees the lion.
FOL: Sees(Bear, Lion)
TEXT: The lion eats the tiger.
FOL: Eats(Lion, Tiger)
TEXT: The lion is cold.
FOL: Cold(Lion)
TEXT: The lion sees the tiger.
FOL: Sees(Lion, Tiger)
TEXT: The tiger is not nice.
FOL: -Nice(Tiger)
TEXT: The tiger likes the bald eagle.
FOL: Likes(Tiger, BaldEagle)
TEXT: The tiger sees the bald eagle.
FOL: Sees(Tiger, BaldEagle)
TEXT: If something is kind then it likes the bear.
FOL: all x. (Kind(x) -> Likes(x, Bear))
TEXT: If something is nice then it likes the tiger.
FOL: all x. (Nice(x) -> Likes(x, Tiger))
TEXT: If something eats the lion then it does not like the tiger.
FOL: all x. (Eats(x, Lion) -> -Likes(x, Tiger))
TEXT: If the bald eagle likes the lion and the bald eagle sees the tiger then the lion is red.
FOL: (Likes(BaldEagle, Lion) & Sees(BaldEagle, Tiger)) -> Red(Lion)
TEXT: If something eats the bald eagle then the bald eagle does not see the bear.
FOL: all x. (Eats(x, BaldEagle) -> -Sees(BaldEagle, Bear))
TEXT: If something sees the tiger then the tiger likes the lion.
FOL: all x. (Sees(x, Tiger) -> Likes(Tiger, Lion))
TEXT: If something eats the bear and it is round then it is nice.
FOL: all x. ((Eats(x, Bear) & Round(x)) -> Nice(x))
TEXT: If something eats the tiger and it likes the bear then the bear is kind.
FOL: all x. ((Eats(x, Tiger) & Likes(x, Bear)) -> Kind(Bear))
TEXT: If something likes the lion then the lion is kind.
FOL: all x. (Likes(x, Lion) -> Kind(Lion))
TEXT: The bear is kind.
FOL: Kind(Bear)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 70 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The cat eats the mouse.
The cat likes the tiger.
The cow eats the tiger.
The cow likes the cat.
The mouse chases the cat.
The mouse chases the cow.
The mouse eats the tiger.
The mouse is green.
The mouse is round.
The tiger chases the cat.
The tiger eats the cow.
The tiger likes the mouse.
If someone chases the cow and they chase the mouse then the mouse is blue.
If someone eats the cat then they are nice.
If the cat eats the mouse then the mouse likes the cow.
If someone chases the mouse and they are round then they are big.
If someone chases the tiger and the tiger chases the cat then the tiger is round.
If someone eats the tiger and they like the cat then the cat likes the cow.
If the mouse likes the cow and the mouse chases the cow then the cow eats the cat.
If someone eats the cow and they eat the cat then they chase the tiger.
If someone eats the tiger and they eat the cat then the tiger eats the cat.
</PREMISES>
<CONCLUSION>
The cow is big.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The cat eats the mouse.
FOL: Eats(Cat, Mouse)

TEXT: The cat likes the tiger.
FOL: Likes(Cat, Tiger)

TEXT: The cow eats the tiger.
FOL: Eats(Cow, Tiger)

TEXT: The cow likes the cat.
FOL: Likes(Cow, Cat)

TEXT: The mouse chases the cat.
FOL: Chases(Mouse, Cat)

TEXT: The mouse chases the cow.
FOL: Chases(Mouse, Cow)

TEXT: The mouse eats the tiger.
FOL: Eats(Mouse, Tiger)

TEXT: The mouse is green.
FOL: IsGreen(Mouse)

TEXT: The mouse is round.
FOL: IsRound(Mouse)

TEXT: The tiger chases the cat.
FOL: Chases(Tiger, Cat)

TEXT: The tiger eats the cow.
FOL: Eats(Tiger, Cow)

TEXT: The tiger likes the mouse.
FOL: Likes(Tiger, Mouse)

TEXT: If someone chases the cow and they chase the mouse then the mouse is blue.
FOL: all x. (Chases(x, Cow) & Chases(x, Mouse) -> IsBlue(Mouse))

TEXT: If someone eats the cat then they are nice.
FOL: all x. (Eats(x, Cat) -> Nice(x))

TEXT: If the cat eats the mouse then the mouse likes the cow.
FOL: (Eats(Cat, Mouse) -> Likes(Mouse, Cow))

TEXT: If someone chases the mouse and they are round then they are big.
FOL: all x. (Chases(x, Mouse) & IsRound(x) -> IsBig(x))

TEXT: If someone chases the tiger and the tiger chases the cat then the tiger is round.
FOL: all x. (Chases(x, Tiger) & Chases(Tiger, Cat) -> IsRound(Tiger))

TEXT: If someone eats the tiger and they like the cat then the cat likes the cow.
FOL: all x. (Eats(x, Tiger) & Likes(x, Cat) -> Likes(Cat, Cow))

TEXT: If the mouse likes the cow and the mouse chases the cow then the cow eats the cat.
FOL: (Likes(Mouse, Cow) & Chases(Mouse, Cow) -> Eats(Cow, Cat))

TEXT: If someone eats the cow and they eat the cat then they chase the tiger.
FOL: all x. (Eats(x, Cow) & Eats(x, Cat) -> Chases(x, Tiger))

TEXT: If someone eats the tiger and they eat the cat then the tiger eats the cat.
FOL: all x. (Eats(x, Tiger) & Eats(x, Cat) -> Eats(Tiger, Cat))

TEXT: The cow is big.
FOL: IsBig(Cow)
Processed: Uncertain

Generation 2:
TEXT: The cat eats the mouse.
FOL: Eats(Cat, Mouse)
TEXT: The cat likes the tiger.
FOL: Likes(Cat, Tiger)
TEXT: The cow eats the tiger.
FOL: Eats(Cow, Tiger)
TEXT: The cow likes the cat.
FOL: Likes(Cow, Cat)
TEXT: The mouse chases the cat.
FOL: Chases(Mouse, Cat)
TEXT: The mouse chases the cow.
FOL: Chases(Mouse, Cow)
TEXT: The mouse eats the tiger.
FOL: Eats(Mouse, Tiger)
TEXT: The mouse is green.
FOL: Color(Mouse, Green)
TEXT: The mouse is round.
FOL: Shape(Mouse, Round)
TEXT: The tiger chases the cat.
FOL: Chases(Tiger, Cat)
TEXT: The tiger eats the cow.
FOL: Eats(Tiger, Cow)
TEXT: The tiger likes the mouse.
FOL: Likes(Tiger, Mouse)
TEXT: If someone chases the cow and they chase the mouse then the mouse is blue.
FOL: all x. (Chases(x, Cow) & Chases(x, Mouse) -> Color(Mouse, Blue))
TEXT: If someone eats the cat then they are nice.
FOL: all x. (Eats(x, Cat) -> Nice(x))
TEXT: If the cat eats the mouse then the mouse likes the cow.
FOL: (Eats(Cat, Mouse) -> Likes(Mouse, Cow))
TEXT: If someone chases the mouse and they are round then they are big.
FOL: all x. (Chases(x, Mouse) & Shape(x, Round) -> Big(x))
TEXT: If someone chases the tiger and the tiger chases the cat then the tiger is round.
FOL: all x. (Chases(x, Tiger) & Chases(Tiger, Cat) -> Shape(Tiger, Round))
TEXT: If someone eats the tiger and they like the cat then the cat likes the cow.
FOL: all x. (Eats(x, Tiger) & Likes(x, Cat) -> Likes(Cat, Cow))
TEXT: If the mouse likes the cow and the mouse chases the cow then the cow eats the cat.
FOL: (Likes(Mouse, Cow) & Chases(Mouse, Cow) -> Eats(Cow, Cat))
TEXT: If someone eats the cow and they eat the cat then they chase the tiger.
FOL: all x. (Eats(x, Cow) & Eats(x, Cat) -> Chases(x, Tiger))
TEXT: If someone eats the tiger and they eat the cat then the tiger eats the cat.
FOL: all x. (Eats(x, Tiger) & Eats(x, Cat) -> Eats(Tiger, Cat))
TEXT: The cow is big.
FOL: Big(Cow)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: The cat eats the mouse.
FOL: Eats(Cat, Mouse)
TEXT: The cat likes the tiger.
FOL: Likes(Cat, Tiger)
TEXT: The cow eats the tiger.
FOL: Eats(Cow, Tiger)
TEXT: The cow likes the cat.
FOL: Likes(Cow, Cat)
TEXT: The mouse chases the cat.
FOL: Chases(Mouse, Cat)
TEXT: The mouse chases the cow.
FOL: Chases(Mouse, Cow)
TEXT: The mouse eats the tiger.
FOL: Eats(Mouse, Tiger)
TEXT: The mouse is green.
FOL: IsGreen(Mouse)
TEXT: The mouse is round.
FOL: IsRound(Mouse)
TEXT: The tiger chases the cat.
FOL: Chases(Tiger, Cat)
TEXT: The tiger eats the cow.
FOL: Eats(Tiger, Cow)
TEXT: The tiger likes the mouse.
FOL: Likes(Tiger, Mouse)
TEXT: If someone chases the cow and they chase the mouse then the mouse is blue.
FOL: all x. ((Chases(x, Cow) & Chases(x, Mouse)) -> IsBlue(Mouse))
TEXT: If someone eats the cat then they are nice.
FOL: all x. (Eats(x, Cat) -> IsNice(x))
TEXT: If the cat eats the mouse then the mouse likes the cow.
FOL: (Eats(Cat, Mouse) -> Likes(Mouse, Cow))
TEXT: If someone chases the mouse and they are round then they are big.
FOL: all x. ((Chases(x, Mouse) & IsRound(x)) -> IsBig(x))
TEXT: If someone chases the tiger and the tiger chases the cat then the tiger is round.
FOL: all x. ((Chases(x, Tiger) & Chases(Tiger, Cat)) -> IsRound(Tiger))
TEXT: If someone eats the tiger and they like the cat then the cat likes the cow.
FOL: all x. ((Eats(x, Tiger) & Likes(x, Cat)) -> Likes(Cat, Cow))
TEXT: If the mouse likes the cow and the mouse chases the cow then the cow eats the cat.
FOL: ((Likes(Mouse, Cow) & Chases(Mouse, Cow)) -> Eats(Cow, Cat))
TEXT: If someone eats the cow and they eat the cat then they chase the tiger.
FOL: all x. ((Eats(x, Cow) & Eats(x, Cat)) -> Chases(x, Tiger))
TEXT: If someone eats the tiger and they eat the cat then the tiger eats the cat.
FOL: all x. ((Eats(x, Tiger) & Eats(x, Cat)) -> Eats(Tiger, Cat))
TEXT: The cow is big.
FOL: IsBig(Cow)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 71 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle chases the tiger.
The bald eagle is green.
The bald eagle likes the mouse.
The bald eagle likes the tiger.
The dog needs the mouse.
The mouse is rough.
The tiger chases the bald eagle.
The tiger chases the mouse.
The tiger is round.
The tiger likes the bald eagle.
The tiger needs the bald eagle.
If someone needs the mouse and the mouse chases the dog then the dog likes the tiger.
If the dog likes the tiger and the tiger is green then the dog chases the mouse.
If someone needs the dog then the dog needs the tiger.
If someone is red then they chase the dog.
If someone likes the tiger then they are red.
If someone is rough then they like the tiger.
If someone chases the tiger then the tiger needs the bald eagle.
If someone needs the tiger and they like the bald eagle then the bald eagle needs the mouse.
</PREMISES>
<CONCLUSION>
The dog does not like the tiger.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle chases the tiger.
FOL: Chases(BaldEagle, Tiger)
TEXT: The bald eagle is green.
FOL: IsGreen(BaldEagle)
TEXT: The bald eagle likes the mouse.
FOL: Likes(BaldEagle, Mouse)
TEXT: The bald eagle likes the tiger.
FOL: Likes(BaldEagle, Tiger)
TEXT: The dog needs the mouse.
FOL: Needs(Dog, Mouse)
TEXT: The mouse is rough.
FOL: IsRough(Mouse)
TEXT: The tiger chases the bald eagle.
FOL: Chases(Tiger, BaldEagle)
TEXT: The tiger chases the mouse.
FOL: Chases(Tiger, Mouse)
TEXT: The tiger is round.
FOL: IsRound(Tiger)
TEXT: The tiger likes the bald eagle.
FOL: Likes(Tiger, BaldEagle)
TEXT: The tiger needs the bald eagle.
FOL: Needs(Tiger, BaldEagle)
TEXT: If someone needs the mouse and the mouse chases the dog then the dog likes the tiger.
FOL: all x. (Needs(x, Mouse) & Chases(Mouse, Dog) -> Likes(Dog, Tiger))
TEXT: If the dog likes the tiger and the tiger is green then the dog chases the mouse.
FOL: (Likes(Dog, Tiger) & IsGreen(Tiger) -> Chases(Dog, Mouse))
TEXT: If someone needs the dog then the dog needs the tiger.
FOL: all x. (Needs(x, Dog) -> Needs(Dog, Tiger))
TEXT: If someone is red then they chase the dog.
FOL: all x. (IsRed(x) -> Chases(x, Dog))
TEXT: If someone likes the tiger then they are red.
FOL: all x. (Likes(x, Tiger) -> IsRed(x))
TEXT: If someone is rough then they like the tiger.
FOL: all x. (IsRough(x) -> Likes(x, Tiger))
TEXT: If someone chases the tiger then the tiger needs the bald eagle.
FOL: all x. (Chases(x, Tiger) -> Needs(Tiger, BaldEagle))
TEXT: If someone needs the tiger and they like the bald eagle then the bald eagle needs the mouse.
FOL: all x. (Needs(x, Tiger) & Likes(x, BaldEagle) -> Needs(BaldEagle, Mouse))
TEXT: The dog does not like the tiger.
FOL: -Likes(Dog, Tiger)
</EVALUATE>
Processed: False

Generation 2:
TEXT: The bald eagle chases the tiger.
FOL: Chases(BaldEagle, Tiger)
TEXT: The bald eagle is green.
FOL: IsColor(BaldEagle, Green)
TEXT: The bald eagle likes the mouse.
FOL: Likes(BaldEagle, Mouse)
TEXT: The bald eagle likes the tiger.
FOL: Likes(BaldEagle, Tiger)
TEXT: The dog needs the mouse.
FOL: Needs(Dog, Mouse)
TEXT: The mouse is rough.
FOL: IsTrait(Mouse, Rough)
TEXT: The tiger chases the bald eagle.
FOL: Chases(Tiger, BaldEagle)
TEXT: The tiger chases the mouse.
FOL: Chases(Tiger, Mouse)
TEXT: The tiger is round.
FOL: IsTrait(Tiger, Round)
TEXT: The tiger likes the bald eagle.
FOL: Likes(Tiger, BaldEagle)
TEXT: The tiger needs the bald eagle.
FOL: Needs(Tiger, BaldEagle)
TEXT: If someone needs the mouse and the mouse chases the dog then the dog likes the tiger.
FOL: all x. (Needs(x, Mouse) & Chases(Mouse, Dog) -> Likes(Dog, Tiger))
TEXT: If the dog likes the tiger and the tiger is green then the dog chases the mouse.
FOL: (Likes(Dog, Tiger) & IsColor(Tiger, Green) -> Chases(Dog, Mouse))
TEXT: If someone needs the dog then the dog needs the tiger.
FOL: all x. (Needs(x, Dog) -> Needs(Dog, Tiger))
TEXT: If someone is red then they chase the dog.
FOL: all x. (IsColor(x, Red) -> Chases(x, Dog))
TEXT: If someone likes the tiger then they are red.
FOL: all x. (Likes(x, Tiger) -> IsColor(x, Red))
TEXT: If someone is rough then they like the tiger.
FOL: all x. (IsTrait(x, Rough) -> Likes(x, Tiger))
TEXT: If someone chases the tiger then the tiger needs the bald eagle.
FOL: all x. (Chases(x, Tiger) -> Needs(Tiger, BaldEagle))
TEXT: If someone needs the tiger and they like the bald eagle then the bald eagle needs the mouse.
FOL: all x. (Needs(x, Tiger) & Likes(x, BaldEagle) -> Needs(BaldEagle, Mouse))
TEXT: The dog does not like the tiger.
FOL: -Likes(Dog, Tiger)
</EVALUATE>
Processed: False

Generation 3:
TEXT: The bald eagle chases the tiger.
FOL: Chases(BaldEagle, Tiger)
TEXT: The bald eagle is green.
FOL: IsGreen(BaldEagle)
TEXT: The bald eagle likes the mouse.
FOL: Likes(BaldEagle, Mouse)
TEXT: The bald eagle likes the tiger.
FOL: Likes(BaldEagle, Tiger)
TEXT: The dog needs the mouse.
FOL: Needs(Dog, Mouse)
TEXT: The mouse is rough.
FOL: IsRough(Mouse)
TEXT: The tiger chases the bald eagle.
FOL: Chases(Tiger, BaldEagle)
TEXT: The tiger chases the mouse.
FOL: Chases(Tiger, Mouse)
TEXT: The tiger is round.
FOL: IsRound(Tiger)
TEXT: The tiger likes the bald eagle.
FOL: Likes(Tiger, BaldEagle)
TEXT: The tiger needs the bald eagle.
FOL: Needs(Tiger, BaldEagle)
TEXT: If someone needs the mouse and the mouse chases the dog then the dog likes the tiger.
FOL: all x. ((Needs(x, Mouse) & Chases(Mouse, Dog)) -> Likes(Dog, Tiger))
TEXT: If the dog likes the tiger and the tiger is green then the dog chases the mouse.
FOL: (Likes(Dog, Tiger) & IsGreen(Tiger)) -> Chases(Dog, Mouse)
TEXT: If someone needs the dog then the dog needs the tiger.
FOL: all x. (Needs(x, Dog) -> Needs(Dog, Tiger))
TEXT: If someone is red then they chase the dog.
FOL: all x. (IsRed(x) -> Chases(x, Dog))
TEXT: If someone likes the tiger then they are red.
FOL: all x. (Likes(x, Tiger) -> IsRed(x))
TEXT: If someone is rough then they like the tiger.
FOL: all x. (IsRough(x) -> Likes(x, Tiger))
TEXT: If someone chases the tiger then the tiger needs the bald eagle.
FOL: all x. (Chases(x, Tiger) -> Needs(Tiger, BaldEagle))
TEXT: If someone needs the tiger and they like the bald eagle then the bald eagle needs the mouse.
FOL: all x. ((Needs(x, Tiger) & Likes(x, BaldEagle)) -> Needs(BaldEagle, Mouse))
TEXT: The dog does not like the tiger.
FOL: -Likes(Dog, Tiger)
Processed: False

Reference: False
========================================

=== Example 72 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bear does not see the dog.
The dog eats the bear.
The dog is blue.
The lion is green.
The lion needs the rabbit.
The lion sees the dog.
The rabbit eats the lion.
The rabbit is rough.
The rabbit needs the dog.
The rabbit sees the dog.
If the lion eats the bear then the bear does not eat the dog.
If the bear does not see the dog then the bear is red.
If something eats the rabbit then the rabbit eats the bear.
If something eats the bear then the bear needs the lion.
If something needs the lion then the lion eats the bear.
If something is red and it eats the bear then the bear does not see the lion.
If something is red and it does not eat the dog then the dog sees the rabbit.
If something sees the rabbit then it is not big.
If something is rough and it does not see the rabbit then the rabbit eats the lion.
</PREMISES>
<CONCLUSION>
The bear needs the lion.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bear does not see the dog.
FOL: -Sees(Bear, Dog)
TEXT: The dog eats the bear.
FOL: Eats(Dog, Bear)
TEXT: The dog is blue.
FOL: Color(Dog, Blue)
TEXT: The lion is green.
FOL: Color(Lion, Green)
TEXT: The lion needs the rabbit.
FOL: Needs(Lion, Rabbit)
TEXT: The lion sees the dog.
FOL: Sees(Lion, Dog)
TEXT: The rabbit eats the lion.
FOL: Eats(Rabbit, Lion)
TEXT: The rabbit is rough.
FOL: Texture(Rabbit, Rough)
TEXT: The rabbit needs the dog.
FOL: Needs(Rabbit, Dog)
TEXT: The rabbit sees the dog.
FOL: Sees(Rabbit, Dog)
TEXT: If the lion eats the bear then the bear does not eat the dog.
FOL: Eats(Lion, Bear) -> -Eats(Bear, Dog)
TEXT: If the bear does not see the dog then the bear is red.
FOL: -Sees(Bear, Dog) -> Color(Bear, Red)
TEXT: If something eats the rabbit then the rabbit eats the bear.
FOL: exists x. (Eats(x, Rabbit) -> Eats(Rabbit, Bear))
TEXT: If something eats the bear then the bear needs the lion.
FOL: exists x. (Eats(x, Bear) -> Needs(Bear, Lion))
TEXT: If something needs the lion then the lion eats the bear.
FOL: exists x. (Needs(x, Lion) -> Eats(Lion, Bear))
TEXT: If something is red and it eats the bear then the bear does not see the lion.
FOL: exists x. (Color(x, Red) & Eats(x, Bear) -> -Sees(Bear, Lion))
TEXT: If something is red and it does not eat the dog then the dog sees the rabbit.
FOL: exists x. (Color(x, Red) & -Eats(x, Dog) -> Sees(Dog, Rabbit))
TEXT: If something sees the rabbit then it is not big.
FOL: exists x. (Sees(x, Rabbit) -> -Big(x))
TEXT: If something is rough and it does not see the rabbit then the rabbit eats the lion.
FOL: exists x. (Texture(x, Rough) & -Sees(x, Rabbit) -> Eats(Rabbit, Lion))
TEXT: The bear needs the lion.
FOL: Needs(Bear, Lion)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: The bear does not see the dog.
FOL: -Sees(Bear, Dog)

TEXT: The dog eats the bear.
FOL: Eats(Dog, Bear)

TEXT: The dog is blue.
FOL: Color(Dog, Blue)

TEXT: The lion is green.
FOL: Color(Lion, Green)

TEXT: The lion needs the rabbit.
FOL: Needs(Lion, Rabbit)

TEXT: The lion sees the dog.
FOL: Sees(Lion, Dog)

TEXT: The rabbit eats the lion.
FOL: Eats(Rabbit, Lion)

TEXT: The rabbit is rough.
FOL: Rough(Rabbit)

TEXT: The rabbit needs the dog.
FOL: Needs(Rabbit, Dog)

TEXT: The rabbit sees the dog.
FOL: Sees(Rabbit, Dog)

TEXT: If the lion eats the bear then the bear does not eat the dog.
FOL: (Eats(Lion, Bear) -> -Eats(Bear, Dog))

TEXT: If the bear does not see the dog then the bear is red.
FOL: (-Sees(Bear, Dog) -> Color(Bear, Red))

TEXT: If something eats the rabbit then the rabbit eats the bear.
FOL: all x. (Eats(x, Rabbit) -> Eats(Rabbit, Bear))

TEXT: If something eats the bear then the bear needs the lion.
FOL: all x. (Eats(x, Bear) -> Needs(Bear, Lion))

TEXT: If something needs the lion then the lion eats the bear.
FOL: all x. (Needs(x, Lion) -> Eats(Lion, Bear))

TEXT: If something is red and it eats the bear then the bear does not see the lion.
FOL: all x. ((Color(x, Red) & Eats(x, Bear)) -> -Sees(Bear, Lion))

TEXT: If something is red and it does not eat the dog then the dog sees the rabbit.
FOL: all x. ((Color(x, Red) & -Eats(x, Dog)) -> Sees(Dog, Rabbit))

TEXT: If something sees the rabbit then it is not big.
FOL: all x. (Sees(x, Rabbit) -> -Big(x))

TEXT: If something is rough and it does not see the rabbit then the rabbit eats the lion.
FOL: all x. ((Rough(x) & -Sees(x, Rabbit)) -> Eats(Rabbit, Lion))

TEXT: The bear needs the lion.
FOL: Needs(Bear, Lion)
Processed: True

Generation 3:
TEXT: The bear does not see the dog.
FOL: -Sees(Bear, Dog)

TEXT: The dog eats the bear.
FOL: Eats(Dog, Bear)

TEXT: The dog is blue.
FOL: Color(Dog, Blue)

TEXT: The lion is green.
FOL: Color(Lion, Green)

TEXT: The lion needs the rabbit.
FOL: Needs(Lion, Rabbit)

TEXT: The lion sees the dog.
FOL: Sees(Lion, Dog)

TEXT: The rabbit eats the lion.
FOL: Eats(Rabbit, Lion)

TEXT: The rabbit is rough.
FOL: Rough(Rabbit)

TEXT: The rabbit needs the dog.
FOL: Needs(Rabbit, Dog)

TEXT: The rabbit sees the dog.
FOL: Sees(Rabbit, Dog)

TEXT: If the lion eats the bear then the bear does not eat the dog.
FOL: (Eats(Lion, Bear) -> -Eats(Bear, Dog))

TEXT: If the bear does not see the dog then the bear is red.
FOL: (-Sees(Bear, Dog) -> Color(Bear, Red))

TEXT: If something eats the rabbit then the rabbit eats the bear.
FOL: all x. (Eats(x, Rabbit) -> Eats(Rabbit, Bear))

TEXT: If something eats the bear then the bear needs the lion.
FOL: all x. (Eats(x, Bear) -> Needs(Bear, Lion))

TEXT: If something needs the lion then the lion eats the bear.
FOL: all x. (Needs(x, Lion) -> Eats(Lion, Bear))

TEXT: If something is red and it eats the bear then the bear does not see the lion.
FOL: all x. ((Color(x, Red) & Eats(x, Bear)) -> -Sees(Bear, Lion))

TEXT: If something is red and it does not eat the dog then the dog sees the rabbit.
FOL: all x. ((Color(x, Red) & -Eats(x, Dog)) -> Sees(Dog, Rabbit))

TEXT: If something sees the rabbit then it is not big.
FOL: all x. (Sees(x, Rabbit) -> -Big(x))

TEXT: If something is rough and it does not see the rabbit then the rabbit eats the lion.
FOL: all x. ((Rough(x) & -Sees(x, Rabbit)) -> Eats(Rabbit, Lion))

TEXT: The bear needs the lion.
FOL: Needs(Bear, Lion)
Processed: True

Reference: True
========================================

=== Example 73 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The cat eats the tiger.
The cat likes the tiger.
The lion likes the cat.
The rabbit is red.
The rabbit is not young.
The rabbit likes the lion.
The tiger likes the cat.
If someone is cold and they like the tiger then the tiger does not like the lion.
If someone chases the tiger then the tiger likes the lion.
If the tiger is cold then the tiger chases the rabbit.
If the lion chases the cat then the cat chases the tiger.
If someone eats the tiger then the tiger is cold.
If someone is young then they chase the tiger.
If someone chases the tiger then the tiger does not like the rabbit.
If the tiger likes the cat and the tiger chases the rabbit then the tiger is young.
If the lion is rough and the lion is not red then the lion does not like the rabbit.
</PREMISES>
<CONCLUSION>
The tiger does not chase the tiger.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The cat eats the tiger.
FOL: Eats(Cat, Tiger)
TEXT: The cat likes the tiger.
FOL: Likes(Cat, Tiger)
TEXT: The lion likes the cat.
FOL: Likes(Lion, Cat)
TEXT: The rabbit is red.
FOL: Red(Rabbit)
TEXT: The rabbit is not young.
FOL: -Young(Rabbit)
TEXT: The rabbit likes the lion.
FOL: Likes(Rabbit, Lion)
TEXT: The tiger likes the cat.
FOL: Likes(Tiger, Cat)
TEXT: If someone is cold and they like the tiger then the tiger does not like the lion.
FOL: all x. (Cold(x) & Likes(x, Tiger) -> -Likes(Tiger, Lion))
TEXT: If someone chases the tiger then the tiger likes the lion.
FOL: all x. (Chases(x, Tiger) -> Likes(Tiger, Lion))
TEXT: If the tiger is cold then the tiger chases the rabbit.
FOL: Cold(Tiger) -> Chases(Tiger, Rabbit)
TEXT: If the lion chases the cat then the cat chases the tiger.
FOL: Chases(Lion, Cat) -> Chases(Cat, Tiger)
TEXT: If someone eats the tiger then the tiger is cold.
FOL: all x. (Eats(x, Tiger) -> Cold(Tiger))
TEXT: If someone is young then they chase the tiger.
FOL: all x. (Young(x) -> Chases(x, Tiger))
TEXT: If someone chases the tiger then the tiger does not like the rabbit.
FOL: all x. (Chases(x, Tiger) -> -Likes(Tiger, Rabbit))
TEXT: If the tiger likes the cat and the tiger chases the rabbit then the tiger is young.
FOL: (Likes(Tiger, Cat) & Chases(Tiger, Rabbit)) -> Young(Tiger)
TEXT: If the lion is rough and the lion is not red then the lion does not like the rabbit.
FOL: (Rough(Lion) & -Red(Lion)) -> -Likes(Lion, Rabbit)
TEXT: The tiger does not chase the tiger.
FOL: -Chases(Tiger, Tiger)
Processed: False

Generation 2:
TEXT: The cat eats the tiger.
FOL: Eats(Cat, Tiger)

TEXT: The cat likes the tiger.
FOL: Likes(Cat, Tiger)

TEXT: The lion likes the cat.
FOL: Likes(Lion, Cat)

TEXT: The rabbit is red.
FOL: IsRed(Rabbit)

TEXT: The rabbit is not young.
FOL: -IsYoung(Rabbit)

TEXT: The rabbit likes the lion.
FOL: Likes(Rabbit, Lion)

TEXT: The tiger likes the cat.
FOL: Likes(Tiger, Cat)

TEXT: If someone is cold and they like the tiger then the tiger does not like the lion.
FOL: all x. (IsCold(x) & Likes(x, Tiger) -> -Likes(Tiger, Lion))

TEXT: If someone chases the tiger then the tiger likes the lion.
FOL: all x. (Chases(x, Tiger) -> Likes(Tiger, Lion))

TEXT: If the tiger is cold then the tiger chases the rabbit.
FOL: IsCold(Tiger) -> Chases(Tiger, Rabbit)

TEXT: If the lion chases the cat then the cat chases the tiger.
FOL: Chases(Lion, Cat) -> Chases(Cat, Tiger)

TEXT: If someone eats the tiger then the tiger is cold.
FOL: all x. (Eats(x, Tiger) -> IsCold(Tiger))

TEXT: If someone is young then they chase the tiger.
FOL: all x. (IsYoung(x) -> Chases(x, Tiger))

TEXT: If someone chases the tiger then the tiger does not like the rabbit.
FOL: all x. (Chases(x, Tiger) -> -Likes(Tiger, Rabbit))

TEXT: If the tiger likes the cat and the tiger chases the rabbit then the tiger is young.
FOL: (Likes(Tiger, Cat) & Chases(Tiger, Rabbit)) -> IsYoung(Tiger)

TEXT: If the lion is rough and the lion is not red then the lion does not like the rabbit.
FOL: (IsRough(Lion) & -IsRed(Lion)) -> -Likes(Lion, Rabbit)

TEXT: The tiger does not chase the tiger.
FOL: -Chases(Tiger, Tiger)
Processed: False

Generation 3:
TEXT: The cat eats the tiger.
FOL: Eats(Cat, Tiger)
TEXT: The cat likes the tiger.
FOL: Likes(Cat, Tiger)
TEXT: The lion likes the cat.
FOL: Likes(Lion, Cat)
TEXT: The rabbit is red.
FOL: Red(Rabbit)
TEXT: The rabbit is not young.
FOL: -Young(Rabbit)
TEXT: The rabbit likes the lion.
FOL: Likes(Rabbit, Lion)
TEXT: The tiger likes the cat.
FOL: Likes(Tiger, Cat)
TEXT: If someone is cold and they like the tiger then the tiger does not like the lion.
FOL: all x. (Cold(x) & Likes(x, Tiger) -> -Likes(Tiger, Lion))
TEXT: If someone chases the tiger then the tiger likes the lion.
FOL: all x. (Chases(x, Tiger) -> Likes(Tiger, Lion))
TEXT: If the tiger is cold then the tiger chases the rabbit.
FOL: Cold(Tiger) -> Chases(Tiger, Rabbit)
TEXT: If the lion chases the cat then the cat chases the tiger.
FOL: Chases(Lion, Cat) -> Chases(Cat, Tiger)
TEXT: If someone eats the tiger then the tiger is cold.
FOL: all x. (Eats(x, Tiger) -> Cold(Tiger))
TEXT: If someone is young then they chase the tiger.
FOL: all x. (Young(x) -> Chases(x, Tiger))
TEXT: If someone chases the tiger then the tiger does not like the rabbit.
FOL: all x. (Chases(x, Tiger) -> -Likes(Tiger, Rabbit))
TEXT: If the tiger likes the cat and the tiger chases the rabbit then the tiger is young.
FOL: (Likes(Tiger, Cat) & Chases(Tiger, Rabbit)) -> Young(Tiger)
TEXT: If the lion is rough and the lion is not red then the lion does not like the rabbit.
FOL: (Rough(Lion) & -Red(Lion)) -> -Likes(Lion, Rabbit)
TEXT: The tiger does not chase the tiger.
FOL: -Chases(Tiger, Tiger)
Processed: False

Reference: False
========================================

=== Example 74 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is furry.
Bob is quiet.
Erin is blue.
Erin is furry.
Erin is round.
Gary is kind.
Gary is quiet.
Gary is rough.
Gary is round.
Harry is blue.
Harry is not furry.
Harry is kind.
If Erin is rough then Erin is furry.
If someone is round and blue then they are rough.
Quiet, furry people are round.
If Bob is quiet and Bob is round then Bob is kind.
If someone is kind then they are cold.
All furry, cold people are blue.
</PREMISES>
<CONCLUSION>
Bob is not blue.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is furry.
FOL: Furry(Bob)
TEXT: Bob is quiet.
FOL: Quiet(Bob)
TEXT: Erin is blue.
FOL: Blue(Erin)
TEXT: Erin is furry.
FOL: Furry(Erin)
TEXT: Erin is round.
FOL: Round(Erin)
TEXT: Gary is kind.
FOL: Kind(Gary)
TEXT: Gary is quiet.
FOL: Quiet(Gary)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: Gary is round.
FOL: Round(Gary)
TEXT: Harry is blue.
FOL: Blue(Harry)
TEXT: Harry is not furry.
FOL: -Furry(Harry)
TEXT: Harry is kind.
FOL: Kind(Harry)
TEXT: If Erin is rough then Erin is furry.
FOL: (Rough(Erin) -> Furry(Erin))
TEXT: If someone is round and blue then they are rough.
FOL: all x. (Round(x) & Blue(x) -> Rough(x))
TEXT: Quiet, furry people are round.
FOL: all x. (Quiet(x) & Furry(x) -> Round(x))
TEXT: If Bob is quiet and Bob is round then Bob is kind.
FOL: (Quiet(Bob) & Round(Bob) -> Kind(Bob))
TEXT: If someone is kind then they are cold.
FOL: all x. (Kind(x) -> Cold(x))
TEXT: All furry, cold people are blue.
FOL: all x. (Furry(x) & Cold(x) -> Blue(x))
TEXT: Bob is not blue.
FOL: -Blue(Bob)
</EVALUATE>
Processed: False

Generation 2:
TEXT: Bob is furry.
FOL: Furry(Bob)

TEXT: Bob is quiet.
FOL: Quiet(Bob)

TEXT: Erin is blue.
FOL: Blue(Erin)

TEXT: Erin is furry.
FOL: Furry(Erin)

TEXT: Erin is round.
FOL: Round(Erin)

TEXT: Gary is kind.
FOL: Kind(Gary)

TEXT: Gary is quiet.
FOL: Quiet(Gary)

TEXT: Gary is rough.
FOL: Rough(Gary)

TEXT: Gary is round.
FOL: Round(Gary)

TEXT: Harry is blue.
FOL: Blue(Harry)

TEXT: Harry is not furry.
FOL: -Furry(Harry)

TEXT: Harry is kind.
FOL: Kind(Harry)

TEXT: If Erin is rough then Erin is furry.
FOL: (Rough(Erin) -> Furry(Erin))

TEXT: If someone is round and blue then they are rough.
FOL: all x. (Round(x) & Blue(x) -> Rough(x))

TEXT: Quiet, furry people are round.
FOL: all x. (Quiet(x) & Furry(x) -> Round(x))

TEXT: If Bob is quiet and Bob is round then Bob is kind.
FOL: (Quiet(Bob) & Round(Bob) -> Kind(Bob))

TEXT: If someone is kind then they are cold.
FOL: all x. (Kind(x) -> Cold(x))

TEXT: All furry, cold people are blue.
FOL: all x. (Furry(x) & Cold(x) -> Blue(x))

TEXT: Bob is not blue.
FOL: -Blue(Bob)
Processed: False

Generation 3:
TEXT: Bob is furry.
FOL: Furry(Bob)
TEXT: Bob is quiet.
FOL: Quiet(Bob)
TEXT: Erin is blue.
FOL: Blue(Erin)
TEXT: Erin is furry.
FOL: Furry(Erin)
TEXT: Erin is round.
FOL: Round(Erin)
TEXT: Gary is kind.
FOL: Kind(Gary)
TEXT: Gary is quiet.
FOL: Quiet(Gary)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: Gary is round.
FOL: Round(Gary)
TEXT: Harry is blue.
FOL: Blue(Harry)
TEXT: Harry is not furry.
FOL: -Furry(Harry)
TEXT: Harry is kind.
FOL: Kind(Harry)
TEXT: If Erin is rough then Erin is furry.
FOL: Rough(Erin) -> Furry(Erin)
TEXT: If someone is round and blue then they are rough.
FOL: all x. (Round(x) & Blue(x) -> Rough(x))
TEXT: Quiet, furry people are round.
FOL: all x. (Quiet(x) & Furry(x) -> Round(x))
TEXT: If Bob is quiet and Bob is round then Bob is kind.
FOL: (Quiet(Bob) & Round(Bob)) -> Kind(Bob)
TEXT: If someone is kind then they are cold.
FOL: all x. (Kind(x) -> Cold(x))
TEXT: All furry, cold people are blue.
FOL: all x. (Furry(x) & Cold(x) -> Blue(x))
TEXT: Bob is not blue.
FOL: -Blue(Bob)
Processed: False

Reference: False
========================================

=== Example 75 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The lion needs the rabbit.
The mouse is rough.
The mouse is young.
The mouse visits the lion.
The rabbit needs the mouse.
The rabbit needs the squirrel.
The squirrel is not blue.
If something is young then it needs the lion.
If something is round then it needs the lion.
If something needs the lion then it needs the rabbit.
If something is rough and it visits the mouse then the mouse is red.
If the rabbit visits the squirrel and the squirrel chases the lion then the squirrel needs the rabbit.
If something is red then it is not blue.
If something is young and it does not need the mouse then it visits the rabbit.
If something needs the rabbit then it visits the mouse.
If the lion visits the mouse and the lion is blue then the mouse chases the squirrel.
</PREMISES>
<CONCLUSION>
The rabbit does not chase the squirrel.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The lion needs the rabbit.
FOL: Needs(Lion, Rabbit)

TEXT: The mouse is rough.
FOL: Rough(Mouse)

TEXT: The mouse is young.
FOL: Young(Mouse)

TEXT: The mouse visits the lion.
FOL: Visits(Mouse, Lion)

TEXT: The rabbit needs the mouse.
FOL: Needs(Rabbit, Mouse)

TEXT: The rabbit needs the squirrel.
FOL: Needs(Rabbit, Squirrel)

TEXT: The squirrel is not blue.
FOL: -Blue(Squirrel)

TEXT: If something is young then it needs the lion.
FOL: all x. (Young(x) -> Needs(x, Lion))

TEXT: If something is round then it needs the lion.
FOL: all x. (Round(x) -> Needs(x, Lion))

TEXT: If something needs the lion then it needs the rabbit.
FOL: all x. (Needs(x, Lion) -> Needs(x, Rabbit))

TEXT: If something is rough and it visits the mouse then the mouse is red.
FOL: all x. (Rough(x) & Visits(x, Mouse) -> Red(Mouse))

TEXT: If the rabbit visits the squirrel and the squirrel chases the lion then the squirrel needs the rabbit.
FOL: (Visits(Rabbit, Squirrel) & Chases(Squirrel, Lion)) -> Needs(Squirrel, Rabbit)

TEXT: If something is red then it is not blue.
FOL: all x. (Red(x) -> -Blue(x))

TEXT: If something is young and it does not need the mouse then it visits the rabbit.
FOL: all x. (Young(x) & -Needs(x, Mouse) -> Visits(x, Rabbit))

TEXT: If something needs the rabbit then it visits the mouse.
FOL: all x. (Needs(x, Rabbit) -> Visits(x, Mouse))

TEXT: If the lion visits the mouse and the lion is blue then the mouse chases the squirrel.
FOL: (Visits(Lion, Mouse) & Blue(Lion)) -> Chases(Mouse, Squirrel)

TEXT: The rabbit does not chase the squirrel.
FOL: -Chases(Rabbit, Squirrel)
Processed: Uncertain

Generation 2:
TEXT: The lion needs the rabbit.
FOL: Needs(TheLion, TheRabbit)

TEXT: The mouse is rough.
FOL: Rough(TheMouse)

TEXT: The mouse is young.
FOL: Young(TheMouse)

TEXT: The mouse visits the lion.
FOL: Visits(TheMouse, TheLion)

TEXT: The rabbit needs the mouse.
FOL: Needs(TheRabbit, TheMouse)

TEXT: The rabbit needs the squirrel.
FOL: Needs(TheRabbit, TheSquirrel)

TEXT: The squirrel is not blue.
FOL: -Blue(TheSquirrel)

TEXT: If something is young then it needs the lion.
FOL: all x. (Young(x) -> Needs(x, TheLion))

TEXT: If something is round then it needs the lion.
FOL: all x. (Round(x) -> Needs(x, TheLion))

TEXT: If something needs the lion then it needs the rabbit.
FOL: all x. (Needs(x, TheLion) -> Needs(x, TheRabbit))

TEXT: If something is rough and it visits the mouse then the mouse is red.
FOL: all x. (Rough(x) & Visits(x, TheMouse) -> Red(TheMouse))

TEXT: If the rabbit visits the squirrel and the squirrel chases the lion then the squirrel needs the rabbit.
FOL: (Visits(TheRabbit, TheSquirrel) & Chases(TheSquirrel, TheLion)) -> Needs(TheSquirrel, TheRabbit)

TEXT: If something is red then it is not blue.
FOL: all x. (Red(x) -> -Blue(x))

TEXT: If something is young and it does not need the mouse then it visits the rabbit.
FOL: all x. (Young(x) & -Needs(x, TheMouse) -> Visits(x, TheRabbit))

TEXT: If something needs the rabbit then it visits the mouse.
FOL: all x. (Needs(x, TheRabbit) -> Visits(x, TheMouse))

TEXT: If the lion visits the mouse and the lion is blue then the mouse chases the squirrel.
FOL: (Visits(TheLion, TheMouse) & Blue(TheLion)) -> Chases(TheMouse, TheSquirrel)

TEXT: The rabbit does not chase the squirrel.
FOL: -Chases(TheRabbit, TheSquirrel)
Processed: Uncertain

Generation 3:
TEXT: The lion needs the rabbit.
FOL: Needs(lion, rabbit)
TEXT: The mouse is rough.
FOL: Rough(mouse)
TEXT: The mouse is young.
FOL: Young(mouse)
TEXT: The mouse visits the lion.
FOL: Visits(mouse, lion)
TEXT: The rabbit needs the mouse.
FOL: Needs(rabbit, mouse)
TEXT: The rabbit needs the squirrel.
FOL: Needs(rabbit, squirrel)
TEXT: The squirrel is not blue.
FOL: -Blue(squirrel)
TEXT: If something is young then it needs the lion.
FOL: all x. (Young(x) -> Needs(x, lion))
TEXT: If something is round then it needs the lion.
FOL: all x. (Round(x) -> Needs(x, lion))
TEXT: If something needs the lion then it needs the rabbit.
FOL: all x. (Needs(x, lion) -> Needs(x, rabbit))
TEXT: If something is rough and it visits the mouse then the mouse is red.
FOL: all x. (Rough(x) & Visits(x, mouse) -> Red(mouse))
TEXT: If the rabbit visits the squirrel and the squirrel chases the lion then the squirrel needs the rabbit.
FOL: (Visits(rabbit, squirrel) & Chases(squirrel, lion) -> Needs(squirrel, rabbit))
TEXT: If something is red then it is not blue.
FOL: all x. (Red(x) -> -Blue(x))
TEXT: If something is young and it does not need the mouse then it visits the rabbit.
FOL: all x. (Young(x) & -Needs(x, mouse) -> Visits(x, rabbit))
TEXT: If something needs the rabbit then it visits the mouse.
FOL: all x. (Needs(x, rabbit) -> Visits(x, mouse))
TEXT: If the lion visits the mouse and the lion is blue then the mouse chases the squirrel.
FOL: (Visits(lion, mouse) & Blue(lion) -> Chases(mouse, squirrel))
TEXT: The rabbit does not chase the squirrel.
FOL: -Chases(rabbit, squirrel)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 76 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is rough.
Bob is white.
Bob is young.
Dave is big.
Dave is furry.
Dave is kind.
Dave is quiet.
Dave is rough.
Dave is white.
Dave is young.
Erin is big.
Erin is quiet.
Erin is rough.
Erin is white.
Fiona is furry.
Fiona is kind.
If someone is kind and rough then they are young.
If someone is furry and kind then they are big.
White people are kind.
Young, kind people are big.
Quiet people are big.
Furry, white people are big.
Kind, big people are white.
All young, kind people are quiet.
All white, furry people are rough.
</PREMISES>
<CONCLUSION>
Fiona is not rough.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is rough.
FOL: Rough(Bob)
TEXT: Bob is white.
FOL: White(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Dave is big.
FOL: Big(Dave)
TEXT: Dave is furry.
FOL: Furry(Dave)
TEXT: Dave is kind.
FOL: Kind(Dave)
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Dave is rough.
FOL: Rough(Dave)
TEXT: Dave is white.
FOL: White(Dave)
TEXT: Dave is young.
FOL: Young(Dave)
TEXT: Erin is big.
FOL: Big(Erin)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Erin is rough.
FOL: Rough(Erin)
TEXT: Erin is white.
FOL: White(Erin)
TEXT: Fiona is furry.
FOL: Furry(Fiona)
TEXT: Fiona is kind.
FOL: Kind(Fiona)
TEXT: If someone is kind and rough then they are young.
FOL: all x. ((Kind(x) & Rough(x)) -> Young(x))
TEXT: If someone is furry and kind then they are big.
FOL: all x. ((Furry(x) & Kind(x)) -> Big(x))
TEXT: White people are kind.
FOL: all x. (White(x) -> Kind(x))
TEXT: Young, kind people are big.
FOL: all x. ((Young(x) & Kind(x)) -> Big(x))
TEXT: Quiet people are big.
FOL: all x. (Quiet(x) -> Big(x))
TEXT: Furry, white people are big.
FOL: all x. ((Furry(x) & White(x)) -> Big(x))
TEXT: Kind, big people are white.
FOL: all x. ((Kind(x) & Big(x)) -> White(x))
TEXT: All young, kind people are quiet.
FOL: all x. ((Young(x) & Kind(x)) -> Quiet(x))
TEXT: All white, furry people are rough.
FOL: all x. ((White(x) & Furry(x)) -> Rough(x))
TEXT: Fiona is not rough.
FOL: -Rough(Fiona)
Processed: False

Generation 2:
TEXT: Bob is rough.
FOL: Rough(Bob)
TEXT: Bob is white.
FOL: White(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Dave is big.
FOL: Big(Dave)
TEXT: Dave is furry.
FOL: Furry(Dave)
TEXT: Dave is kind.
FOL: Kind(Dave)
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Dave is rough.
FOL: Rough(Dave)
TEXT: Dave is white.
FOL: White(Dave)
TEXT: Dave is young.
FOL: Young(Dave)
TEXT: Erin is big.
FOL: Big(Erin)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Erin is rough.
FOL: Rough(Erin)
TEXT: Erin is white.
FOL: White(Erin)
TEXT: Fiona is furry.
FOL: Furry(Fiona)
TEXT: Fiona is kind.
FOL: Kind(Fiona)
TEXT: If someone is kind and rough then they are young.
FOL: all x. ((Kind(x) & Rough(x)) -> Young(x))
TEXT: If someone is furry and kind then they are big.
FOL: all x. ((Furry(x) & Kind(x)) -> Big(x))
TEXT: White people are kind.
FOL: all x. (White(x) -> Kind(x))
TEXT: Young, kind people are big.
FOL: all x. ((Young(x) & Kind(x)) -> Big(x))
TEXT: Quiet people are big.
FOL: all x. (Quiet(x) -> Big(x))
TEXT: Furry, white people are big.
FOL: all x. ((Furry(x) & White(x)) -> Big(x))
TEXT: Kind, big people are white.
FOL: all x. ((Kind(x) & Big(x)) -> White(x))
TEXT: All young, kind people are quiet.
FOL: all x. ((Young(x) & Kind(x)) -> Quiet(x))
TEXT: All white, furry people are rough.
FOL: all x. ((White(x) & Furry(x)) -> Rough(x))
TEXT: Fiona is not rough.
FOL: -Rough(Fiona)
</EVALUATE>
Processed: False

Generation 3:
TEXT: Bob is rough.
FOL: Rough(Bob)

TEXT: Bob is white.
FOL: White(Bob)

TEXT: Bob is young.
FOL: Young(Bob)

TEXT: Dave is big.
FOL: Big(Dave)

TEXT: Dave is furry.
FOL: Furry(Dave)

TEXT: Dave is kind.
FOL: Kind(Dave)

TEXT: Dave is quiet.
FOL: Quiet(Dave)

TEXT: Dave is rough.
FOL: Rough(Dave)

TEXT: Dave is white.
FOL: White(Dave)

TEXT: Dave is young.
FOL: Young(Dave)

TEXT: Erin is big.
FOL: Big(Erin)

TEXT: Erin is quiet.
FOL: Quiet(Erin)

TEXT: Erin is rough.
FOL: Rough(Erin)

TEXT: Erin is white.
FOL: White(Erin)

TEXT: Fiona is furry.
FOL: Furry(Fiona)

TEXT: Fiona is kind.
FOL: Kind(Fiona)

TEXT: If someone is kind and rough then they are young.
FOL: all x. (Kind(x) & Rough(x) -> Young(x))

TEXT: If someone is furry and kind then they are big.
FOL: all x. (Furry(x) & Kind(x) -> Big(x))

TEXT: White people are kind.
FOL: all x. (White(x) -> Kind(x))

TEXT: Young, kind people are big.
FOL: all x. (Young(x) & Kind(x) -> Big(x))

TEXT: Quiet people are big.
FOL: all x. (Quiet(x) -> Big(x))

TEXT: Furry, white people are big.
FOL: all x. (Furry(x) & White(x) -> Big(x))

TEXT: Kind, big people are white.
FOL: all x. (Kind(x) & Big(x) -> White(x))

TEXT: All young, kind people are quiet.
FOL: all x. (Young(x) & Kind(x) -> Quiet(x))

TEXT: All white, furry people are rough.
FOL: all x. (White(x) & Furry(x) -> Rough(x))

TEXT: Fiona is not rough.
FOL: -Rough(Fiona)
Processed: False

Reference: False
========================================

=== Example 77 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle sees the dog.
The cow is round.
The cow sees the bald eagle.
The dog eats the cow.
The dog eats the squirrel.
The dog is kind.
The dog is round.
The dog likes the cow.
The dog sees the squirrel.
The squirrel eats the bald eagle.
The squirrel is red.
The squirrel likes the cow.
The squirrel likes the dog.
The squirrel sees the cow.
If the dog likes the squirrel and the dog sees the squirrel then the dog is round.
If something is rough then it eats the squirrel.
If something sees the cow and it is blue then the cow sees the dog.
If something likes the bald eagle then it eats the dog.
If something eats the dog then it is blue.
If something eats the bald eagle then it eats the dog.
If the dog likes the bald eagle then the bald eagle likes the squirrel.
If something eats the bald eagle then it eats the dog.
If something sees the dog then it eats the bald eagle.
</PREMISES>
<CONCLUSION>
The cow eats the squirrel.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle sees the dog.
FOL: Sees(BaldEagle, Dog)

TEXT: The cow is round.
FOL: Round(Cow)

TEXT: The cow sees the bald eagle.
FOL: Sees(Cow, BaldEagle)

TEXT: The dog eats the cow.
FOL: Eats(Dog, Cow)

TEXT: The dog eats the squirrel.
FOL: Eats(Dog, Squirrel)

TEXT: The dog is kind.
FOL: Kind(Dog)

TEXT: The dog is round.
FOL: Round(Dog)

TEXT: The dog likes the cow.
FOL: Likes(Dog, Cow)

TEXT: The dog sees the squirrel.
FOL: Sees(Dog, Squirrel)

TEXT: The squirrel eats the bald eagle.
FOL: Eats(Squirrel, BaldEagle)

TEXT: The squirrel is red.
FOL: Red(Squirrel)

TEXT: The squirrel likes the cow.
FOL: Likes(Squirrel, Cow)

TEXT: The squirrel likes the dog.
FOL: Likes(Squirrel, Dog)

TEXT: The squirrel sees the cow.
FOL: Sees(Squirrel, Cow)

TEXT: If the dog likes the squirrel and the dog sees the squirrel then the dog is round.
FOL: (Likes(Dog, Squirrel) & Sees(Dog, Squirrel)) -> Round(Dog)

TEXT: If something is rough then it eats the squirrel.
FOL: all x. (Rough(x) -> Eats(x, Squirrel))

TEXT: If something sees the cow and it is blue then the cow sees the dog.
FOL: all x. ((Sees(x, Cow) & Blue(x)) -> Sees(Cow, Dog))

TEXT: If something likes the bald eagle then it eats the dog.
FOL: all x. (Likes(x, BaldEagle) -> Eats(x, Dog))

TEXT: If something eats the dog then it is blue.
FOL: all x. (Eats(x, Dog) -> Blue(x))

TEXT: If something eats the bald eagle then it eats the dog.
FOL: all x. (Eats(x, BaldEagle) -> Eats(x, Dog))

TEXT: If the dog likes the bald eagle then the bald eagle likes the squirrel.
FOL: Likes(Dog, BaldEagle) -> Likes(BaldEagle, Squirrel)

TEXT: If something eats the bald eagle then it eats the dog.
FOL: all x. (Eats(x, BaldEagle) -> Eats(x, Dog))

TEXT: If something sees the dog then it eats the bald eagle.
FOL: all x. (Sees(x, Dog) -> Eats(x, BaldEagle))

TEXT: The cow eats the squirrel.
FOL: Eats(Cow, Squirrel)
Processed: Uncertain

Generation 2:
TEXT: The bald eagle sees the dog.
FOL: Sees(BaldEagle, Dog)

TEXT: The cow is round.
FOL: Round(Cow)

TEXT: The cow sees the bald eagle.
FOL: Sees(Cow, BaldEagle)

TEXT: The dog eats the cow.
FOL: Eats(Dog, Cow)

TEXT: The dog eats the squirrel.
FOL: Eats(Dog, Squirrel)

TEXT: The dog is kind.
FOL: Kind(Dog)

TEXT: The dog is round.
FOL: Round(Dog)

TEXT: The dog likes the cow.
FOL: Likes(Dog, Cow)

TEXT: The dog sees the squirrel.
FOL: Sees(Dog, Squirrel)

TEXT: The squirrel eats the bald eagle.
FOL: Eats(Squirrel, BaldEagle)

TEXT: The squirrel is red.
FOL: Red(Squirrel)

TEXT: The squirrel likes the cow.
FOL: Likes(Squirrel, Cow)

TEXT: The squirrel likes the dog.
FOL: Likes(Squirrel, Dog)

TEXT: The squirrel sees the cow.
FOL: Sees(Squirrel, Cow)

TEXT: If the dog likes the squirrel and the dog sees the squirrel then the dog is round.
FOL: (Likes(Dog, Squirrel) & Sees(Dog, Squirrel)) -> Round(Dog)

TEXT: If something is rough then it eats the squirrel.
FOL: all x. (Rough(x) -> Eats(x, Squirrel))

TEXT: If something sees the cow and it is blue then the cow sees the dog.
FOL: all x. ((Sees(x, Cow) & Blue(x)) -> Sees(Cow, Dog))

TEXT: If something likes the bald eagle then it eats the dog.
FOL: all x. (Likes(x, BaldEagle) -> Eats(x, Dog))

TEXT: If something eats the dog then it is blue.
FOL: all x. (Eats(x, Dog) -> Blue(x))

TEXT: If something eats the bald eagle then it eats the dog.
FOL: all x. (Eats(x, BaldEagle) -> Eats(x, Dog))

TEXT: If the dog likes the bald eagle then the bald eagle likes the squirrel.
FOL: (Likes(Dog, BaldEagle) -> Likes(BaldEagle, Squirrel))

TEXT: If something sees the dog then it eats the bald eagle.
FOL: all x. (Sees(x, Dog) -> Eats(x, BaldEagle))

TEXT: The cow eats the squirrel.
FOL: Eats(Cow, Squirrel)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: The bald eagle sees the dog.
FOL: Sees(BaldEagle, Dog)
TEXT: The cow is round.
FOL: Round(Cow)
TEXT: The cow sees the bald eagle.
FOL: Sees(Cow, BaldEagle)
TEXT: The dog eats the cow.
FOL: Eats(Dog, Cow)
TEXT: The dog eats the squirrel.
FOL: Eats(Dog, Squirrel)
TEXT: The dog is kind.
FOL: Kind(Dog)
TEXT: The dog is round.
FOL: Round(Dog)
TEXT: The dog likes the cow.
FOL: Likes(Dog, Cow)
TEXT: The dog sees the squirrel.
FOL: Sees(Dog, Squirrel)
TEXT: The squirrel eats the bald eagle.
FOL: Eats(Squirrel, BaldEagle)
TEXT: The squirrel is red.
FOL: Red(Squirrel)
TEXT: The squirrel likes the cow.
FOL: Likes(Squirrel, Cow)
TEXT: The squirrel likes the dog.
FOL: Likes(Squirrel, Dog)
TEXT: The squirrel sees the cow.
FOL: Sees(Squirrel, Cow)
TEXT: If the dog likes the squirrel and the dog sees the squirrel then the dog is round.
FOL: (Likes(Dog, Squirrel) & Sees(Dog, Squirrel)) -> Round(Dog)
TEXT: If something is rough then it eats the squirrel.
FOL: all x. (Rough(x) -> Eats(x, Squirrel))
TEXT: If something sees the cow and it is blue then the cow sees the dog.
FOL: all x. ((Sees(x, Cow) & Blue(x)) -> Sees(Cow, Dog))
TEXT: If something likes the bald eagle then it eats the dog.
FOL: all x. (Likes(x, BaldEagle) -> Eats(x, Dog))
TEXT: If something eats the dog then it is blue.
FOL: all x. (Eats(x, Dog) -> Blue(x))
TEXT: If something eats the bald eagle then it eats the dog.
FOL: all x. (Eats(x, BaldEagle) -> Eats(x, Dog))
TEXT: If the dog likes the bald eagle then the bald eagle likes the squirrel.
FOL: (Likes(Dog, BaldEagle) -> Likes(BaldEagle, Squirrel))
TEXT: If something eats the bald eagle then it eats the dog.
FOL: all x. (Eats(x, BaldEagle) -> Eats(x, Dog))
TEXT: If something sees the dog then it eats the bald eagle.
FOL: all x. (Sees(x, Dog) -> Eats(x, BaldEagle))
TEXT: The cow eats the squirrel.
FOL: Eats(Cow, Squirrel)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 78 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The dog does not eat the mouse.
The dog does not eat the tiger.
The dog is round.
The dog likes the lion.
The dog likes the mouse.
The lion eats the tiger.
The mouse is not cold.
The mouse is round.
The mouse needs the dog.
The tiger is blue.
The tiger is rough.
The tiger does not need the lion.
If someone likes the mouse and they are blue then the mouse eats the dog.
If someone likes the mouse and the mouse is blue then the mouse is rough.
If someone is cold then they need the tiger.
If someone eats the lion then they need the tiger.
If someone likes the dog then they are rough.
If someone is blue and they eat the lion then the lion is rough.
If someone is rough then they eat the lion.
If someone needs the tiger then they do not like the lion.
</PREMISES>
<CONCLUSION>
The mouse eats the lion.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The dog does not eat the mouse.
FOL: -Eats(Dog, Mouse)
TEXT: The dog does not eat the tiger.
FOL: -Eats(Dog, Tiger)
TEXT: The dog is round.
FOL: Round(Dog)
TEXT: The dog likes the lion.
FOL: Likes(Dog, Lion)
TEXT: The dog likes the mouse.
FOL: Likes(Dog, Mouse)
TEXT: The lion eats the tiger.
FOL: Eats(Lion, Tiger)
TEXT: The mouse is not cold.
FOL: -Cold(Mouse)
TEXT: The mouse is round.
FOL: Round(Mouse)
TEXT: The mouse needs the dog.
FOL: Needs(Mouse, Dog)
TEXT: The tiger is blue.
FOL: Blue(Tiger)
TEXT: The tiger is rough.
FOL: Rough(Tiger)
TEXT: The tiger does not need the lion.
FOL: -Needs(Tiger, Lion)
TEXT: If someone likes the mouse and they are blue then the mouse eats the dog.
FOL: all x. ((Likes(x, Mouse) & Blue(x)) -> Eats(Mouse, Dog))
TEXT: If someone likes the mouse and the mouse is blue then the mouse is rough.
FOL: all x. ((Likes(x, Mouse) & Blue(Mouse)) -> Rough(Mouse))
TEXT: If someone is cold then they need the tiger.
FOL: all x. (Cold(x) -> Needs(x, Tiger))
TEXT: If someone eats the lion then they need the tiger.
FOL: all x. (Eats(x, Lion) -> Needs(x, Tiger))
TEXT: If someone likes the dog then they are rough.
FOL: all x. (Likes(x, Dog) -> Rough(x))
TEXT: If someone is blue and they eat the lion then the lion is rough.
FOL: all x. ((Blue(x) & Eats(x, Lion)) -> Rough(Lion))
TEXT: If someone is rough then they eat the lion.
FOL: all x. (Rough(x) -> Eats(x, Lion))
TEXT: If someone needs the tiger then they do not like the lion.
FOL: all x. (Needs(x, Tiger) -> -Likes(x, Lion))
TEXT: The mouse eats the lion.
FOL: Eats(Mouse, Lion)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: The dog does not eat the mouse.
FOL: -Eats(Dog, Mouse)
TEXT: The dog does not eat the tiger.
FOL: -Eats(Dog, Tiger)
TEXT: The dog is round.
FOL: Round(Dog)
TEXT: The dog likes the lion.
FOL: Likes(Dog, Lion)
TEXT: The dog likes the mouse.
FOL: Likes(Dog, Mouse)
TEXT: The lion eats the tiger.
FOL: Eats(Lion, Tiger)
TEXT: The mouse is not cold.
FOL: -Cold(Mouse)
TEXT: The mouse is round.
FOL: Round(Mouse)
TEXT: The mouse needs the dog.
FOL: Needs(Mouse, Dog)
TEXT: The tiger is blue.
FOL: Blue(Tiger)
TEXT: The tiger is rough.
FOL: Rough(Tiger)
TEXT: The tiger does not need the lion.
FOL: -Needs(Tiger, Lion)
TEXT: If someone likes the mouse and they are blue then the mouse eats the dog.
FOL: all x. (Likes(x, Mouse) & Blue(x) -> Eats(Mouse, Dog))
TEXT: If someone likes the mouse and the mouse is blue then the mouse is rough.
FOL: all x. (Likes(x, Mouse) & Blue(Mouse) -> Rough(Mouse))
TEXT: If someone is cold then they need the tiger.
FOL: all x. (Cold(x) -> Needs(x, Tiger))
TEXT: If someone eats the lion then they need the tiger.
FOL: all x. (Eats(x, Lion) -> Needs(x, Tiger))
TEXT: If someone likes the dog then they are rough.
FOL: all x. (Likes(x, Dog) -> Rough(x))
TEXT: If someone is blue and they eat the lion then the lion is rough.
FOL: all x. (Blue(x) & Eats(x, Lion) -> Rough(Lion))
TEXT: If someone is rough then they eat the lion.
FOL: all x. (Rough(x) -> Eats(x, Lion))
TEXT: If someone needs the tiger then they do not like the lion.
FOL: all x. (Needs(x, Tiger) -> -Likes(x, Lion))
TEXT: The mouse eats the lion.
FOL: Eats(Mouse, Lion)
Processed: Uncertain

Generation 3:
TEXT: The dog does not eat the mouse.
FOL: -Eats(Dog, Mouse)

TEXT: The dog does not eat the tiger.
FOL: -Eats(Dog, Tiger)

TEXT: The dog is round.
FOL: Round(Dog)

TEXT: The dog likes the lion.
FOL: Likes(Dog, Lion)

TEXT: The dog likes the mouse.
FOL: Likes(Dog, Mouse)

TEXT: The lion eats the tiger.
FOL: Eats(Lion, Tiger)

TEXT: The mouse is not cold.
FOL: -Cold(Mouse)

TEXT: The mouse is round.
FOL: Round(Mouse)

TEXT: The mouse needs the dog.
FOL: Needs(Mouse, Dog)

TEXT: The tiger is blue.
FOL: Blue(Tiger)

TEXT: The tiger is rough.
FOL: Rough(Tiger)

TEXT: The tiger does not need the lion.
FOL: -Needs(Tiger, Lion)

TEXT: If someone likes the mouse and they are blue then the mouse eats the dog.
FOL: all x. ((Likes(x, Mouse) & Blue(x)) -> Eats(Mouse, Dog))

TEXT: If someone likes the mouse and the mouse is blue then the mouse is rough.
FOL: all x. ((Likes(x, Mouse) & Blue(Mouse)) -> Rough(Mouse))

TEXT: If someone is cold then they need the tiger.
FOL: all x. (Cold(x) -> Needs(x, Tiger))

TEXT: If someone eats the lion then they need the tiger.
FOL: all x. (Eats(x, Lion) -> Needs(x, Tiger))

TEXT: If someone likes the dog then they are rough.
FOL: all x. (Likes(x, Dog) -> Rough(x))

TEXT: If someone is blue and they eat the lion then the lion is rough.
FOL: all x. ((Blue(x) & Eats(x, Lion)) -> Rough(Lion))

TEXT: If someone is rough then they eat the lion.
FOL: all x. (Rough(x) -> Eats(x, Lion))

TEXT: If someone needs the tiger then they do not like the lion.
FOL: all x. (Needs(x, Tiger) -> -Likes(x, Lion))

TEXT: The mouse eats the lion.
FOL: Eats(Mouse, Lion)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 79 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is kind.
Charlie is quiet.
Fiona is big.
Fiona is blue.
Fiona is kind.
Fiona is quiet.
Gary is white.
Blue, quiet things are big.
All quiet things are blue.
Quiet, rough things are big.
Rough things are quiet.
All big things are red.
If Gary is white then Gary is rough.
If something is white and big then it is blue.
All rough, blue things are white.
If something is quiet and red then it is kind.
</PREMISES>
<CONCLUSION>
Charlie is white.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is kind.
FOL: Kind(Bob)
TEXT: Charlie is quiet.
FOL: Quiet(Charlie)
TEXT: Fiona is big.
FOL: Big(Fiona)
TEXT: Fiona is blue.
FOL: Blue(Fiona)
TEXT: Fiona is kind.
FOL: Kind(Fiona)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Gary is white.
FOL: White(Gary)
TEXT: Blue, quiet things are big.
FOL: all x. (Blue(x) & Quiet(x) -> Big(x))
TEXT: All quiet things are blue.
FOL: all x. (Quiet(x) -> Blue(x))
TEXT: Quiet, rough things are big.
FOL: all x. (Quiet(x) & Rough(x) -> Big(x))
TEXT: Rough things are quiet.
FOL: all x. (Rough(x) -> Quiet(x))
TEXT: All big things are red.
FOL: all x. (Big(x) -> Red(x))
TEXT: If Gary is white then Gary is rough.
FOL: White(Gary) -> Rough(Gary)
TEXT: If something is white and big then it is blue.
FOL: all x. (White(x) & Big(x) -> Blue(x))
TEXT: All rough, blue things are white.
FOL: all x. (Rough(x) & Blue(x) -> White(x))
TEXT: If something is quiet and red then it is kind.
FOL: all x. (Quiet(x) & Red(x) -> Kind(x))
TEXT: Charlie is white.
FOL: White(Charlie)
Processed: Uncertain

Generation 2:
TEXT: Bob is kind.
FOL: Kind(Bob)
TEXT: Charlie is quiet.
FOL: Quiet(Charlie)
TEXT: Fiona is big.
FOL: Big(Fiona)
TEXT: Fiona is blue.
FOL: Blue(Fiona)
TEXT: Fiona is kind.
FOL: Kind(Fiona)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Gary is white.
FOL: White(Gary)
TEXT: Blue, quiet things are big.
FOL: all x. (Blue(x) & Quiet(x) -> Big(x))
TEXT: All quiet things are blue.
FOL: all x. (Quiet(x) -> Blue(x))
TEXT: Quiet, rough things are big.
FOL: all x. (Quiet(x) & Rough(x) -> Big(x))
TEXT: Rough things are quiet.
FOL: all x. (Rough(x) -> Quiet(x))
TEXT: All big things are red.
FOL: all x. (Big(x) -> Red(x))
TEXT: If Gary is white then Gary is rough.
FOL: White(Gary) -> Rough(Gary)
TEXT: If something is white and big then it is blue.
FOL: all x. (White(x) & Big(x) -> Blue(x))
TEXT: All rough, blue things are white.
FOL: all x. (Rough(x) & Blue(x) -> White(x))
TEXT: If something is quiet and red then it is kind.
FOL: all x. (Quiet(x) & Red(x) -> Kind(x))
TEXT: Charlie is white.
FOL: White(Charlie)
Processed: Uncertain

Generation 3:
TEXT: Bob is kind.
FOL: Kind(Bob)

TEXT: Charlie is quiet.
FOL: Quiet(Charlie)

TEXT: Fiona is big.
FOL: Big(Fiona)

TEXT: Fiona is blue.
FOL: Blue(Fiona)

TEXT: Fiona is kind.
FOL: Kind(Fiona)

TEXT: Fiona is quiet.
FOL: Quiet(Fiona)

TEXT: Gary is white.
FOL: White(Gary)

TEXT: Blue, quiet things are big.
FOL: all x. (Blue(x) & Quiet(x) -> Big(x))

TEXT: All quiet things are blue.
FOL: all x. (Quiet(x) -> Blue(x))

TEXT: Quiet, rough things are big.
FOL: all x. (Quiet(x) & Rough(x) -> Big(x))

TEXT: Rough things are quiet.
FOL: all x. (Rough(x) -> Quiet(x))

TEXT: All big things are red.
FOL: all x. (Big(x) -> Red(x))

TEXT: If Gary is white then Gary is rough.
FOL: White(Gary) -> Rough(Gary)

TEXT: If something is white and big then it is blue.
FOL: all x. (White(x) & Big(x) -> Blue(x))

TEXT: All rough, blue things are white.
FOL: all x. (Rough(x) & Blue(x) -> White(x))

TEXT: If something is quiet and red then it is kind.
FOL: all x. (Quiet(x) & Red(x) -> Kind(x))

TEXT: Charlie is white.
FOL: White(Charlie)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 80 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle eats the squirrel.
The bald eagle is kind.
The bald eagle is round.
The bald eagle does not visit the squirrel.
The cat is rough.
The cat likes the squirrel.
The cow is big.
The cow likes the squirrel.
The cow visits the squirrel.
The squirrel eats the cow.
The squirrel likes the bald eagle.
If someone likes the cow and they do not eat the cat then they do not eat the bald eagle.
If someone eats the cat then they are blue.
If someone is big then they do not like the cat.
If the cow eats the cat and the cat is big then the cow visits the bald eagle.
If someone visits the cat then the cat is round.
If someone visits the cow then they are round.
If someone is kind then they like the squirrel.
If someone visits the cat and the cat is round then they are big.
If someone eats the squirrel and they like the squirrel then the squirrel visits the cat.
</PREMISES>
<CONCLUSION>
The squirrel does not like the cat.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle eats the squirrel.
FOL: Eats(BaldEagle, Squirrel)
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)
TEXT: The bald eagle is round.
FOL: Round(BaldEagle)
TEXT: The bald eagle does not visit the squirrel.
FOL: -Visits(BaldEagle, Squirrel)
TEXT: The cat is rough.
FOL: Rough(Cat)
TEXT: The cat likes the squirrel.
FOL: Likes(Cat, Squirrel)
TEXT: The cow is big.
FOL: Big(Cow)
TEXT: The cow likes the squirrel.
FOL: Likes(Cow, Squirrel)
TEXT: The cow visits the squirrel.
FOL: Visits(Cow, Squirrel)
TEXT: The squirrel eats the cow.
FOL: Eats(Squirrel, Cow)
TEXT: The squirrel likes the bald eagle.
FOL: Likes(Squirrel, BaldEagle)
TEXT: If someone likes the cow and they do not eat the cat then they do not eat the bald eagle.
FOL: all x. (Likes(x, Cow) & -Eats(x, Cat) -> -Eats(x, BaldEagle))
TEXT: If someone eats the cat then they are blue.
FOL: all x. (Eats(x, Cat) -> Blue(x))
TEXT: If someone is big then they do not like the cat.
FOL: all x. (Big(x) -> -Likes(x, Cat))
TEXT: If the cow eats the cat and the cat is big then the cow visits the bald eagle.
FOL: (Eats(Cow, Cat) & Big(Cat)) -> Visits(Cow, BaldEagle)
TEXT: If someone visits the cat then the cat is round.
FOL: all x. (Visits(x, Cat) -> Round(Cat))
TEXT: If someone visits the cow then they are round.
FOL: all x. (Visits(x, Cow) -> Round(x))
TEXT: If someone is kind then they like the squirrel.
FOL: all x. (Kind(x) -> Likes(x, Squirrel))
TEXT: If someone visits the cat and the cat is round then they are big.
FOL: all x. (Visits(x, Cat) & Round(Cat) -> Big(x))
TEXT: If someone eats the squirrel and they like the squirrel then the squirrel visits the cat.
FOL: all x. (Eats(x, Squirrel) & Likes(x, Squirrel) -> Visits(Squirrel, Cat))
TEXT: The squirrel does not like the cat.
FOL: -Likes(Squirrel, Cat)
</EVALUATE>
Processed: True

Generation 2:
TEXT: The bald eagle eats the squirrel.
FOL: Eats(BaldEagle, Squirrel)
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)
TEXT: The bald eagle is round.
FOL: Round(BaldEagle)
TEXT: The bald eagle does not visit the squirrel.
FOL: -Visits(BaldEagle, Squirrel)
TEXT: The cat is rough.
FOL: Rough(Cat)
TEXT: The cat likes the squirrel.
FOL: Likes(Cat, Squirrel)
TEXT: The cow is big.
FOL: Big(Cow)
TEXT: The cow likes the squirrel.
FOL: Likes(Cow, Squirrel)
TEXT: The cow visits the squirrel.
FOL: Visits(Cow, Squirrel)
TEXT: The squirrel eats the cow.
FOL: Eats(Squirrel, Cow)
TEXT: The squirrel likes the bald eagle.
FOL: Likes(Squirrel, BaldEagle)
TEXT: If someone likes the cow and they do not eat the cat then they do not eat the bald eagle.
FOL: all x. (Likes(x, Cow) & -Eats(x, Cat) -> -Eats(x, BaldEagle))
TEXT: If someone eats the cat then they are blue.
FOL: all x. (Eats(x, Cat) -> Blue(x))
TEXT: If someone is big then they do not like the cat.
FOL: all x. (Big(x) -> -Likes(x, Cat))
TEXT: If the cow eats the cat and the cat is big then the cow visits the bald eagle.
FOL: (Eats(Cow, Cat) & Big(Cat)) -> Visits(Cow, BaldEagle)
TEXT: If someone visits the cat then the cat is round.
FOL: all x. (Visits(x, Cat) -> Round(Cat))
TEXT: If someone visits the cow then they are round.
FOL: all x. (Visits(x, Cow) -> Round(x))
TEXT: If someone is kind then they like the squirrel.
FOL: all x. (Kind(x) -> Likes(x, Squirrel))
TEXT: If someone visits the cat and the cat is round then they are big.
FOL: all x. (Visits(x, Cat) & Round(Cat) -> Big(x))
TEXT: If someone eats the squirrel and they like the squirrel then the squirrel visits the cat.
FOL: all x. (Eats(x, Squirrel) & Likes(x, Squirrel) -> Visits(Squirrel, Cat))
TEXT: The squirrel does not like the cat.
FOL: -Likes(Squirrel, Cat)
</EVALUATE>
Processed: True

Generation 3:
TEXT: The bald eagle eats the squirrel.
FOL: Eats(BaldEagle, Squirrel)
TEXT: The bald eagle is kind.
FOL: Kind(BaldEagle)
TEXT: The bald eagle is round.
FOL: Round(BaldEagle)
TEXT: The bald eagle does not visit the squirrel.
FOL: -Visits(BaldEagle, Squirrel)
TEXT: The cat is rough.
FOL: Rough(Cat)
TEXT: The cat likes the squirrel.
FOL: Likes(Cat, Squirrel)
TEXT: The cow is big.
FOL: Big(Cow)
TEXT: The cow likes the squirrel.
FOL: Likes(Cow, Squirrel)
TEXT: The cow visits the squirrel.
FOL: Visits(Cow, Squirrel)
TEXT: The squirrel eats the cow.
FOL: Eats(Squirrel, Cow)
TEXT: The squirrel likes the bald eagle.
FOL: Likes(Squirrel, BaldEagle)
TEXT: If someone likes the cow and they do not eat the cat then they do not eat the bald eagle.
FOL: all x. (Likes(x, Cow) & -Eats(x, Cat) -> -Eats(x, BaldEagle))
TEXT: If someone eats the cat then they are blue.
FOL: all x. (Eats(x, Cat) -> Blue(x))
TEXT: If someone is big then they do not like the cat.
FOL: all x. (Big(x) -> -Likes(x, Cat))
TEXT: If the cow eats the cat and the cat is big then the cow visits the bald eagle.
FOL: (Eats(Cow, Cat) & Big(Cat)) -> Visits(Cow, BaldEagle)
TEXT: If someone visits the cat then the cat is round.
FOL: all x. (Visits(x, Cat) -> Round(Cat))
TEXT: If someone visits the cow then they are round.
FOL: all x. (Visits(x, Cow) -> Round(x))
TEXT: If someone is kind then they like the squirrel.
FOL: all x. (Kind(x) -> Likes(x, Squirrel))
TEXT: If someone visits the cat and the cat is round then they are big.
FOL: all x. (Visits(x, Cat) & Round(Cat) -> Big(x))
TEXT: If someone eats the squirrel and they like the squirrel then the squirrel visits the cat.
FOL: all x. (Eats(x, Squirrel) & Likes(x, Squirrel) -> Visits(Squirrel, Cat))
TEXT: The squirrel does not like the cat.
FOL: -Likes(Squirrel, Cat)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 81 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Charlie is cold.
Charlie is furry.
Charlie is smart.
Dave is furry.
Dave is young.
Gary is quiet.
Gary is smart.
Harry is furry.
Harry is quiet.
Harry is young.
If someone is cold and quiet then they are white.
If someone is cold and big then they are young.
All furry people are white.
Quiet people are cold.
If someone is furry then they are white.
If someone is smart and white then they are furry.
All furry people are big.
</PREMISES>
<CONCLUSION>
Harry is not cold.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Charlie is cold.
FOL: Cold(Charlie)
TEXT: Charlie is furry.
FOL: Furry(Charlie)
TEXT: Charlie is smart.
FOL: Smart(Charlie)
TEXT: Dave is furry.
FOL: Furry(Dave)
TEXT: Dave is young.
FOL: Young(Dave)
TEXT: Gary is quiet.
FOL: Quiet(Gary)
TEXT: Gary is smart.
FOL: Smart(Gary)
TEXT: Harry is furry.
FOL: Furry(Harry)
TEXT: Harry is quiet.
FOL: Quiet(Harry)
TEXT: Harry is young.
FOL: Young(Harry)
TEXT: If someone is cold and quiet then they are white.
FOL: all x. (Cold(x) & Quiet(x) -> White(x))
TEXT: If someone is cold and big then they are young.
FOL: all x. (Cold(x) & Big(x) -> Young(x))
TEXT: All furry people are white.
FOL: all x. (Furry(x) -> White(x))
TEXT: Quiet people are cold.
FOL: all x. (Quiet(x) -> Cold(x))
TEXT: If someone is furry then they are white.
FOL: all x. (Furry(x) -> White(x))
TEXT: If someone is smart and white then they are furry.
FOL: all x. (Smart(x) & White(x) -> Furry(x))
TEXT: All furry people are big.
FOL: all x. (Furry(x) -> Big(x))
TEXT: Harry is not cold.
FOL: -Cold(Harry)
</EVALUATE>
Processed: False

Generation 2:
TEXT: Charlie is cold.
FOL: Cold(Charlie)
TEXT: Charlie is furry.
FOL: Furry(Charlie)
TEXT: Charlie is smart.
FOL: Smart(Charlie)
TEXT: Dave is furry.
FOL: Furry(Dave)
TEXT: Dave is young.
FOL: Young(Dave)
TEXT: Gary is quiet.
FOL: Quiet(Gary)
TEXT: Gary is smart.
FOL: Smart(Gary)
TEXT: Harry is furry.
FOL: Furry(Harry)
TEXT: Harry is quiet.
FOL: Quiet(Harry)
TEXT: Harry is young.
FOL: Young(Harry)
TEXT: If someone is cold and quiet then they are white.
FOL: all x. (Cold(x) & Quiet(x) -> White(x))
TEXT: If someone is cold and big then they are young.
FOL: all x. (Cold(x) & Big(x) -> Young(x))
TEXT: All furry people are white.
FOL: all x. (Furry(x) -> White(x))
TEXT: Quiet people are cold.
FOL: all x. (Quiet(x) -> Cold(x))
TEXT: If someone is furry then they are white.
FOL: all x. (Furry(x) -> White(x))
TEXT: If someone is smart and white then they are furry.
FOL: all x. (Smart(x) & White(x) -> Furry(x))
TEXT: All furry people are big.
FOL: all x. (Furry(x) -> Big(x))
TEXT: Harry is not cold.
FOL: -Cold(Harry)
Processed: False

Generation 3:
TEXT: Charlie is cold.
FOL: Cold(Charlie)
TEXT: Charlie is furry.
FOL: Furry(Charlie)
TEXT: Charlie is smart.
FOL: Smart(Charlie)
TEXT: Dave is furry.
FOL: Furry(Dave)
TEXT: Dave is young.
FOL: Young(Dave)
TEXT: Gary is quiet.
FOL: Quiet(Gary)
TEXT: Gary is smart.
FOL: Smart(Gary)
TEXT: Harry is furry.
FOL: Furry(Harry)
TEXT: Harry is quiet.
FOL: Quiet(Harry)
TEXT: Harry is young.
FOL: Young(Harry)
TEXT: If someone is cold and quiet then they are white.
FOL: all x. (Cold(x) & Quiet(x) -> White(x))
TEXT: If someone is cold and big then they are young.
FOL: all x. (Cold(x) & Big(x) -> Young(x))
TEXT: All furry people are white.
FOL: all x. (Furry(x) -> White(x))
TEXT: Quiet people are cold.
FOL: all x. (Quiet(x) -> Cold(x))
TEXT: If someone is furry then they are white.
FOL: all x. (Furry(x) -> White(x))
TEXT: If someone is smart and white then they are furry.
FOL: all x. (Smart(x) & White(x) -> Furry(x))
TEXT: All furry people are big.
FOL: all x. (Furry(x) -> Big(x))
TEXT: Harry is not cold.
FOL: -Cold(Harry)
Processed: False

Reference: False
========================================

=== Example 82 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is nice.
Charlie is round.
Gary is blue.
Gary is nice.
Gary is rough.
Gary is round.
Harry is blue.
Harry is nice.
Harry is quiet.
Harry is rough.
All quiet, round people are young.
All young, blue people are rough.
All round, big people are young.
Blue people are round.
All rough people are quiet.
If someone is big then they are rough.
If someone is quiet and big then they are round.
If Charlie is nice and Charlie is big then Charlie is blue.
All nice people are big.
</PREMISES>
<CONCLUSION>
Bob is blue.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is nice.
FOL: Nice(Bob)
TEXT: Charlie is round.
FOL: Round(Charlie)
TEXT: Gary is blue.
FOL: Blue(Gary)
TEXT: Gary is nice.
FOL: Nice(Gary)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: Gary is round.
FOL: Round(Gary)
TEXT: Harry is blue.
FOL: Blue(Harry)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: Harry is quiet.
FOL: Quiet(Harry)
TEXT: Harry is rough.
FOL: Rough(Harry)
TEXT: All quiet, round people are young.
FOL: all x. (Quiet(x) & Round(x) -> Young(x))
TEXT: All young, blue people are rough.
FOL: all x. (Young(x) & Blue(x) -> Rough(x))
TEXT: All round, big people are young.
FOL: all x. (Round(x) & Big(x) -> Young(x))
TEXT: Blue people are round.
FOL: all x. (Blue(x) -> Round(x))
TEXT: All rough people are quiet.
FOL: all x. (Rough(x) -> Quiet(x))
TEXT: If someone is big then they are rough.
FOL: all x. (Big(x) -> Rough(x))
TEXT: If someone is quiet and big then they are round.
FOL: all x. (Quiet(x) & Big(x) -> Round(x))
TEXT: If Charlie is nice and Charlie is big then Charlie is blue.
FOL: (Nice(Charlie) & Big(Charlie) -> Blue(Charlie))
TEXT: All nice people are big.
FOL: all x. (Nice(x) -> Big(x))
TEXT: Bob is blue.
FOL: Blue(Bob)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: Bob is nice.
FOL: Nice(Bob)
TEXT: Charlie is round.
FOL: Round(Charlie)
TEXT: Gary is blue.
FOL: Blue(Gary)
TEXT: Gary is nice.
FOL: Nice(Gary)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: Gary is round.
FOL: Round(Gary)
TEXT: Harry is blue.
FOL: Blue(Harry)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: Harry is quiet.
FOL: Quiet(Harry)
TEXT: Harry is rough.
FOL: Rough(Harry)
TEXT: All quiet, round people are young.
FOL: all x. (Quiet(x) & Round(x) -> Young(x))
TEXT: All young, blue people are rough.
FOL: all x. (Young(x) & Blue(x) -> Rough(x))
TEXT: All round, big people are young.
FOL: all x. (Round(x) & Big(x) -> Young(x))
TEXT: Blue people are round.
FOL: all x. (Blue(x) -> Round(x))
TEXT: All rough people are quiet.
FOL: all x. (Rough(x) -> Quiet(x))
TEXT: If someone is big then they are rough.
FOL: all x. (Big(x) -> Rough(x))
TEXT: If someone is quiet and big then they are round.
FOL: all x. (Quiet(x) & Big(x) -> Round(x))
TEXT: If Charlie is nice and Charlie is big then Charlie is blue.
FOL: ((Nice(Charlie) & Big(Charlie)) -> Blue(Charlie))
TEXT: All nice people are big.
FOL: all x. (Nice(x) -> Big(x))
TEXT: Bob is blue.
FOL: Blue(Bob)
Processed: Uncertain

Generation 3:
TEXT: Bob is nice.
FOL: Nice(Bob)

TEXT: Charlie is round.
FOL: Round(Charlie)

TEXT: Gary is blue.
FOL: Blue(Gary)

TEXT: Gary is nice.
FOL: Nice(Gary)

TEXT: Gary is rough.
FOL: Rough(Gary)

TEXT: Gary is round.
FOL: Round(Gary)

TEXT: Harry is blue.
FOL: Blue(Harry)

TEXT: Harry is nice.
FOL: Nice(Harry)

TEXT: Harry is quiet.
FOL: Quiet(Harry)

TEXT: Harry is rough.
FOL: Rough(Harry)

TEXT: All quiet, round people are young.
FOL: all x. (Quiet(x) & Round(x) -> Young(x))

TEXT: All young, blue people are rough.
FOL: all x. (Young(x) & Blue(x) -> Rough(x))

TEXT: All round, big people are young.
FOL: all x. (Round(x) & Big(x) -> Young(x))

TEXT: Blue people are round.
FOL: all x. (Blue(x) -> Round(x))

TEXT: All rough people are quiet.
FOL: all x. (Rough(x) -> Quiet(x))

TEXT: If someone is big then they are rough.
FOL: all x. (Big(x) -> Rough(x))

TEXT: If someone is quiet and big then they are round.
FOL: all x. (Quiet(x) & Big(x) -> Round(x))

TEXT: If Charlie is nice and Charlie is big then Charlie is blue.
FOL: (Nice(Charlie) & Big(Charlie) -> Blue(Charlie))

TEXT: All nice people are big.
FOL: all x. (Nice(x) -> Big(x))

TEXT: Bob is blue.
FOL: Blue(Bob)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 83 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is cold.
Charlie is furry.
Charlie is round.
Fiona is quiet.
Gary is nice.
Gary is quiet.
Gary is round.
Nice people are white.
All round, cold people are nice.
If someone is furry and round then they are cold.
All cold, green people are quiet.
If Charlie is cold then Charlie is nice.
If someone is furry and white then they are green.
If Anne is white and Anne is quiet then Anne is green.
</PREMISES>
<CONCLUSION>
Charlie is white.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is cold.
FOL: Cold(Anne)
TEXT: Charlie is furry.
FOL: Furry(Charlie)
TEXT: Charlie is round.
FOL: Round(Charlie)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Gary is nice.
FOL: Nice(Gary)
TEXT: Gary is quiet.
FOL: Quiet(Gary)
TEXT: Gary is round.
FOL: Round(Gary)
TEXT: Nice people are white.
FOL: all x. (Nice(x) -> White(x))
TEXT: All round, cold people are nice.
FOL: all x. ((Round(x) & Cold(x)) -> Nice(x))
TEXT: If someone is furry and round then they are cold.
FOL: all x. ((Furry(x) & Round(x)) -> Cold(x))
TEXT: All cold, green people are quiet.
FOL: all x. ((Cold(x) & Green(x)) -> Quiet(x))
TEXT: If Charlie is cold then Charlie is nice.
FOL: (Cold(Charlie) -> Nice(Charlie))
TEXT: If someone is furry and white then they are green.
FOL: all x. ((Furry(x) & White(x)) -> Green(x))
TEXT: If Anne is white and Anne is quiet then Anne is green.
FOL: ((White(Anne) & Quiet(Anne)) -> Green(Anne))
TEXT: Charlie is white.
FOL: White(Charlie)
Processed: True

Generation 2:
TEXT: Anne is cold.
FOL: Cold(Anne)
TEXT: Charlie is furry.
FOL: Furry(Charlie)
TEXT: Charlie is round.
FOL: Round(Charlie)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Gary is nice.
FOL: Nice(Gary)
TEXT: Gary is quiet.
FOL: Quiet(Gary)
TEXT: Gary is round.
FOL: Round(Gary)
TEXT: Nice people are white.
FOL: all x. (Nice(x) -> White(x))
TEXT: All round, cold people are nice.
FOL: all x. (Round(x) & Cold(x) -> Nice(x))
TEXT: If someone is furry and round then they are cold.
FOL: all x. (Furry(x) & Round(x) -> Cold(x))
TEXT: All cold, green people are quiet.
FOL: all x. (Cold(x) & Green(x) -> Quiet(x))
TEXT: If Charlie is cold then Charlie is nice.
FOL: Cold(Charlie) -> Nice(Charlie)
TEXT: If someone is furry and white then they are green.
FOL: all x. (Furry(x) & White(x) -> Green(x))
TEXT: If Anne is white and Anne is quiet then Anne is green.
FOL: (White(Anne) & Quiet(Anne)) -> Green(Anne)
TEXT: Charlie is white.
FOL: White(Charlie)
Processed: True

Generation 3:
TEXT: Anne is cold.
FOL: Cold(Anne)
TEXT: Charlie is furry.
FOL: Furry(Charlie)
TEXT: Charlie is round.
FOL: Round(Charlie)
TEXT: Fiona is quiet.
FOL: Quiet(Fiona)
TEXT: Gary is nice.
FOL: Nice(Gary)
TEXT: Gary is quiet.
FOL: Quiet(Gary)
TEXT: Gary is round.
FOL: Round(Gary)
TEXT: Nice people are white.
FOL: all x. (Nice(x) -> White(x))
TEXT: All round, cold people are nice.
FOL: all x. (Round(x) & Cold(x) -> Nice(x))
TEXT: If someone is furry and round then they are cold.
FOL: all x. (Furry(x) & Round(x) -> Cold(x))
TEXT: All cold, green people are quiet.
FOL: all x. (Cold(x) & Green(x) -> Quiet(x))
TEXT: If Charlie is cold then Charlie is nice.
FOL: Cold(Charlie) -> Nice(Charlie)
TEXT: If someone is furry and white then they are green.
FOL: all x. (Furry(x) & White(x) -> Green(x))
TEXT: If Anne is white and Anne is quiet then Anne is green.
FOL: (White(Anne) & Quiet(Anne)) -> Green(Anne)
TEXT: Charlie is white.
FOL: White(Charlie)
</EVALUATE>
Processed: True

Reference: True
========================================

=== Example 84 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The cat is red.
The cat needs the cow.
The cow is red.
The cow needs the cat.
The cow sees the cat.
The cow does not see the dog.
The cow sees the tiger.
The dog is blue.
The dog needs the cow.
The dog does not need the tiger.
The dog sees the tiger.
The dog visits the cat.
The dog visits the cow.
The tiger is cold.
The tiger sees the cat.
The tiger sees the cow.
If something is cold and blue then it sees the dog.
If something visits the dog then the dog visits the tiger.
If something needs the cat then the cat visits the dog.
If something visits the tiger then the tiger is blue.
If something needs the dog and the dog needs the cat then the cat sees the tiger.
If something sees the dog then it visits the cat.
If something sees the tiger and the tiger is red then it needs the cat.
If something sees the tiger and the tiger sees the dog then the tiger visits the dog.
</PREMISES>
<CONCLUSION>
The tiger needs the cat.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The cat is red.
FOL: Red(Cat)

TEXT: The cat needs the cow.
FOL: Needs(Cat, Cow)

TEXT: The cow is red.
FOL: Red(Cow)

TEXT: The cow needs the cat.
FOL: Needs(Cow, Cat)

TEXT: The cow sees the cat.
FOL: Sees(Cow, Cat)

TEXT: The cow does not see the dog.
FOL: -Sees(Cow, Dog)

TEXT: The cow sees the tiger.
FOL: Sees(Cow, Tiger)

TEXT: The dog is blue.
FOL: Blue(Dog)

TEXT: The dog needs the cow.
FOL: Needs(Dog, Cow)

TEXT: The dog does not need the tiger.
FOL: -Needs(Dog, Tiger)

TEXT: The dog sees the tiger.
FOL: Sees(Dog, Tiger)

TEXT: The dog visits the cat.
FOL: Visits(Dog, Cat)

TEXT: The dog visits the cow.
FOL: Visits(Dog, Cow)

TEXT: The tiger is cold.
FOL: Cold(Tiger)

TEXT: The tiger sees the cat.
FOL: Sees(Tiger, Cat)

TEXT: The tiger sees the cow.
FOL: Sees(Tiger, Cow)

TEXT: If something is cold and blue then it sees the dog.
FOL: all x. (Cold(x) & Blue(x) -> Sees(x, Dog))

TEXT: If something visits the dog then the dog visits the tiger.
FOL: all x. (Visits(x, Dog) -> Visits(Dog, Tiger))

TEXT: If something needs the cat then the cat visits the dog.
FOL: all x. (Needs(x, Cat) -> Visits(Cat, Dog))

TEXT: If something visits the tiger then the tiger is blue.
FOL: all x. (Visits(x, Tiger) -> Blue(Tiger))

TEXT: If something needs the dog and the dog needs the cat then the cat sees the tiger.
FOL: all x. (Needs(x, Dog) & Needs(Dog, Cat) -> Sees(Cat, Tiger))

TEXT: If something sees the dog then it visits the cat.
FOL: all x. (Sees(x, Dog) -> Visits(x, Cat))

TEXT: If something sees the tiger and the tiger is red then it needs the cat.
FOL: all x. (Sees(x, Tiger) & Red(Tiger) -> Needs(x, Cat))

TEXT: If something sees the tiger and the tiger sees the dog then the tiger visits the dog.
FOL: all x. (Sees(x, Tiger) & Sees(Tiger, Dog) -> Visits(Tiger, Dog))

TEXT: The tiger needs the cat.
FOL: Needs(Tiger, Cat)
Processed: Uncertain

Generation 2:
TEXT: The cat is red.
FOL: Red(Cat)
TEXT: The cat needs the cow.
FOL: Needs(Cat, Cow)
TEXT: The cow is red.
FOL: Red(Cow)
TEXT: The cow needs the cat.
FOL: Needs(Cow, Cat)
TEXT: The cow sees the cat.
FOL: Sees(Cow, Cat)
TEXT: The cow does not see the dog.
FOL: -Sees(Cow, Dog)
TEXT: The cow sees the tiger.
FOL: Sees(Cow, Tiger)
TEXT: The dog is blue.
FOL: Blue(Dog)
TEXT: The dog needs the cow.
FOL: Needs(Dog, Cow)
TEXT: The dog does not need the tiger.
FOL: -Needs(Dog, Tiger)
TEXT: The dog sees the tiger.
FOL: Sees(Dog, Tiger)
TEXT: The dog visits the cat.
FOL: Visits(Dog, Cat)
TEXT: The dog visits the cow.
FOL: Visits(Dog, Cow)
TEXT: The tiger is cold.
FOL: Cold(Tiger)
TEXT: The tiger sees the cat.
FOL: Sees(Tiger, Cat)
TEXT: The tiger sees the cow.
FOL: Sees(Tiger, Cow)
TEXT: If something is cold and blue then it sees the dog.
FOL: all x. (Cold(x) & Blue(x) -> Sees(x, Dog))
TEXT: If something visits the dog then the dog visits the tiger.
FOL: all x. (Visits(x, Dog) -> Visits(Dog, Tiger))
TEXT: If something needs the cat then the cat visits the dog.
FOL: all x. (Needs(x, Cat) -> Visits(Cat, Dog))
TEXT: If something visits the tiger then the tiger is blue.
FOL: all x. (Visits(x, Tiger) -> Blue(Tiger))
TEXT: If something needs the dog and the dog needs the cat then the cat sees the tiger.
FOL: all x. (Needs(x, Dog) & Needs(Dog, Cat) -> Sees(Cat, Tiger))
TEXT: If something sees the dog then it visits the cat.
FOL: all x. (Sees(x, Dog) -> Visits(x, Cat))
TEXT: If something sees the tiger and the tiger is red then it needs the cat.
FOL: all x. (Sees(x, Tiger) & Red(Tiger) -> Needs(x, Cat))
TEXT: If something sees the tiger and the tiger sees the dog then the tiger visits the dog.
FOL: all x. (Sees(x, Tiger) & Sees(Tiger, Dog) -> Visits(Tiger, Dog))
TEXT: The tiger needs the cat.
FOL: Needs(Tiger, Cat)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: The cat is red.
FOL: Color(Cat, Red)

TEXT: The cat needs the cow.
FOL: Needs(Cat, Cow)

TEXT: The cow is red.
FOL: Color(Cow, Red)

TEXT: The cow needs the cat.
FOL: Needs(Cow, Cat)

TEXT: The cow sees the cat.
FOL: Sees(Cow, Cat)

TEXT: The cow does not see the dog.
FOL: -Sees(Cow, Dog)

TEXT: The cow sees the tiger.
FOL: Sees(Cow, Tiger)

TEXT: The dog is blue.
FOL: Color(Dog, Blue)

TEXT: The dog needs the cow.
FOL: Needs(Dog, Cow)

TEXT: The dog does not need the tiger.
FOL: -Needs(Dog, Tiger)

TEXT: The dog sees the tiger.
FOL: Sees(Dog, Tiger)

TEXT: The dog visits the cat.
FOL: Visits(Dog, Cat)

TEXT: The dog visits the cow.
FOL: Visits(Dog, Cow)

TEXT: The tiger is cold.
FOL: Cold(Tiger)

TEXT: The tiger sees the cat.
FOL: Sees(Tiger, Cat)

TEXT: The tiger sees the cow.
FOL: Sees(Tiger, Cow)

TEXT: If something is cold and blue then it sees the dog.
FOL: all x. (Cold(x) & Color(x, Blue) -> Sees(x, Dog))

TEXT: If something visits the dog then the dog visits the tiger.
FOL: all x. (Visits(x, Dog) -> Visits(Dog, Tiger))

TEXT: If something needs the cat then the cat visits the dog.
FOL: all x. (Needs(x, Cat) -> Visits(Cat, Dog))

TEXT: If something visits the tiger then the tiger is blue.
FOL: all x. (Visits(x, Tiger) -> Color(Tiger, Blue))

TEXT: If something needs the dog and the dog needs the cat then the cat sees the tiger.
FOL: all x. (Needs(x, Dog) & Needs(Dog, Cat) -> Sees(Cat, Tiger))

TEXT: If something sees the dog then it visits the cat.
FOL: all x. (Sees(x, Dog) -> Visits(x, Cat))

TEXT: If something sees the tiger and the tiger is red then it needs the cat.
FOL: all x. (Sees(x, Tiger) & Color(Tiger, Red) -> Needs(x, Cat))

TEXT: If something sees the tiger and the tiger sees the dog then the tiger visits the dog.
FOL: all x. (Sees(x, Tiger) & Sees(Tiger, Dog) -> Visits(Tiger, Dog))

TEXT: The tiger needs the cat.
FOL: Needs(Tiger, Cat)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 85 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The cow likes the lion.
The cow likes the mouse.
The cow likes the squirrel.
The lion eats the mouse.
The lion is green.
The lion likes the squirrel.
The mouse is blue.
The mouse likes the cow.
The mouse visits the lion.
The squirrel visits the cow.
If someone visits the cow then they eat the mouse.
If someone likes the mouse then they visit the lion.
If someone visits the cow then they eat the cow.
If someone visits the squirrel and the squirrel is blue then the squirrel likes the cow.
If someone is cold then they eat the cow.
If someone is green then they are big.
If someone is big and green then they like the lion.
If someone likes the lion then they are cold.
If someone eats the cow then they visit the cow.
</PREMISES>
<CONCLUSION>
The mouse is cold.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The cow likes the lion.
FOL: Likes(Cow, Lion)
TEXT: The cow likes the mouse.
FOL: Likes(Cow, Mouse)
TEXT: The cow likes the squirrel.
FOL: Likes(Cow, Squirrel)
TEXT: The lion eats the mouse.
FOL: Eats(Lion, Mouse)
TEXT: The lion is green.
FOL: Green(Lion)
TEXT: The lion likes the squirrel.
FOL: Likes(Lion, Squirrel)
TEXT: The mouse is blue.
FOL: Blue(Mouse)
TEXT: The mouse likes the cow.
FOL: Likes(Mouse, Cow)
TEXT: The mouse visits the lion.
FOL: Visits(Mouse, Lion)
TEXT: The squirrel visits the cow.
FOL: Visits(Squirrel, Cow)
TEXT: If someone visits the cow then they eat the mouse.
FOL: all x. (Visits(x, Cow) -> Eats(x, Mouse))
TEXT: If someone likes the mouse then they visit the lion.
FOL: all x. (Likes(x, Mouse) -> Visits(x, Lion))
TEXT: If someone visits the cow then they eat the cow.
FOL: all x. (Visits(x, Cow) -> Eats(x, Cow))
TEXT: If someone visits the squirrel and the squirrel is blue then the squirrel likes the cow.
FOL: all x. ((Visits(x, Squirrel) & Blue(Squirrel)) -> Likes(Squirrel, Cow))
TEXT: If someone is cold then they eat the cow.
FOL: all x. (Cold(x) -> Eats(x, Cow))
TEXT: If someone is green then they are big.
FOL: all x. (Green(x) -> Big(x))
TEXT: If someone is big and green then they like the lion.
FOL: all x. ((Big(x) & Green(x)) -> Likes(x, Lion))
TEXT: If someone likes the lion then they are cold.
FOL: all x. (Likes(x, Lion) -> Cold(x))
TEXT: If someone eats the cow then they visit the cow.
FOL: all x. (Eats(x, Cow) -> Visits(x, Cow))
TEXT: The mouse is cold.
FOL: Cold(Mouse)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: The cow likes the lion.
FOL: Likes(Cow, Lion)
TEXT: The cow likes the mouse.
FOL: Likes(Cow, Mouse)
TEXT: The cow likes the squirrel.
FOL: Likes(Cow, Squirrel)
TEXT: The lion eats the mouse.
FOL: Eats(Lion, Mouse)
TEXT: The lion is green.
FOL: Green(Lion)
TEXT: The lion likes the squirrel.
FOL: Likes(Lion, Squirrel)
TEXT: The mouse is blue.
FOL: Blue(Mouse)
TEXT: The mouse likes the cow.
FOL: Likes(Mouse, Cow)
TEXT: The mouse visits the lion.
FOL: Visits(Mouse, Lion)
TEXT: The squirrel visits the cow.
FOL: Visits(Squirrel, Cow)
TEXT: If someone visits the cow then they eat the mouse.
FOL: all x. (Visits(x, Cow) -> Eats(x, Mouse))
TEXT: If someone likes the mouse then they visit the lion.
FOL: all x. (Likes(x, Mouse) -> Visits(x, Lion))
TEXT: If someone visits the cow then they eat the cow.
FOL: all x. (Visits(x, Cow) -> Eats(x, Cow))
TEXT: If someone visits the squirrel and the squirrel is blue then the squirrel likes the cow.
FOL: all x. ((Visits(x, Squirrel) & Blue(Squirrel)) -> Likes(Squirrel, Cow))
TEXT: If someone is cold then they eat the cow.
FOL: all x. (Cold(x) -> Eats(x, Cow))
TEXT: If someone is green then they are big.
FOL: all x. (Green(x) -> Big(x))
TEXT: If someone is big and green then they like the lion.
FOL: all x. ((Big(x) & Green(x)) -> Likes(x, Lion))
TEXT: If someone likes the lion then they are cold.
FOL: all x. (Likes(x, Lion) -> Cold(x))
TEXT: If someone eats the cow then they visit the cow.
FOL: all x. (Eats(x, Cow) -> Visits(x, Cow))
TEXT: The mouse is cold.
FOL: Cold(Mouse)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: The cow likes the lion.
FOL: Likes(Cow, Lion)
TEXT: The cow likes the mouse.
FOL: Likes(Cow, Mouse)
TEXT: The cow likes the squirrel.
FOL: Likes(Cow, Squirrel)
TEXT: The lion eats the mouse.
FOL: Eats(Lion, Mouse)
TEXT: The lion is green.
FOL: Green(Lion)
TEXT: The lion likes the squirrel.
FOL: Likes(Lion, Squirrel)
TEXT: The mouse is blue.
FOL: Blue(Mouse)
TEXT: The mouse likes the cow.
FOL: Likes(Mouse, Cow)
TEXT: The mouse visits the lion.
FOL: Visits(Mouse, Lion)
TEXT: The squirrel visits the cow.
FOL: Visits(Squirrel, Cow)
TEXT: If someone visits the cow then they eat the mouse.
FOL: all x. (Visits(x, Cow) -> Eats(x, Mouse))
TEXT: If someone likes the mouse then they visit the lion.
FOL: all x. (Likes(x, Mouse) -> Visits(x, Lion))
TEXT: If someone visits the cow then they eat the cow.
FOL: all x. (Visits(x, Cow) -> Eats(x, Cow))
TEXT: If someone visits the squirrel and the squirrel is blue then the squirrel likes the cow.
FOL: all x. ((Visits(x, Squirrel) & Blue(Squirrel)) -> Likes(Squirrel, Cow))
TEXT: If someone is cold then they eat the cow.
FOL: all x. (Cold(x) -> Eats(x, Cow))
TEXT: If someone is green then they are big.
FOL: all x. (Green(x) -> Big(x))
TEXT: If someone is big and green then they like the lion.
FOL: all x. ((Big(x) & Green(x)) -> Likes(x, Lion))
TEXT: If someone likes the lion then they are cold.
FOL: all x. (Likes(x, Lion) -> Cold(x))
TEXT: If someone eats the cow then they visit the cow.
FOL: all x. (Eats(x, Cow) -> Visits(x, Cow))
TEXT: The mouse is cold.
FOL: Cold(Mouse)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 86 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle chases the dog.
The bald eagle is green.
The bald eagle visits the squirrel.
The dog chases the rabbit.
The dog likes the squirrel.
The rabbit chases the bald eagle.
The rabbit is rough.
The rabbit likes the squirrel.
The rabbit visits the squirrel.
The squirrel likes the bald eagle.
If someone likes the dog then the dog is round.
If someone chases the rabbit then the rabbit does not visit the dog.
If someone likes the dog then they are rough.
If someone likes the dog then they are green.
If someone visits the squirrel then they are round.
If someone chases the rabbit then the rabbit is round.
If someone is round then they like the dog.
If the squirrel likes the bald eagle and the squirrel is not round then the bald eagle likes the rabbit.
</PREMISES>
<CONCLUSION>
The rabbit does not like the dog.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle chases the dog.
FOL: Chases(BaldEagle, Dog)
TEXT: The bald eagle is green.
FOL: Green(BaldEagle)
TEXT: The bald eagle visits the squirrel.
FOL: Visits(BaldEagle, Squirrel)
TEXT: The dog chases the rabbit.
FOL: Chases(Dog, Rabbit)
TEXT: The dog likes the squirrel.
FOL: Likes(Dog, Squirrel)
TEXT: The rabbit chases the bald eagle.
FOL: Chases(Rabbit, BaldEagle)
TEXT: The rabbit is rough.
FOL: Rough(Rabbit)
TEXT: The rabbit likes the squirrel.
FOL: Likes(Rabbit, Squirrel)
TEXT: The rabbit visits the squirrel.
FOL: Visits(Rabbit, Squirrel)
TEXT: The squirrel likes the bald eagle.
FOL: Likes(Squirrel, BaldEagle)
TEXT: If someone likes the dog then the dog is round.
FOL: all x. (Likes(x, Dog) -> Round(Dog))
TEXT: If someone chases the rabbit then the rabbit does not visit the dog.
FOL: all x. (Chases(x, Rabbit) -> -Visits(Rabbit, Dog))
TEXT: If someone likes the dog then they are rough.
FOL: all x. (Likes(x, Dog) -> Rough(x))
TEXT: If someone likes the dog then they are green.
FOL: all x. (Likes(x, Dog) -> Green(x))
TEXT: If someone visits the squirrel then they are round.
FOL: all x. (Visits(x, Squirrel) -> Round(x))
TEXT: If someone chases the rabbit then the rabbit is round.
FOL: all x. (Chases(x, Rabbit) -> Round(Rabbit))
TEXT: If someone is round then they like the dog.
FOL: all x. (Round(x) -> Likes(x, Dog))
TEXT: If the squirrel likes the bald eagle and the squirrel is not round then the bald eagle likes the rabbit.
FOL: (Likes(Squirrel, BaldEagle) & -Round(Squirrel)) -> Likes(BaldEagle, Rabbit)
TEXT: The rabbit does not like the dog.
FOL: -Likes(Rabbit, Dog)
</EVALUATE>
Processed: False

Generation 2:
TEXT: The bald eagle chases the dog.
FOL: Chases(BaldEagle, Dog)
TEXT: The bald eagle is green.
FOL: Green(BaldEagle)
TEXT: The bald eagle visits the squirrel.
FOL: Visits(BaldEagle, Squirrel)
TEXT: The dog chases the rabbit.
FOL: Chases(Dog, Rabbit)
TEXT: The dog likes the squirrel.
FOL: Likes(Dog, Squirrel)
TEXT: The rabbit chases the bald eagle.
FOL: Chases(Rabbit, BaldEagle)
TEXT: The rabbit is rough.
FOL: Rough(Rabbit)
TEXT: The rabbit likes the squirrel.
FOL: Likes(Rabbit, Squirrel)
TEXT: The rabbit visits the squirrel.
FOL: Visits(Rabbit, Squirrel)
TEXT: The squirrel likes the bald eagle.
FOL: Likes(Squirrel, BaldEagle)
TEXT: If someone likes the dog then the dog is round.
FOL: all x. (Likes(x, Dog) -> Round(Dog))
TEXT: If someone chases the rabbit then the rabbit does not visit the dog.
FOL: all x. (Chases(x, Rabbit) -> -Visits(Rabbit, Dog))
TEXT: If someone likes the dog then they are rough.
FOL: all x. (Likes(x, Dog) -> Rough(x))
TEXT: If someone likes the dog then they are green.
FOL: all x. (Likes(x, Dog) -> Green(x))
TEXT: If someone visits the squirrel then they are round.
FOL: all x. (Visits(x, Squirrel) -> Round(x))
TEXT: If someone chases the rabbit then the rabbit is round.
FOL: all x. (Chases(x, Rabbit) -> Round(Rabbit))
TEXT: If someone is round then they like the dog.
FOL: all x. (Round(x) -> Likes(x, Dog))
TEXT: If the squirrel likes the bald eagle and the squirrel is not round then the bald eagle likes the rabbit.
FOL: (Likes(Squirrel, BaldEagle) & -Round(Squirrel)) -> Likes(BaldEagle, Rabbit)
TEXT: The rabbit does not like the dog.
FOL: -Likes(Rabbit, Dog)
Processed: False

Generation 3:
TEXT: The bald eagle chases the dog.
FOL: Chases(BaldEagle, Dog)

TEXT: The bald eagle is green.
FOL: Green(BaldEagle)

TEXT: The bald eagle visits the squirrel.
FOL: Visits(BaldEagle, Squirrel)

TEXT: The dog chases the rabbit.
FOL: Chases(Dog, Rabbit)

TEXT: The dog likes the squirrel.
FOL: Likes(Dog, Squirrel)

TEXT: The rabbit chases the bald eagle.
FOL: Chases(Rabbit, BaldEagle)

TEXT: The rabbit is rough.
FOL: Rough(Rabbit)

TEXT: The rabbit likes the squirrel.
FOL: Likes(Rabbit, Squirrel)

TEXT: The rabbit visits the squirrel.
FOL: Visits(Rabbit, Squirrel)

TEXT: The squirrel likes the bald eagle.
FOL: Likes(Squirrel, BaldEagle)

TEXT: If someone likes the dog then the dog is round.
FOL: all x. (Likes(x, Dog) -> Round(Dog))

TEXT: If someone chases the rabbit then the rabbit does not visit the dog.
FOL: all x. (Chases(x, Rabbit) -> -Visits(Rabbit, Dog))

TEXT: If someone likes the dog then they are rough.
FOL: all x. (Likes(x, Dog) -> Rough(x))

TEXT: If someone likes the dog then they are green.
FOL: all x. (Likes(x, Dog) -> Green(x))

TEXT: If someone visits the squirrel then they are round.
FOL: all x. (Visits(x, Squirrel) -> Round(x))

TEXT: If someone chases the rabbit then the rabbit is round.
FOL: all x. (Chases(x, Rabbit) -> Round(Rabbit))

TEXT: If someone is round then they like the dog.
FOL: all x. (Round(x) -> Likes(x, Dog))

TEXT: If the squirrel likes the bald eagle and the squirrel is not round then the bald eagle likes the rabbit.
FOL: (Likes(Squirrel, BaldEagle) & -Round(Squirrel)) -> Likes(BaldEagle, Rabbit)

TEXT: The rabbit does not like the dog.
FOL: -Likes(Rabbit, Dog)
Processed: False

Reference: False
========================================

=== Example 87 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is nice.
Bob is cold.
Bob is not red.
Bob is rough.
Charlie is red.
Charlie is rough.
Harry is nice.
Harry is quiet.
Harry is rough.
Harry is round.
Nice people are quiet.
If someone is red and nice then they are not quiet.
Quiet people are cold.
If someone is quiet and round then they are not red.
If someone is green and quiet then they are round.
If someone is cold then they are green.
</PREMISES>
<CONCLUSION>
Bob is round.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Bob is cold.
FOL: Cold(Bob)
TEXT: Bob is not red.
FOL: -Red(Bob)
TEXT: Bob is rough.
FOL: Rough(Bob)
TEXT: Charlie is red.
FOL: Red(Charlie)
TEXT: Charlie is rough.
FOL: Rough(Charlie)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: Harry is quiet.
FOL: Quiet(Harry)
TEXT: Harry is rough.
FOL: Rough(Harry)
TEXT: Harry is round.
FOL: Round(Harry)
TEXT: Nice people are quiet.
FOL: all x. (Nice(x) -> Quiet(x))
TEXT: If someone is red and nice then they are not quiet.
FOL: all x. ((Red(x) & Nice(x)) -> -Quiet(x))
TEXT: Quiet people are cold.
FOL: all x. (Quiet(x) -> Cold(x))
TEXT: If someone is quiet and round then they are not red.
FOL: all x. ((Quiet(x) & Round(x)) -> -Red(x))
TEXT: If someone is green and quiet then they are round.
FOL: all x. ((Green(x) & Quiet(x)) -> Round(x))
TEXT: If someone is cold then they are green.
FOL: all x. (Cold(x) -> Green(x))
TEXT: Bob is round.
FOL: Round(Bob)
Processed: Uncertain

Generation 2:
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Bob is cold.
FOL: Cold(Bob)
TEXT: Bob is not red.
FOL: -Red(Bob)
TEXT: Bob is rough.
FOL: Rough(Bob)
TEXT: Charlie is red.
FOL: Red(Charlie)
TEXT: Charlie is rough.
FOL: Rough(Charlie)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: Harry is quiet.
FOL: Quiet(Harry)
TEXT: Harry is rough.
FOL: Rough(Harry)
TEXT: Harry is round.
FOL: Round(Harry)
TEXT: Nice people are quiet.
FOL: all x. (Nice(x) -> Quiet(x))
TEXT: If someone is red and nice then they are not quiet.
FOL: all x. ((Red(x) & Nice(x)) -> -Quiet(x))
TEXT: Quiet people are cold.
FOL: all x. (Quiet(x) -> Cold(x))
TEXT: If someone is quiet and round then they are not red.
FOL: all x. ((Quiet(x) & Round(x)) -> -Red(x))
TEXT: If someone is green and quiet then they are round.
FOL: all x. ((Green(x) & Quiet(x)) -> Round(x))
TEXT: If someone is cold then they are green.
FOL: all x. (Cold(x) -> Green(x))
TEXT: Bob is round.
FOL: Round(Bob)
</EVALUATE>
Processed: Uncertain

Generation 3:
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Bob is cold.
FOL: Cold(Bob)
TEXT: Bob is not red.
FOL: -Red(Bob)
TEXT: Bob is rough.
FOL: Rough(Bob)
TEXT: Charlie is red.
FOL: Red(Charlie)
TEXT: Charlie is rough.
FOL: Rough(Charlie)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: Harry is quiet.
FOL: Quiet(Harry)
TEXT: Harry is rough.
FOL: Rough(Harry)
TEXT: Harry is round.
FOL: Round(Harry)
TEXT: Nice people are quiet.
FOL: all x. (Nice(x) -> Quiet(x))
TEXT: If someone is red and nice then they are not quiet.
FOL: all x. (Red(x) & Nice(x) -> -Quiet(x))
TEXT: Quiet people are cold.
FOL: all x. (Quiet(x) -> Cold(x))
TEXT: If someone is quiet and round then they are not red.
FOL: all x. (Quiet(x) & Round(x) -> -Red(x))
TEXT: If someone is green and quiet then they are round.
FOL: all x. (Green(x) & Quiet(x) -> Round(x))
TEXT: If someone is cold then they are green.
FOL: all x. (Cold(x) -> Green(x))
TEXT: Bob is round.
FOL: Round(Bob)
</EVALUATE>
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 88 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is big.
Anne is cold.
Dave is quiet.
Dave is smart.
Gary is big.
Gary is cold.
Gary is quiet.
Gary is not red.
Gary is rough.
Gary is round.
Harry is red.
Harry is rough.
Big things are cold.
Round, rough things are cold.
If something is cold then it is rough.
If something is big and cold then it is quiet.
If something is cold then it is quiet.
Quiet things are round.
Round, cold things are big.
Red, rough things are big.
All round things are smart.
</PREMISES>
<CONCLUSION>
Dave is not cold.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is big.
FOL: Big(Anne)
TEXT: Anne is cold.
FOL: Cold(Anne)
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Dave is smart.
FOL: Smart(Dave)
TEXT: Gary is big.
FOL: Big(Gary)
TEXT: Gary is cold.
FOL: Cold(Gary)
TEXT: Gary is quiet.
FOL: Quiet(Gary)
TEXT: Gary is not red.
FOL: -Red(Gary)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: Gary is round.
FOL: Round(Gary)
TEXT: Harry is red.
FOL: Red(Harry)
TEXT: Harry is rough.
FOL: Rough(Harry)
TEXT: Big things are cold.
FOL: all x. (Big(x) -> Cold(x))
TEXT: Round, rough things are cold.
FOL: all x. ((Round(x) & Rough(x)) -> Cold(x))
TEXT: If something is cold then it is rough.
FOL: all x. (Cold(x) -> Rough(x))
TEXT: If something is big and cold then it is quiet.
FOL: all x. ((Big(x) & Cold(x)) -> Quiet(x))
TEXT: If something is cold then it is quiet.
FOL: all x. (Cold(x) -> Quiet(x))
TEXT: Quiet things are round.
FOL: all x. (Quiet(x) -> Round(x))
TEXT: Round, cold things are big.
FOL: all x. ((Round(x) & Cold(x)) -> Big(x))
TEXT: Red, rough things are big.
FOL: all x. ((Red(x) & Rough(x)) -> Big(x))
TEXT: All round things are smart.
FOL: all x. (Round(x) -> Smart(x))
TEXT: Dave is not cold.
FOL: -Cold(Dave)
Processed: Uncertain

Generation 2:
TEXT: Anne is big.
FOL: Big(Anne)
TEXT: Anne is cold.
FOL: Cold(Anne)
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Dave is smart.
FOL: Smart(Dave)
TEXT: Gary is big.
FOL: Big(Gary)
TEXT: Gary is cold.
FOL: Cold(Gary)
TEXT: Gary is quiet.
FOL: Quiet(Gary)
TEXT: Gary is not red.
FOL: -Red(Gary)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: Gary is round.
FOL: Round(Gary)
TEXT: Harry is red.
FOL: Red(Harry)
TEXT: Harry is rough.
FOL: Rough(Harry)
TEXT: Big things are cold.
FOL: all x. (Big(x) -> Cold(x))
TEXT: Round, rough things are cold.
FOL: all x. ((Round(x) & Rough(x)) -> Cold(x))
TEXT: If something is cold then it is rough.
FOL: all x. (Cold(x) -> Rough(x))
TEXT: If something is big and cold then it is quiet.
FOL: all x. ((Big(x) & Cold(x)) -> Quiet(x))
TEXT: If something is cold then it is quiet.
FOL: all x. (Cold(x) -> Quiet(x))
TEXT: Quiet things are round.
FOL: all x. (Quiet(x) -> Round(x))
TEXT: Round, cold things are big.
FOL: all x. ((Round(x) & Cold(x)) -> Big(x))
TEXT: Red, rough things are big.
FOL: all x. ((Red(x) & Rough(x)) -> Big(x))
TEXT: All round things are smart.
FOL: all x. (Round(x) -> Smart(x))
TEXT: Dave is not cold.
FOL: -Cold(Dave)
Processed: Uncertain

Generation 3:
TEXT: Anne is big.
FOL: Big(Anne)
TEXT: Anne is cold.
FOL: Cold(Anne)
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Dave is smart.
FOL: Smart(Dave)
TEXT: Gary is big.
FOL: Big(Gary)
TEXT: Gary is cold.
FOL: Cold(Gary)
TEXT: Gary is quiet.
FOL: Quiet(Gary)
TEXT: Gary is not red.
FOL: -Red(Gary)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: Gary is round.
FOL: Round(Gary)
TEXT: Harry is red.
FOL: Red(Harry)
TEXT: Harry is rough.
FOL: Rough(Harry)
TEXT: Big things are cold.
FOL: all x. (Big(x) -> Cold(x))
TEXT: Round, rough things are cold.
FOL: all x. (Round(x) & Rough(x) -> Cold(x))
TEXT: If something is cold then it is rough.
FOL: all x. (Cold(x) -> Rough(x))
TEXT: If something is big and cold then it is quiet.
FOL: all x. (Big(x) & Cold(x) -> Quiet(x))
TEXT: If something is cold then it is quiet.
FOL: all x. (Cold(x) -> Quiet(x))
TEXT: Quiet things are round.
FOL: all x. (Quiet(x) -> Round(x))
TEXT: Round, cold things are big.
FOL: all x. (Round(x) & Cold(x) -> Big(x))
TEXT: Red, rough things are big.
FOL: all x. (Red(x) & Rough(x) -> Big(x))
TEXT: All round things are smart.
FOL: all x. (Round(x) -> Smart(x))
TEXT: Dave is not cold.
FOL: -Cold(Dave)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 89 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is green.
Anne is nice.
Anne is quiet.
Erin is big.
Erin is nice.
Erin is quiet.
Gary is blue.
Gary is green.
Harry is blue.
Harry is green.
Harry is kind.
Harry is round.
If something is kind and blue then it is nice.
Nice things are round.
If something is round then it is quiet.
Blue things are round.
Nice things are big.
If something is round and quiet then it is kind.
</PREMISES>
<CONCLUSION>
Harry is not blue.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is green.
FOL: Green(Anne)
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
TEXT: Erin is big.
FOL: Big(Erin)
TEXT: Erin is nice.
FOL: Nice(Erin)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Gary is blue.
FOL: Blue(Gary)
TEXT: Gary is green.
FOL: Green(Gary)
TEXT: Harry is blue.
FOL: Blue(Harry)
TEXT: Harry is green.
FOL: Green(Harry)
TEXT: Harry is kind.
FOL: Kind(Harry)
TEXT: Harry is round.
FOL: Round(Harry)
TEXT: If something is kind and blue then it is nice.
FOL: all x. (Kind(x) & Blue(x) -> Nice(x))
TEXT: Nice things are round.
FOL: all x. (Nice(x) -> Round(x))
TEXT: If something is round then it is quiet.
FOL: all x. (Round(x) -> Quiet(x))
TEXT: Blue things are round.
FOL: all x. (Blue(x) -> Round(x))
TEXT: Nice things are big.
FOL: all x. (Nice(x) -> Big(x))
TEXT: If something is round and quiet then it is kind.
FOL: all x. (Round(x) & Quiet(x) -> Kind(x))
TEXT: Harry is not blue.
FOL: -Blue(Harry)
Processed: False

Generation 2:
TEXT: Anne is green.
FOL: Green(Anne)
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
TEXT: Erin is big.
FOL: Big(Erin)
TEXT: Erin is nice.
FOL: Nice(Erin)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Gary is blue.
FOL: Blue(Gary)
TEXT: Gary is green.
FOL: Green(Gary)
TEXT: Harry is blue.
FOL: Blue(Harry)
TEXT: Harry is green.
FOL: Green(Harry)
TEXT: Harry is kind.
FOL: Kind(Harry)
TEXT: Harry is round.
FOL: Round(Harry)
TEXT: If something is kind and blue then it is nice.
FOL: all x. (Kind(x) & Blue(x) -> Nice(x))
TEXT: Nice things are round.
FOL: all x. (Nice(x) -> Round(x))
TEXT: If something is round then it is quiet.
FOL: all x. (Round(x) -> Quiet(x))
TEXT: Blue things are round.
FOL: all x. (Blue(x) -> Round(x))
TEXT: Nice things are big.
FOL: all x. (Nice(x) -> Big(x))
TEXT: If something is round and quiet then it is kind.
FOL: all x. (Round(x) & Quiet(x) -> Kind(x))
TEXT: Harry is not blue.
FOL: -Blue(Harry)
</EVALUATE>
Processed: False

Generation 3:
TEXT: Anne is green.
FOL: Green(Anne)
TEXT: Anne is nice.
FOL: Nice(Anne)
TEXT: Anne is quiet.
FOL: Quiet(Anne)
TEXT: Erin is big.
FOL: Big(Erin)
TEXT: Erin is nice.
FOL: Nice(Erin)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Gary is blue.
FOL: Blue(Gary)
TEXT: Gary is green.
FOL: Green(Gary)
TEXT: Harry is blue.
FOL: Blue(Harry)
TEXT: Harry is green.
FOL: Green(Harry)
TEXT: Harry is kind.
FOL: Kind(Harry)
TEXT: Harry is round.
FOL: Round(Harry)
TEXT: If something is kind and blue then it is nice.
FOL: all x. (Kind(x) & Blue(x) -> Nice(x))
TEXT: Nice things are round.
FOL: all x. (Nice(x) -> Round(x))
TEXT: If something is round then it is quiet.
FOL: all x. (Round(x) -> Quiet(x))
TEXT: Blue things are round.
FOL: all x. (Blue(x) -> Round(x))
TEXT: Nice things are big.
FOL: all x. (Nice(x) -> Big(x))
TEXT: If something is round and quiet then it is kind.
FOL: all x. (Round(x) & Quiet(x) -> Kind(x))
TEXT: Harry is not blue.
FOL: -Blue(Harry)
Processed: False

Reference: False
========================================

=== Example 90 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Anne is blue.
Erin is quiet.
Fiona is big.
Fiona is furry.
Fiona is nice.
Harry is furry.
Harry is not rough.
Round things are blue.
If something is round and not big then it is not nice.
Quiet things are nice.
All blue, round things are nice.
Nice, rough things are round.
If something is furry then it is round.
Furry, blue things are quiet.
Nice things are furry.
If something is round and blue then it is not rough.
</PREMISES>
<CONCLUSION>
Erin is not blue.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Anne is blue.
FOL: Blue(Anne)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Fiona is big.
FOL: Big(Fiona)
TEXT: Fiona is furry.
FOL: Furry(Fiona)
TEXT: Fiona is nice.
FOL: Nice(Fiona)
TEXT: Harry is furry.
FOL: Furry(Harry)
TEXT: Harry is not rough.
FOL: -Rough(Harry)
TEXT: Round things are blue.
FOL: all x. (Round(x) -> Blue(x))
TEXT: If something is round and not big then it is not nice.
FOL: all x. (Round(x) & -Big(x) -> -Nice(x))
TEXT: Quiet things are nice.
FOL: all x. (Quiet(x) -> Nice(x))
TEXT: All blue, round things are nice.
FOL: all x. (Blue(x) & Round(x) -> Nice(x))
TEXT: Nice, rough things are round.
FOL: all x. (Nice(x) & Rough(x) -> Round(x))
TEXT: If something is furry then it is round.
FOL: all x. (Furry(x) -> Round(x))
TEXT: Furry, blue things are quiet.
FOL: all x. (Furry(x) & Blue(x) -> Quiet(x))
TEXT: Nice things are furry.
FOL: all x. (Nice(x) -> Furry(x))
TEXT: If something is round and blue then it is not rough.
FOL: all x. (Round(x) & Blue(x) -> -Rough(x))
TEXT: Erin is not blue.
FOL: -Blue(Erin)
Processed: False

Generation 2:
TEXT: Anne is blue.
FOL: Blue(Anne)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Fiona is big.
FOL: Big(Fiona)
TEXT: Fiona is furry.
FOL: Furry(Fiona)
TEXT: Fiona is nice.
FOL: Nice(Fiona)
TEXT: Harry is furry.
FOL: Furry(Harry)
TEXT: Harry is not rough.
FOL: -Rough(Harry)
TEXT: Round things are blue.
FOL: all x. (Round(x) -> Blue(x))
TEXT: If something is round and not big then it is not nice.
FOL: all x. (Round(x) & -Big(x) -> -Nice(x))
TEXT: Quiet things are nice.
FOL: all x. (Quiet(x) -> Nice(x))
TEXT: All blue, round things are nice.
FOL: all x. (Blue(x) & Round(x) -> Nice(x))
TEXT: Nice, rough things are round.
FOL: all x. (Nice(x) & Rough(x) -> Round(x))
TEXT: If something is furry then it is round.
FOL: all x. (Furry(x) -> Round(x))
TEXT: Furry, blue things are quiet.
FOL: all x. (Furry(x) & Blue(x) -> Quiet(x))
TEXT: Nice things are furry.
FOL: all x. (Nice(x) -> Furry(x))
TEXT: If something is round and blue then it is not rough.
FOL: all x. (Round(x) & Blue(x) -> -Rough(x))
TEXT: Erin is not blue.
FOL: -Blue(Erin)
Processed: False

Generation 3:
TEXT: Anne is blue.
FOL: Blue(Anne)
TEXT: Erin is quiet.
FOL: Quiet(Erin)
TEXT: Fiona is big.
FOL: Big(Fiona)
TEXT: Fiona is furry.
FOL: Furry(Fiona)
TEXT: Fiona is nice.
FOL: Nice(Fiona)
TEXT: Harry is furry.
FOL: Furry(Harry)
TEXT: Harry is not rough.
FOL: -Rough(Harry)
TEXT: Round things are blue.
FOL: all x. (Round(x) -> Blue(x))
TEXT: If something is round and not big then it is not nice.
FOL: all x. (Round(x) & -Big(x) -> -Nice(x))
TEXT: Quiet things are nice.
FOL: all x. (Quiet(x) -> Nice(x))
TEXT: All blue, round things are nice.
FOL: all x. (Blue(x) & Round(x) -> Nice(x))
TEXT: Nice, rough things are round.
FOL: all x. (Nice(x) & Rough(x) -> Round(x))
TEXT: If something is furry then it is round.
FOL: all x. (Furry(x) -> Round(x))
TEXT: Furry, blue things are quiet.
FOL: all x. (Furry(x) & Blue(x) -> Quiet(x))
TEXT: Nice things are furry.
FOL: all x. (Nice(x) -> Furry(x))
TEXT: If something is round and blue then it is not rough.
FOL: all x. (Round(x) & Blue(x) -> -Rough(x))
TEXT: Erin is not blue.
FOL: -Blue(Erin)
Processed: False

Reference: False
========================================

=== Example 91 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bear chases the rabbit.
The bear chases the tiger.
The bear is red.
The bear needs the lion.
The bear needs the rabbit.
The bear sees the lion.
The lion is nice.
The lion is red.
The lion is round.
The lion sees the bear.
The rabbit chases the tiger.
The rabbit is round.
The rabbit is young.
The tiger chases the rabbit.
The tiger is round.
The tiger sees the bear.
If something sees the tiger then it sees the bear.
If something chases the tiger and the tiger is red then it is round.
If the bear needs the tiger then the tiger needs the lion.
If something sees the rabbit then the rabbit sees the lion.
If something is round then it needs the rabbit.
If something chases the bear then it sees the rabbit.
If the lion is red and the lion needs the bear then the bear chases the lion.
If something sees the lion then it chases the bear.
</PREMISES>
<CONCLUSION>
The rabbit needs the rabbit.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bear chases the rabbit.
FOL: Chases(Bear, Rabbit)
TEXT: The bear chases the tiger.
FOL: Chases(Bear, Tiger)
TEXT: The bear is red.
FOL: Red(Bear)
TEXT: The bear needs the lion.
FOL: Needs(Bear, Lion)
TEXT: The bear needs the rabbit.
FOL: Needs(Bear, Rabbit)
TEXT: The bear sees the lion.
FOL: Sees(Bear, Lion)
TEXT: The lion is nice.
FOL: Nice(Lion)
TEXT: The lion is red.
FOL: Red(Lion)
TEXT: The lion is round.
FOL: Round(Lion)
TEXT: The lion sees the bear.
FOL: Sees(Lion, Bear)
TEXT: The rabbit chases the tiger.
FOL: Chases(Rabbit, Tiger)
TEXT: The rabbit is round.
FOL: Round(Rabbit)
TEXT: The rabbit is young.
FOL: Young(Rabbit)
TEXT: The tiger chases the rabbit.
FOL: Chases(Tiger, Rabbit)
TEXT: The tiger is round.
FOL: Round(Tiger)
TEXT: The tiger sees the bear.
FOL: Sees(Tiger, Bear)
TEXT: If something sees the tiger then it sees the bear.
FOL: all x. (Sees(x, Tiger) -> Sees(x, Bear))
TEXT: If something chases the tiger and the tiger is red then it is round.
FOL: all x. ((Chases(x, Tiger) & Red(Tiger)) -> Round(x))
TEXT: If the bear needs the tiger then the tiger needs the lion.
FOL: (Needs(Bear, Tiger) -> Needs(Tiger, Lion))
TEXT: If something sees the rabbit then the rabbit sees the lion.
FOL: all x. (Sees(x, Rabbit) -> Sees(Rabbit, Lion))
TEXT: If something is round then it needs the rabbit.
FOL: all x. (Round(x) -> Needs(x, Rabbit))
TEXT: If something chases the bear then it sees the rabbit.
FOL: all x. (Chases(x, Bear) -> Sees(x, Rabbit))
TEXT: If the lion is red and the lion needs the bear then the bear chases the lion.
FOL: ((Red(Lion) & Needs(Lion, Bear)) -> Chases(Bear, Lion))
TEXT: If something sees the lion then it chases the bear.
FOL: all x. (Sees(x, Lion) -> Chases(x, Bear))
TEXT: The rabbit needs the rabbit.
FOL: Needs(Rabbit, Rabbit)
</EVALUATE>
Processed: True

Generation 2:
TEXT: The bear chases the rabbit.
FOL: Chases(Bear, Rabbit)

TEXT: The bear chases the tiger.
FOL: Chases(Bear, Tiger)

TEXT: The bear is red.
FOL: Red(Bear)

TEXT: The bear needs the lion.
FOL: Needs(Bear, Lion)

TEXT: The bear needs the rabbit.
FOL: Needs(Bear, Rabbit)

TEXT: The bear sees the lion.
FOL: Sees(Bear, Lion)

TEXT: The lion is nice.
FOL: Nice(Lion)

TEXT: The lion is red.
FOL: Red(Lion)

TEXT: The lion is round.
FOL: Round(Lion)

TEXT: The lion sees the bear.
FOL: Sees(Lion, Bear)

TEXT: The rabbit chases the tiger.
FOL: Chases(Rabbit, Tiger)

TEXT: The rabbit is round.
FOL: Round(Rabbit)

TEXT: The rabbit is young.
FOL: Young(Rabbit)

TEXT: The tiger chases the rabbit.
FOL: Chases(Tiger, Rabbit)

TEXT: The tiger is round.
FOL: Round(Tiger)

TEXT: The tiger sees the bear.
FOL: Sees(Tiger, Bear)

TEXT: If something sees the tiger then it sees the bear.
FOL: all x. (Sees(x, Tiger) -> Sees(x, Bear))

TEXT: If something chases the tiger and the tiger is red then it is round.
FOL: all x. (Chases(x, Tiger) & Red(Tiger) -> Round(x))

TEXT: If the bear needs the tiger then the tiger needs the lion.
FOL: Needs(Bear, Tiger) -> Needs(Tiger, Lion)

TEXT: If something sees the rabbit then the rabbit sees the lion.
FOL: all x. (Sees(x, Rabbit) -> Sees(Rabbit, Lion))

TEXT: If something is round then it needs the rabbit.
FOL: all x. (Round(x) -> Needs(x, Rabbit))

TEXT: If something chases the bear then it sees the rabbit.
FOL: all x. (Chases(x, Bear) -> Sees(x, Rabbit))

TEXT: If the lion is red and the lion needs the bear then the bear chases the lion.
FOL: (Red(Lion) & Needs(Lion, Bear)) -> Chases(Bear, Lion)

TEXT: The rabbit needs the rabbit.
FOL: Needs(Rabbit, Rabbit)
Processed: True

Generation 3:
TEXT: The bear chases the rabbit.
FOL: Chases(Bear, Rabbit)
TEXT: The bear chases the tiger.
FOL: Chases(Bear, Tiger)
TEXT: The bear is red.
FOL: Red(Bear)
TEXT: The bear needs the lion.
FOL: Needs(Bear, Lion)
TEXT: The bear needs the rabbit.
FOL: Needs(Bear, Rabbit)
TEXT: The bear sees the lion.
FOL: Sees(Bear, Lion)
TEXT: The lion is nice.
FOL: Nice(Lion)
TEXT: The lion is red.
FOL: Red(Lion)
TEXT: The lion is round.
FOL: Round(Lion)
TEXT: The lion sees the bear.
FOL: Sees(Lion, Bear)
TEXT: The rabbit chases the tiger.
FOL: Chases(Rabbit, Tiger)
TEXT: The rabbit is round.
FOL: Round(Rabbit)
TEXT: The rabbit is young.
FOL: Young(Rabbit)
TEXT: The tiger chases the rabbit.
FOL: Chases(Tiger, Rabbit)
TEXT: The tiger is round.
FOL: Round(Tiger)
TEXT: The tiger sees the bear.
FOL: Sees(Tiger, Bear)
TEXT: If something sees the tiger then it sees the bear.
FOL: all x. (Sees(x, Tiger) -> Sees(x, Bear))
TEXT: If something chases the tiger and the tiger is red then it is round.
FOL: all x. ((Chases(x, Tiger) & Red(Tiger)) -> Round(x))
TEXT: If the bear needs the tiger then the tiger needs the lion.
FOL: Needs(Bear, Tiger) -> Needs(Tiger, Lion)
TEXT: If something sees the rabbit then the rabbit sees the lion.
FOL: all x. (Sees(x, Rabbit) -> Sees(Rabbit, Lion))
TEXT: If something is round then it needs the rabbit.
FOL: all x. (Round(x) -> Needs(x, Rabbit))
TEXT: If something chases the bear then it sees the rabbit.
FOL: all x. (Chases(x, Bear) -> Sees(x, Rabbit))
TEXT: If the lion is red and the lion needs the bear then the bear chases the lion.
FOL: (Red(Lion) & Needs(Lion, Bear)) -> Chases(Bear, Lion)
TEXT: If something sees the lion then it chases the bear.
FOL: all x. (Sees(x, Lion) -> Chases(x, Bear))
TEXT: The rabbit needs the rabbit.
FOL: Needs(Rabbit, Rabbit)
Processed: True

Reference: True
========================================

=== Example 92 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The cat eats the rabbit.
The cat is round.
The cat likes the dog.
The cat needs the dog.
The dog eats the cat.
The dog is big.
The dog likes the cat.
The dog likes the rabbit.
The dog needs the mouse.
The mouse eats the cat.
The mouse needs the cat.
The rabbit eats the cat.
The rabbit is big.
The rabbit is rough.
The rabbit needs the cat.
The rabbit needs the dog.
If something likes the dog then the dog eats the cat.
If the dog is rough then the dog eats the cat.
If something eats the cat and the cat likes the rabbit then it is big.
If something is kind then it likes the cat.
If something likes the rabbit and the rabbit eats the cat then the cat is big.
If the rabbit is big then the rabbit eats the cat.
If something needs the cat then it is round.
If something is big then it likes the rabbit.
If something likes the rabbit then it is rough.
</PREMISES>
<CONCLUSION>
The mouse likes the cat.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The cat eats the rabbit.
FOL: Eats(Cat, Rabbit)
TEXT: The cat is round.
FOL: IsRound(Cat)
TEXT: The cat likes the dog.
FOL: Likes(Cat, Dog)
TEXT: The cat needs the dog.
FOL: Needs(Cat, Dog)
TEXT: The dog eats the cat.
FOL: Eats(Dog, Cat)
TEXT: The dog is big.
FOL: IsBig(Dog)
TEXT: The dog likes the cat.
FOL: Likes(Dog, Cat)
TEXT: The dog likes the rabbit.
FOL: Likes(Dog, Rabbit)
TEXT: The dog needs the mouse.
FOL: Needs(Dog, Mouse)
TEXT: The mouse eats the cat.
FOL: Eats(Mouse, Cat)
TEXT: The mouse needs the cat.
FOL: Needs(Mouse, Cat)
TEXT: The rabbit eats the cat.
FOL: Eats(Rabbit, Cat)
TEXT: The rabbit is big.
FOL: IsBig(Rabbit)
TEXT: The rabbit is rough.
FOL: IsRough(Rabbit)
TEXT: The rabbit needs the cat.
FOL: Needs(Rabbit, Cat)
TEXT: The rabbit needs the dog.
FOL: Needs(Rabbit, Dog)
TEXT: If something likes the dog then the dog eats the cat.
FOL: all x. (Likes(x, Dog) -> Eats(Dog, Cat))
TEXT: If the dog is rough then the dog eats the cat.
FOL: IsRough(Dog) -> Eats(Dog, Cat)
TEXT: If something eats the cat and the cat likes the rabbit then it is big.
FOL: all x. (Eats(x, Cat) & Likes(Cat, Rabbit) -> IsBig(x))
TEXT: If something is kind then it likes the cat.
FOL: all x. (IsKind(x) -> Likes(x, Cat))
TEXT: If something likes the rabbit and the rabbit eats the cat then the cat is big.
FOL: all x. (Likes(x, Rabbit) & Eats(Rabbit, Cat) -> IsBig(Cat))
TEXT: If the rabbit is big then the rabbit eats the cat.
FOL: IsBig(Rabbit) -> Eats(Rabbit, Cat)
TEXT: If something needs the cat then it is round.
FOL: all x. (Needs(x, Cat) -> IsRound(x))
TEXT: If something is big then it likes the rabbit.
FOL: all x. (IsBig(x) -> Likes(x, Rabbit))
TEXT: If something likes the rabbit then it is rough.
FOL: all x. (Likes(x, Rabbit) -> IsRough(x))
TEXT: The mouse likes the cat.
FOL: Likes(Mouse, Cat)
</EVALUATE>
Processed: Uncertain

Generation 2:
TEXT: The cat eats the rabbit.
FOL: Eats(Cat, Rabbit)
TEXT: The cat is round.
FOL: Round(Cat)
TEXT: The cat likes the dog.
FOL: Likes(Cat, Dog)
TEXT: The cat needs the dog.
FOL: Needs(Cat, Dog)
TEXT: The dog eats the cat.
FOL: Eats(Dog, Cat)
TEXT: The dog is big.
FOL: Big(Dog)
TEXT: The dog likes the cat.
FOL: Likes(Dog, Cat)
TEXT: The dog likes the rabbit.
FOL: Likes(Dog, Rabbit)
TEXT: The dog needs the mouse.
FOL: Needs(Dog, Mouse)
TEXT: The mouse eats the cat.
FOL: Eats(Mouse, Cat)
TEXT: The mouse needs the cat.
FOL: Needs(Mouse, Cat)
TEXT: The rabbit eats the cat.
FOL: Eats(Rabbit, Cat)
TEXT: The rabbit is big.
FOL: Big(Rabbit)
TEXT: The rabbit is rough.
FOL: Rough(Rabbit)
TEXT: The rabbit needs the cat.
FOL: Needs(Rabbit, Cat)
TEXT: The rabbit needs the dog.
FOL: Needs(Rabbit, Dog)
TEXT: If something likes the dog then the dog eats the cat.
FOL: all x. (Likes(x, Dog) -> Eats(Dog, Cat))
TEXT: If the dog is rough then the dog eats the cat.
FOL: Rough(Dog) -> Eats(Dog, Cat)
TEXT: If something eats the cat and the cat likes the rabbit then it is big.
FOL: all x. ((Eats(x, Cat) & Likes(Cat, Rabbit)) -> Big(x))
TEXT: If something is kind then it likes the cat.
FOL: all x. (Kind(x) -> Likes(x, Cat))
TEXT: If something likes the rabbit and the rabbit eats the cat then the cat is big.
FOL: all x. ((Likes(x, Rabbit) & Eats(Rabbit, Cat)) -> Big(Cat))
TEXT: If the rabbit is big then the rabbit eats the cat.
FOL: Big(Rabbit) -> Eats(Rabbit, Cat)
TEXT: If something needs the cat then it is round.
FOL: all x. (Needs(x, Cat) -> Round(x))
TEXT: If something is big then it likes the rabbit.
FOL: all x. (Big(x) -> Likes(x, Rabbit))
TEXT: If something likes the rabbit then it is rough.
FOL: all x. (Likes(x, Rabbit) -> Rough(x))
TEXT: The mouse likes the cat.
FOL: Likes(Mouse, Cat)
Processed: Uncertain

Generation 3:
TEXT: The cat eats the rabbit.
FOL: Eats(Cat, Rabbit)

TEXT: The cat is round.
FOL: IsRound(Cat)

TEXT: The cat likes the dog.
FOL: Likes(Cat, Dog)

TEXT: The cat needs the dog.
FOL: Needs(Cat, Dog)

TEXT: The dog eats the cat.
FOL: Eats(Dog, Cat)

TEXT: The dog is big.
FOL: IsBig(Dog)

TEXT: The dog likes the cat.
FOL: Likes(Dog, Cat)

TEXT: The dog likes the rabbit.
FOL: Likes(Dog, Rabbit)

TEXT: The dog needs the mouse.
FOL: Needs(Dog, Mouse)

TEXT: The mouse eats the cat.
FOL: Eats(Mouse, Cat)

TEXT: The mouse needs the cat.
FOL: Needs(Mouse, Cat)

TEXT: The rabbit eats the cat.
FOL: Eats(Rabbit, Cat)

TEXT: The rabbit is big.
FOL: IsBig(Rabbit)

TEXT: The rabbit is rough.
FOL: IsRough(Rabbit)

TEXT: The rabbit needs the cat.
FOL: Needs(Rabbit, Cat)

TEXT: The rabbit needs the dog.
FOL: Needs(Rabbit, Dog)

TEXT: If something likes the dog then the dog eats the cat.
FOL: all x. (Likes(x, Dog) -> Eats(Dog, Cat))

TEXT: If the dog is rough then the dog eats the cat.
FOL: IsRough(Dog) -> Eats(Dog, Cat)

TEXT: If something eats the cat and the cat likes the rabbit then it is big.
FOL: all x. ((Eats(x, Cat) & Likes(Cat, Rabbit)) -> IsBig(x))

TEXT: If something is kind then it likes the cat.
FOL: all x. (IsKind(x) -> Likes(x, Cat))

TEXT: If something likes the rabbit and the rabbit eats the cat then the cat is big.
FOL: all x. ((Likes(x, Rabbit) & Eats(Rabbit, Cat)) -> IsBig(Cat))

TEXT: If the rabbit is big then the rabbit eats the cat.
FOL: IsBig(Rabbit) -> Eats(Rabbit, Cat)

TEXT: If something needs the cat then it is round.
FOL: all x. (Needs(x, Cat) -> IsRound(x))

TEXT: If something is big then it likes the rabbit.
FOL: all x. (IsBig(x) -> Likes(x, Rabbit))

TEXT: If something likes the rabbit then it is rough.
FOL: all x. (Likes(x, Rabbit) -> IsRough(x))

TEXT: The mouse likes the cat.
FOL: Likes(Mouse, Cat)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 93 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is green.
Bob is rough.
Bob is white.
Charlie is rough.
Dave is quiet.
Gary is cold.
Gary is rough.
All quiet, kind people are young.
If Charlie is quiet and Charlie is young then Charlie is kind.
All green, white people are cold.
All quiet people are rough.
All rough, green people are white.
All young people are green.
Rough people are young.
</PREMISES>
<CONCLUSION>
Dave is not young.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is green.
FOL: Green(Bob)
TEXT: Bob is rough.
FOL: Rough(Bob)
TEXT: Bob is white.
FOL: White(Bob)
TEXT: Charlie is rough.
FOL: Rough(Charlie)
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Gary is cold.
FOL: Cold(Gary)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: All quiet, kind people are young.
FOL: all x. (Quiet(x) & Kind(x) -> Young(x))
TEXT: If Charlie is quiet and Charlie is young then Charlie is kind.
FOL: (Quiet(Charlie) & Young(Charlie) -> Kind(Charlie))
TEXT: All green, white people are cold.
FOL: all x. (Green(x) & White(x) -> Cold(x))
TEXT: All quiet people are rough.
FOL: all x. (Quiet(x) -> Rough(x))
TEXT: All rough, green people are white.
FOL: all x. (Rough(x) & Green(x) -> White(x))
TEXT: All young people are green.
FOL: all x. (Young(x) -> Green(x))
TEXT: Rough people are young.
FOL: all x. (Rough(x) -> Young(x))
TEXT: Dave is not young.
FOL: -Young(Dave)
Processed: False

Generation 2:
TEXT: Bob is green.
FOL: Green(Bob)
TEXT: Bob is rough.
FOL: Rough(Bob)
TEXT: Bob is white.
FOL: White(Bob)
TEXT: Charlie is rough.
FOL: Rough(Charlie)
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Gary is cold.
FOL: Cold(Gary)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: All quiet, kind people are young.
FOL: all x. (Quiet(x) & Kind(x) -> Young(x))
TEXT: If Charlie is quiet and Charlie is young then Charlie is kind.
FOL: (Quiet(Charlie) & Young(Charlie)) -> Kind(Charlie)
TEXT: All green, white people are cold.
FOL: all x. (Green(x) & White(x) -> Cold(x))
TEXT: All quiet people are rough.
FOL: all x. (Quiet(x) -> Rough(x))
TEXT: All rough, green people are white.
FOL: all x. (Rough(x) & Green(x) -> White(x))
TEXT: All young people are green.
FOL: all x. (Young(x) -> Green(x))
TEXT: Rough people are young.
FOL: all x. (Rough(x) -> Young(x))
TEXT: Dave is not young.
FOL: -Young(Dave)
Processed: False

Generation 3:
TEXT: Bob is green.
FOL: Green(Bob)
TEXT: Bob is rough.
FOL: Rough(Bob)
TEXT: Bob is white.
FOL: White(Bob)
TEXT: Charlie is rough.
FOL: Rough(Charlie)
TEXT: Dave is quiet.
FOL: Quiet(Dave)
TEXT: Gary is cold.
FOL: Cold(Gary)
TEXT: Gary is rough.
FOL: Rough(Gary)
TEXT: All quiet, kind people are young.
FOL: all x. (Quiet(x) & Kind(x) -> Young(x))
TEXT: If Charlie is quiet and Charlie is young then Charlie is kind.
FOL: (Quiet(Charlie) & Young(Charlie) -> Kind(Charlie))
TEXT: All green, white people are cold.
FOL: all x. (Green(x) & White(x) -> Cold(x))
TEXT: All quiet people are rough.
FOL: all x. (Quiet(x) -> Rough(x))
TEXT: All rough, green people are white.
FOL: all x. (Rough(x) & Green(x) -> White(x))
TEXT: All young people are green.
FOL: all x. (Young(x) -> Green(x))
TEXT: Rough people are young.
FOL: all x. (Rough(x) -> Young(x))
TEXT: Dave is not young.
FOL: -Young(Dave)
</EVALUATE>
Processed: False

Reference: False
========================================

=== Example 94 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle chases the dog.
The bald eagle eats the dog.
The bald eagle is big.
The bald eagle likes the bear.
The bear eats the dog.
The bear is kind.
The dog chases the tiger.
The dog eats the bald eagle.
The dog is kind.
The tiger chases the bear.
The tiger eats the bear.
The tiger is big.
The tiger is round.
The tiger is young.
If someone is kind then they chase the bald eagle.
If someone chases the bear and the bear likes the tiger then they eat the bald eagle.
If someone is kind then they eat the bald eagle.
If someone likes the dog then they like the tiger.
If someone likes the tiger then they are young.
If someone eats the dog then the dog is big.
If someone eats the bald eagle then they like the dog.
If someone likes the dog and they do not chase the tiger then the dog chases the bald eagle.
</PREMISES>
<CONCLUSION>
The dog does not like the tiger.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle chases the dog.
FOL: Chases(BaldEagle, Dog)

TEXT: The bald eagle eats the dog.
FOL: Eats(BaldEagle, Dog)

TEXT: The bald eagle is big.
FOL: Big(BaldEagle)

TEXT: The bald eagle likes the bear.
FOL: Likes(BaldEagle, Bear)

TEXT: The bear eats the dog.
FOL: Eats(Bear, Dog)

TEXT: The bear is kind.
FOL: Kind(Bear)

TEXT: The dog chases the tiger.
FOL: Chases(Dog, Tiger)

TEXT: The dog eats the bald eagle.
FOL: Eats(Dog, BaldEagle)

TEXT: The dog is kind.
FOL: Kind(Dog)

TEXT: The tiger chases the bear.
FOL: Chases(Tiger, Bear)

TEXT: The tiger eats the bear.
FOL: Eats(Tiger, Bear)

TEXT: The tiger is big.
FOL: Big(Tiger)

TEXT: The tiger is round.
FOL: Round(Tiger)

TEXT: The tiger is young.
FOL: Young(Tiger)

TEXT: If someone is kind then they chase the bald eagle.
FOL: all x. (Kind(x) -> Chases(x, BaldEagle))

TEXT: If someone chases the bear and the bear likes the tiger then they eat the bald eagle.
FOL: all x. ((Chases(x, Bear) & Likes(Bear, Tiger)) -> Eats(x, BaldEagle))

TEXT: If someone is kind then they eat the bald eagle.
FOL: all x. (Kind(x) -> Eats(x, BaldEagle))

TEXT: If someone likes the dog then they like the tiger.
FOL: all x. (Likes(x, Dog) -> Likes(x, Tiger))

TEXT: If someone likes the tiger then they are young.
FOL: all x. (Likes(x, Tiger) -> Young(x))

TEXT: If someone eats the dog then the dog is big.
FOL: all x. (Eats(x, Dog) -> Big(Dog))

TEXT: If someone eats the bald eagle then they like the dog.
FOL: all x. (Eats(x, BaldEagle) -> Likes(x, Dog))

TEXT: If someone likes the dog and they do not chase the tiger then the dog chases the bald eagle.
FOL: all x. ((Likes(x, Dog) & -Chases(x, Tiger)) -> Chases(Dog, BaldEagle))

TEXT: The dog does not like the tiger.
FOL: -Likes(Dog, Tiger)
Processed: False

Generation 2:
TEXT: The bald eagle chases the dog.
FOL: Chases(BaldEagle, Dog)
TEXT: The bald eagle eats the dog.
FOL: Eats(BaldEagle, Dog)
TEXT: The bald eagle is big.
FOL: Big(BaldEagle)
TEXT: The bald eagle likes the bear.
FOL: Likes(BaldEagle, Bear)
TEXT: The bear eats the dog.
FOL: Eats(Bear, Dog)
TEXT: The bear is kind.
FOL: Kind(Bear)
TEXT: The dog chases the tiger.
FOL: Chases(Dog, Tiger)
TEXT: The dog eats the bald eagle.
FOL: Eats(Dog, BaldEagle)
TEXT: The dog is kind.
FOL: Kind(Dog)
TEXT: The tiger chases the bear.
FOL: Chases(Tiger, Bear)
TEXT: The tiger eats the bear.
FOL: Eats(Tiger, Bear)
TEXT: The tiger is big.
FOL: Big(Tiger)
TEXT: The tiger is round.
FOL: Round(Tiger)
TEXT: The tiger is young.
FOL: Young(Tiger)
TEXT: If someone is kind then they chase the bald eagle.
FOL: all x. (Kind(x) -> Chases(x, BaldEagle))
TEXT: If someone chases the bear and the bear likes the tiger then they eat the bald eagle.
FOL: all x. ((Chases(x, Bear) & Likes(Bear, Tiger)) -> Eats(x, BaldEagle))
TEXT: If someone is kind then they eat the bald eagle.
FOL: all x. (Kind(x) -> Eats(x, BaldEagle))
TEXT: If someone likes the dog then they like the tiger.
FOL: all x. (Likes(x, Dog) -> Likes(x, Tiger))
TEXT: If someone likes the tiger then they are young.
FOL: all x. (Likes(x, Tiger) -> Young(x))
TEXT: If someone eats the dog then the dog is big.
FOL: all x. (Eats(x, Dog) -> Big(Dog))
TEXT: If someone eats the bald eagle then they like the dog.
FOL: all x. (Eats(x, BaldEagle) -> Likes(x, Dog))
TEXT: If someone likes the dog and they do not chase the tiger then the dog chases the bald eagle.
FOL: all x. ((Likes(x, Dog) & -Chases(x, Tiger)) -> Chases(Dog, BaldEagle))
TEXT: The dog does not like the tiger.
FOL: -Likes(Dog, Tiger)
Processed: False

Generation 3:
TEXT: The bald eagle chases the dog.
FOL: Chases(BaldEagle, Dog)

TEXT: The bald eagle eats the dog.
FOL: Eats(BaldEagle, Dog)

TEXT: The bald eagle is big.
FOL: Big(BaldEagle)

TEXT: The bald eagle likes the bear.
FOL: Likes(BaldEagle, Bear)

TEXT: The bear eats the dog.
FOL: Eats(Bear, Dog)

TEXT: The bear is kind.
FOL: Kind(Bear)

TEXT: The dog chases the tiger.
FOL: Chases(Dog, Tiger)

TEXT: The dog eats the bald eagle.
FOL: Eats(Dog, BaldEagle)

TEXT: The dog is kind.
FOL: Kind(Dog)

TEXT: The tiger chases the bear.
FOL: Chases(Tiger, Bear)

TEXT: The tiger eats the bear.
FOL: Eats(Tiger, Bear)

TEXT: The tiger is big.
FOL: Big(Tiger)

TEXT: The tiger is round.
FOL: Round(Tiger)

TEXT: The tiger is young.
FOL: Young(Tiger)

TEXT: If someone is kind then they chase the bald eagle.
FOL: all x. (Kind(x) -> Chases(x, BaldEagle))

TEXT: If someone chases the bear and the bear likes the tiger then they eat the bald eagle.
FOL: all x. ((Chases(x, Bear) & Likes(Bear, Tiger)) -> Eats(x, BaldEagle))

TEXT: If someone is kind then they eat the bald eagle.
FOL: all x. (Kind(x) -> Eats(x, BaldEagle))

TEXT: If someone likes the dog then they like the tiger.
FOL: all x. (Likes(x, Dog) -> Likes(x, Tiger))

TEXT: If someone likes the tiger then they are young.
FOL: all x. (Likes(x, Tiger) -> Young(x))

TEXT: If someone eats the dog then the dog is big.
FOL: all x. (Eats(x, Dog) -> Big(Dog))

TEXT: If someone eats the bald eagle then they like the dog.
FOL: all x. (Eats(x, BaldEagle) -> Likes(x, Dog))

TEXT: If someone likes the dog and they do not chase the tiger then the dog chases the bald eagle.
FOL: all x. ((Likes(x, Dog) & -Chases(x, Tiger)) -> Chases(Dog, BaldEagle))

TEXT: The dog does not like the tiger.
FOL: -Likes(Dog, Tiger)
Processed: False

Reference: False
========================================

=== Example 95 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is furry.
Bob is nice.
Bob is rough.
Fiona is red.
Gary is furry.
Gary is not white.
Harry is nice.
If Fiona is furry then Fiona is nice.
If Fiona is nice and Fiona is red then Fiona is furry.
All white things are red.
All white things are furry.
If something is big then it is white.
All nice things are big.
If something is furry then it is quiet.
If Fiona is not nice and Fiona is not furry then Fiona is quiet.
Big, quiet things are rough.
</PREMISES>
<CONCLUSION>
Harry is rough.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is furry.
FOL: Furry(Bob)
TEXT: Bob is nice.
FOL: Nice(Bob)
TEXT: Bob is rough.
FOL: Rough(Bob)
TEXT: Fiona is red.
FOL: Red(Fiona)
TEXT: Gary is furry.
FOL: Furry(Gary)
TEXT: Gary is not white.
FOL: -White(Gary)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: If Fiona is furry then Fiona is nice.
FOL: Furry(Fiona) -> Nice(Fiona)
TEXT: If Fiona is nice and Fiona is red then Fiona is furry.
FOL: (Nice(Fiona) & Red(Fiona)) -> Furry(Fiona)
TEXT: All white things are red.
FOL: all x. (White(x) -> Red(x))
TEXT: All white things are furry.
FOL: all x. (White(x) -> Furry(x))
TEXT: If something is big then it is white.
FOL: all x. (Big(x) -> White(x))
TEXT: All nice things are big.
FOL: all x. (Nice(x) -> Big(x))
TEXT: If something is furry then it is quiet.
FOL: all x. (Furry(x) -> Quiet(x))
TEXT: If Fiona is not nice and Fiona is not furry then Fiona is quiet.
FOL: (-Nice(Fiona) & -Furry(Fiona)) -> Quiet(Fiona)
TEXT: Big, quiet things are rough.
FOL: all x. ((Big(x) & Quiet(x)) -> Rough(x))
TEXT: Harry is rough.
FOL: Rough(Harry)
Processed: True

Generation 2:
TEXT: Bob is furry.
FOL: Furry(Bob)
TEXT: Bob is nice.
FOL: Nice(Bob)
TEXT: Bob is rough.
FOL: Rough(Bob)
TEXT: Fiona is red.
FOL: Red(Fiona)
TEXT: Gary is furry.
FOL: Furry(Gary)
TEXT: Gary is not white.
FOL: -White(Gary)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: If Fiona is furry then Fiona is nice.
FOL: (Furry(Fiona) -> Nice(Fiona))
TEXT: If Fiona is nice and Fiona is red then Fiona is furry.
FOL: ((Nice(Fiona) & Red(Fiona)) -> Furry(Fiona))
TEXT: All white things are red.
FOL: all x. (White(x) -> Red(x))
TEXT: All white things are furry.
FOL: all x. (White(x) -> Furry(x))
TEXT: If something is big then it is white.
FOL: all x. (Big(x) -> White(x))
TEXT: All nice things are big.
FOL: all x. (Nice(x) -> Big(x))
TEXT: If something is furry then it is quiet.
FOL: all x. (Furry(x) -> Quiet(x))
TEXT: If Fiona is not nice and Fiona is not furry then Fiona is quiet.
FOL: ((-Nice(Fiona) & -Furry(Fiona)) -> Quiet(Fiona))
TEXT: Big, quiet things are rough.
FOL: all x. ((Big(x) & Quiet(x)) -> Rough(x))
TEXT: Harry is rough.
FOL: Rough(Harry)
Processed: True

Generation 3:
TEXT: Bob is furry.
FOL: Furry(Bob)
TEXT: Bob is nice.
FOL: Nice(Bob)
TEXT: Bob is rough.
FOL: Rough(Bob)
TEXT: Fiona is red.
FOL: Red(Fiona)
TEXT: Gary is furry.
FOL: Furry(Gary)
TEXT: Gary is not white.
FOL: -White(Gary)
TEXT: Harry is nice.
FOL: Nice(Harry)
TEXT: If Fiona is furry then Fiona is nice.
FOL: Furry(Fiona) -> Nice(Fiona)
TEXT: If Fiona is nice and Fiona is red then Fiona is furry.
FOL: (Nice(Fiona) & Red(Fiona)) -> Furry(Fiona)
TEXT: All white things are red.
FOL: all x. (White(x) -> Red(x))
TEXT: All white things are furry.
FOL: all x. (White(x) -> Furry(x))
TEXT: If something is big then it is white.
FOL: all x. (Big(x) -> White(x))
TEXT: All nice things are big.
FOL: all x. (Nice(x) -> Big(x))
TEXT: If something is furry then it is quiet.
FOL: all x. (Furry(x) -> Quiet(x))
TEXT: If Fiona is not nice and Fiona is not furry then Fiona is quiet.
FOL: (-Nice(Fiona) & -Furry(Fiona)) -> Quiet(Fiona)
TEXT: Big, quiet things are rough.
FOL: all x. (Big(x) & Quiet(x)) -> Rough(x)
TEXT: Harry is rough.
FOL: Rough(Harry)
</EVALUATE>
Processed: Uncertain

Reference: True
========================================

=== Example 96 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The cow chases the rabbit.
The cow needs the squirrel.
The dog chases the rabbit.
The dog needs the cow.
The dog sees the cow.
The rabbit chases the cow.
The rabbit chases the squirrel.
The rabbit needs the cow.
The rabbit needs the dog.
The rabbit needs the squirrel.
The rabbit sees the dog.
The squirrel chases the rabbit.
The squirrel needs the rabbit.
The squirrel sees the dog.
If something needs the dog and the dog needs the squirrel then the squirrel is nice.
If something is green and nice then it needs the cow.
Nice things are green.
If something is green then it chases the cow.
If something needs the cow then it sees the squirrel.
If something is kind and it sees the dog then the dog needs the cow.
If something sees the rabbit then it needs the squirrel.
If something needs the cow then it needs the squirrel.
</PREMISES>
<CONCLUSION>
The squirrel sees the squirrel.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)
TEXT: The cow needs the squirrel.
FOL: Needs(Cow, Squirrel)
TEXT: The dog chases the rabbit.
FOL: Chases(Dog, Rabbit)
TEXT: The dog needs the cow.
FOL: Needs(Dog, Cow)
TEXT: The dog sees the cow.
FOL: Sees(Dog, Cow)
TEXT: The rabbit chases the cow.
FOL: Chases(Rabbit, Cow)
TEXT: The rabbit chases the squirrel.
FOL: Chases(Rabbit, Squirrel)
TEXT: The rabbit needs the cow.
FOL: Needs(Rabbit, Cow)
TEXT: The rabbit needs the dog.
FOL: Needs(Rabbit, Dog)
TEXT: The rabbit needs the squirrel.
FOL: Needs(Rabbit, Squirrel)
TEXT: The rabbit sees the dog.
FOL: Sees(Rabbit, Dog)
TEXT: The squirrel chases the rabbit.
FOL: Chases(Squirrel, Rabbit)
TEXT: The squirrel needs the rabbit.
FOL: Needs(Squirrel, Rabbit)
TEXT: The squirrel sees the dog.
FOL: Sees(Squirrel, Dog)
TEXT: If something needs the dog and the dog needs the squirrel then the squirrel is nice.
FOL: all x. (Needs(x, Dog) & Needs(Dog, Squirrel) -> Nice(Squirrel))
TEXT: If something is green and nice then it needs the cow.
FOL: all x. (Green(x) & Nice(x) -> Needs(x, Cow))
TEXT: Nice things are green.
FOL: all x. (Nice(x) -> Green(x))
TEXT: If something is green then it chases the cow.
FOL: all x. (Green(x) -> Chases(x, Cow))
TEXT: If something needs the cow then it sees the squirrel.
FOL: all x. (Needs(x, Cow) -> Sees(x, Squirrel))
TEXT: If something is kind and it sees the dog then the dog needs the cow.
FOL: all x. (Kind(x) & Sees(x, Dog) -> Needs(Dog, Cow))
TEXT: If something sees the rabbit then it needs the squirrel.
FOL: all x. (Sees(x, Rabbit) -> Needs(x, Squirrel))
TEXT: If something needs the cow then it needs the squirrel.
FOL: all x. (Needs(x, Cow) -> Needs(x, Squirrel))
TEXT: The squirrel sees the squirrel.
FOL: Sees(Squirrel, Squirrel)
Processed: True

Generation 2:
TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)
TEXT: The cow needs the squirrel.
FOL: Needs(Cow, Squirrel)
TEXT: The dog chases the rabbit.
FOL: Chases(Dog, Rabbit)
TEXT: The dog needs the cow.
FOL: Needs(Dog, Cow)
TEXT: The dog sees the cow.
FOL: Sees(Dog, Cow)
TEXT: The rabbit chases the cow.
FOL: Chases(Rabbit, Cow)
TEXT: The rabbit chases the squirrel.
FOL: Chases(Rabbit, Squirrel)
TEXT: The rabbit needs the cow.
FOL: Needs(Rabbit, Cow)
TEXT: The rabbit needs the dog.
FOL: Needs(Rabbit, Dog)
TEXT: The rabbit needs the squirrel.
FOL: Needs(Rabbit, Squirrel)
TEXT: The rabbit sees the dog.
FOL: Sees(Rabbit, Dog)
TEXT: The squirrel chases the rabbit.
FOL: Chases(Squirrel, Rabbit)
TEXT: The squirrel needs the rabbit.
FOL: Needs(Squirrel, Rabbit)
TEXT: The squirrel sees the dog.
FOL: Sees(Squirrel, Dog)
TEXT: If something needs the dog and the dog needs the squirrel then the squirrel is nice.
FOL: all x. (Needs(x, Dog) & Needs(Dog, Squirrel) -> Nice(Squirrel))
TEXT: If something is green and nice then it needs the cow.
FOL: all x. (Green(x) & Nice(x) -> Needs(x, Cow))
TEXT: Nice things are green.
FOL: all x. (Nice(x) -> Green(x))
TEXT: If something is green then it chases the cow.
FOL: all x. (Green(x) -> Chases(x, Cow))
TEXT: If something needs the cow then it sees the squirrel.
FOL: all x. (Needs(x, Cow) -> Sees(x, Squirrel))
TEXT: If something is kind and it sees the dog then the dog needs the cow.
FOL: all x. (Kind(x) & Sees(x, Dog) -> Needs(Dog, Cow))
TEXT: If something sees the rabbit then it needs the squirrel.
FOL: all x. (Sees(x, Rabbit) -> Needs(x, Squirrel))
TEXT: If something needs the cow then it needs the squirrel.
FOL: all x. (Needs(x, Cow) -> Needs(x, Squirrel))
TEXT: The squirrel sees the squirrel.
FOL: Sees(Squirrel, Squirrel)
Processed: True

Generation 3:
TEXT: The cow chases the rabbit.
FOL: Chases(Cow, Rabbit)
TEXT: The cow needs the squirrel.
FOL: Needs(Cow, Squirrel)
TEXT: The dog chases the rabbit.
FOL: Chases(Dog, Rabbit)
TEXT: The dog needs the cow.
FOL: Needs(Dog, Cow)
TEXT: The dog sees the cow.
FOL: Sees(Dog, Cow)
TEXT: The rabbit chases the cow.
FOL: Chases(Rabbit, Cow)
TEXT: The rabbit chases the squirrel.
FOL: Chases(Rabbit, Squirrel)
TEXT: The rabbit needs the cow.
FOL: Needs(Rabbit, Cow)
TEXT: The rabbit needs the dog.
FOL: Needs(Rabbit, Dog)
TEXT: The rabbit needs the squirrel.
FOL: Needs(Rabbit, Squirrel)
TEXT: The rabbit sees the dog.
FOL: Sees(Rabbit, Dog)
TEXT: The squirrel chases the rabbit.
FOL: Chases(Squirrel, Rabbit)
TEXT: The squirrel needs the rabbit.
FOL: Needs(Squirrel, Rabbit)
TEXT: The squirrel sees the dog.
FOL: Sees(Squirrel, Dog)
TEXT: If something needs the dog and the dog needs the squirrel then the squirrel is nice.
FOL: all x. (Needs(x, Dog) & Needs(Dog, Squirrel) -> Nice(Squirrel))
TEXT: If something is green and nice then it needs the cow.
FOL: all x. (Green(x) & Nice(x) -> Needs(x, Cow))
TEXT: Nice things are green.
FOL: all x. (Nice(x) -> Green(x))
TEXT: If something is green then it chases the cow.
FOL: all x. (Green(x) -> Chases(x, Cow))
TEXT: If something needs the cow then it sees the squirrel.
FOL: all x. (Needs(x, Cow) -> Sees(x, Squirrel))
TEXT: If something is kind and it sees the dog then the dog needs the cow.
FOL: all x. (Kind(x) & Sees(x, Dog) -> Needs(Dog, Cow))
TEXT: If something sees the rabbit then it needs the squirrel.
FOL: all x. (Sees(x, Rabbit) -> Needs(x, Squirrel))
TEXT: If something needs the cow then it needs the squirrel.
FOL: all x. (Needs(x, Cow) -> Needs(x, Squirrel))
TEXT: The squirrel sees the squirrel.
FOL: Sees(Squirrel, Squirrel)
Processed: True

Reference: True
========================================

=== Example 97 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is not furry.
Bob is young.
Erin is red.
Erin is young.
Fiona is blue.
Harry is blue.
Harry is not rough.
If something is nice and young then it is furry.
If something is blue and not rough then it is furry.
All blue things are furry.
All rough, blue things are nice.
All cold, furry things are nice.
Furry things are cold.
If something is blue and red then it is cold.
Young things are red.
All nice things are young.
</PREMISES>
<CONCLUSION>
Fiona is not furry.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is not furry.
FOL: -Furry(Bob)

TEXT: Bob is young.
FOL: Young(Bob)

TEXT: Erin is red.
FOL: Red(Erin)

TEXT: Erin is young.
FOL: Young(Erin)

TEXT: Fiona is blue.
FOL: Blue(Fiona)

TEXT: Harry is blue.
FOL: Blue(Harry)

TEXT: Harry is not rough.
FOL: -Rough(Harry)

TEXT: If something is nice and young then it is furry.
FOL: all x. (Nice(x) & Young(x) -> Furry(x))

TEXT: If something is blue and not rough then it is furry.
FOL: all x. (Blue(x) & -Rough(x) -> Furry(x))

TEXT: All blue things are furry.
FOL: all x. (Blue(x) -> Furry(x))

TEXT: All rough, blue things are nice.
FOL: all x. (Rough(x) & Blue(x) -> Nice(x))

TEXT: All cold, furry things are nice.
FOL: all x. (Cold(x) & Furry(x) -> Nice(x))

TEXT: Furry things are cold.
FOL: all x. (Furry(x) -> Cold(x))

TEXT: If something is blue and red then it is cold.
FOL: all x. (Blue(x) & Red(x) -> Cold(x))

TEXT: Young things are red.
FOL: all x. (Young(x) -> Red(x))

TEXT: All nice things are young.
FOL: all x. (Nice(x) -> Young(x))

TEXT: Fiona is not furry.
FOL: -Furry(Fiona)
Processed: False

Generation 2:
TEXT: Bob is not furry.
FOL: -Furry(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Erin is red.
FOL: Red(Erin)
TEXT: Erin is young.
FOL: Young(Erin)
TEXT: Fiona is blue.
FOL: Blue(Fiona)
TEXT: Harry is blue.
FOL: Blue(Harry)
TEXT: Harry is not rough.
FOL: -Rough(Harry)
TEXT: If something is nice and young then it is furry.
FOL: all x. (Nice(x) & Young(x) -> Furry(x))
TEXT: If something is blue and not rough then it is furry.
FOL: all x. (Blue(x) & -Rough(x) -> Furry(x))
TEXT: All blue things are furry.
FOL: all x. (Blue(x) -> Furry(x))
TEXT: All rough, blue things are nice.
FOL: all x. (Rough(x) & Blue(x) -> Nice(x))
TEXT: All cold, furry things are nice.
FOL: all x. (Cold(x) & Furry(x) -> Nice(x))
TEXT: Furry things are cold.
FOL: all x. (Furry(x) -> Cold(x))
TEXT: If something is blue and red then it is cold.
FOL: all x. (Blue(x) & Red(x) -> Cold(x))
TEXT: Young things are red.
FOL: all x. (Young(x) -> Red(x))
TEXT: All nice things are young.
FOL: all x. (Nice(x) -> Young(x))
TEXT: Fiona is not furry.
FOL: -Furry(Fiona)
Processed: False

Generation 3:
TEXT: Bob is not furry.
FOL: -Furry(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Erin is red.
FOL: Red(Erin)
TEXT: Erin is young.
FOL: Young(Erin)
TEXT: Fiona is blue.
FOL: Blue(Fiona)
TEXT: Harry is blue.
FOL: Blue(Harry)
TEXT: Harry is not rough.
FOL: -Rough(Harry)
TEXT: If something is nice and young then it is furry.
FOL: all x. (Nice(x) & Young(x) -> Furry(x))
TEXT: If something is blue and not rough then it is furry.
FOL: all x. (Blue(x) & -Rough(x) -> Furry(x))
TEXT: All blue things are furry.
FOL: all x. (Blue(x) -> Furry(x))
TEXT: All rough, blue things are nice.
FOL: all x. (Rough(x) & Blue(x) -> Nice(x))
TEXT: All cold, furry things are nice.
FOL: all x. (Cold(x) & Furry(x) -> Nice(x))
TEXT: Furry things are cold.
FOL: all x. (Furry(x) -> Cold(x))
TEXT: If something is blue and red then it is cold.
FOL: all x. (Blue(x) & Red(x) -> Cold(x))
TEXT: Young things are red.
FOL: all x. (Young(x) -> Red(x))
TEXT: All nice things are young.
FOL: all x. (Nice(x) -> Young(x))
TEXT: Fiona is not furry.
FOL: -Furry(Fiona)
Processed: False

Reference: False
========================================

=== Example 98 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
Bob is furry.
Bob is young.
Charlie is red.
Dave is blue.
Dave is cold.
Dave is furry.
Gary is young.
If Gary is rough and Gary is young then Gary is quiet.
All quiet things are red.
Young, blue things are red.
Furry, rough things are red.
Red things are rough.
All young, rough things are cold.
If something is rough and not young then it is cold.
If something is cold then it is furry.
All young things are quiet.
</PREMISES>
<CONCLUSION>
Dave is not quiet.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: Bob is furry.
FOL: Furry(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Charlie is red.
FOL: Red(Charlie)
TEXT: Dave is blue.
FOL: Blue(Dave)
TEXT: Dave is cold.
FOL: Cold(Dave)
TEXT: Dave is furry.
FOL: Furry(Dave)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: If Gary is rough and Gary is young then Gary is quiet.
FOL: (Rough(Gary) & Young(Gary)) -> Quiet(Gary)
TEXT: All quiet things are red.
FOL: all x. (Quiet(x) -> Red(x))
TEXT: Young, blue things are red.
FOL: all x. (Young(x) & Blue(x) -> Red(x))
TEXT: Furry, rough things are red.
FOL: all x. (Furry(x) & Rough(x) -> Red(x))
TEXT: Red things are rough.
FOL: all x. (Red(x) -> Rough(x))
TEXT: All young, rough things are cold.
FOL: all x. (Young(x) & Rough(x) -> Cold(x))
TEXT: If something is rough and not young then it is cold.
FOL: all x. (Rough(x) & -Young(x) -> Cold(x))
TEXT: If something is cold then it is furry.
FOL: all x. (Cold(x) -> Furry(x))
TEXT: All young things are quiet.
FOL: all x. (Young(x) -> Quiet(x))
TEXT: Dave is not quiet.
FOL: -Quiet(Dave)
Processed: Uncertain

Generation 2:
TEXT: Bob is furry.
FOL: Furry(Bob)

TEXT: Bob is young.
FOL: Young(Bob)

TEXT: Charlie is red.
FOL: Red(Charlie)

TEXT: Dave is blue.
FOL: Blue(Dave)

TEXT: Dave is cold.
FOL: Cold(Dave)

TEXT: Dave is furry.
FOL: Furry(Dave)

TEXT: Gary is young.
FOL: Young(Gary)

TEXT: If Gary is rough and Gary is young then Gary is quiet.
FOL: (Rough(Gary) & Young(Gary)) -> Quiet(Gary)

TEXT: All quiet things are red.
FOL: all x. (Quiet(x) -> Red(x))

TEXT: Young, blue things are red.
FOL: all x. ((Young(x) & Blue(x)) -> Red(x))

TEXT: Furry, rough things are red.
FOL: all x. ((Furry(x) & Rough(x)) -> Red(x))

TEXT: Red things are rough.
FOL: all x. (Red(x) -> Rough(x))

TEXT: All young, rough things are cold.
FOL: all x. ((Young(x) & Rough(x)) -> Cold(x))

TEXT: If something is rough and not young then it is cold.
FOL: all x. ((Rough(x) & -Young(x)) -> Cold(x))

TEXT: If something is cold then it is furry.
FOL: all x. (Cold(x) -> Furry(x))

TEXT: All young things are quiet.
FOL: all x. (Young(x) -> Quiet(x))

TEXT: Dave is not quiet.
FOL: -Quiet(Dave)
Processed: Uncertain

Generation 3:
TEXT: Bob is furry.
FOL: Furry(Bob)
TEXT: Bob is young.
FOL: Young(Bob)
TEXT: Charlie is red.
FOL: Red(Charlie)
TEXT: Dave is blue.
FOL: Blue(Dave)
TEXT: Dave is cold.
FOL: Cold(Dave)
TEXT: Dave is furry.
FOL: Furry(Dave)
TEXT: Gary is young.
FOL: Young(Gary)
TEXT: If Gary is rough and Gary is young then Gary is quiet.
FOL: (Rough(Gary) & Young(Gary)) -> Quiet(Gary)
TEXT: All quiet things are red.
FOL: all x. (Quiet(x) -> Red(x))
TEXT: Young, blue things are red.
FOL: all x. ((Young(x) & Blue(x)) -> Red(x))
TEXT: Furry, rough things are red.
FOL: all x. ((Furry(x) & Rough(x)) -> Red(x))
TEXT: Red things are rough.
FOL: all x. (Red(x) -> Rough(x))
TEXT: All young, rough things are cold.
FOL: all x. ((Young(x) & Rough(x)) -> Cold(x))
TEXT: If something is rough and not young then it is cold.
FOL: all x. ((Rough(x) & -Young(x)) -> Cold(x))
TEXT: If something is cold then it is furry.
FOL: all x. (Cold(x) -> Furry(x))
TEXT: All young things are quiet.
FOL: all x. (Young(x) -> Quiet(x))
TEXT: Dave is not quiet.
FOL: -Quiet(Dave)
Processed: Uncertain

Reference: Uncertain
========================================

=== Example 99 ===
Prompt:
The following is a first-order logic (FOL) problem.
The problem is to determine whether the conclusion follows from the premises.
The premises are given in the form of a set of first-order logic sentences.
The conclusion is given in the form of a single first-order logic sentence.
The task is to translate each of the premises and conclusions into FOL expressions.so that the expressions can be evaluated by a theorem solver like Prover9 to determine whether the conclusion follows from the premises.
Expressions should adhere to the format of the Python NLTK package logic module. The output should follow format TEXT: 
FOL: 
TEXT: 
FOL:...


<PREMISES>
A
l
l
 
b
i
o
d
e
g
r
a
d
a
b
l
e
 
t
h
i
n
g
s
 
a
r
e
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
 


A
l
l
 
w
o
o
d
w
a
r
e
 
i
s
 
b
i
o
d
e
g
r
a
d
a
b
l
e
.


A
l
l
 
p
a
p
e
r
 
i
s
 
w
o
o
d
w
a
r
e
.
 


N
o
t
h
i
n
g
 
i
s
 
a
 
g
o
o
d
 
t
h
i
n
g
 
a
n
d
 
a
l
s
o
 
a
 
b
a
d
 
t
h
i
n
g
.


A
l
l
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
 
t
h
i
n
g
s
 
a
r
e
 
g
o
o
d
.


A
 
w
o
r
k
s
h
e
e
t
 
i
s
 
e
i
t
h
e
r
 
p
a
p
e
r
 
o
r
 
e
n
v
i
r
o
n
m
e
n
t
-
f
r
i
e
n
d
l
y
.
</PREMISES>
<CONCLUSION>
A worksheet is not biodegradable.
</CONCLUSION>
<EVALUATE>
TEXT: All biodegradable things are environment-friendly.
FOL: all x. (Biodegradable(x) -> EnvironmentFriendly(x))
TEXT: All woodware is biodegradable.
FOL: all x. (Woodware(x) -> Biodegradable(x))
TEXT: All paper is woodware.
FOL: all x. (Paper(x) -> Woodware(x))
TEXT: Nothing is a good thing and also a bad thing.
FOL: -(exists x. (Good(x) & Bad(x)))
TEXT: All environment-friendly things are good.
FOL: all x. (EnvironmentFriendly(x) -> Good(x))
TEXT: A worksheet is either paper or environment-friendly.
FOL: ((Paper(Worksheet) & -EnvironmentFriendly(Worksheet)) | (-Paper(Worksheet) & EnvironmentFriendly(Worksheet)))
TEXT: A worksheet is not biodegradable.
FOL: -Dispensable(Worksheet)
</EVALUATE>

<PREMISES>
A
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
r
a
n
k
s
 
h
i
g
h
e
r
 
t
h
a
n
 
a
n
o
t
h
e
r
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
 
i
f
 
i
t
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
.


I
f
 
t
h
e
r
e
 
a
r
e
 
t
w
o
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
 
a
n
d
 
n
e
i
t
h
e
r
 
h
a
s
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
t
h
e
 
o
t
h
e
r
,
 
t
h
e
n
 
t
h
e
 
t
e
a
m
 
w
h
i
c
h
 
r
e
c
e
i
v
e
s
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
 
t
w
o
 
t
e
a
m
s
 
r
a
n
k
s
 
h
i
g
h
e
r
.


R
e
a
l
 
M
a
d
r
i
d
 
a
n
d
 
B
a
r
c
e
l
o
n
a
 
a
r
e
 
b
o
t
h
 
L
a
 
L
i
g
a
 
s
o
c
c
e
r
 
t
e
a
m
s
.


R
e
a
l
 
M
a
d
r
i
d
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
t
h
a
n
 
B
a
r
c
e
l
o
n
a
.


N
e
i
t
h
e
r
 
R
e
a
l
 
M
a
d
r
i
d
 
n
o
r
 
B
a
r
c
e
l
o
n
a
 
r
e
c
e
i
v
e
d
 
m
o
r
e
 
p
o
i
n
t
s
 
f
r
o
m
 
t
h
e
 
g
a
m
e
s
 
b
e
t
w
e
e
n
 
t
h
e
m
.
</PREMISES>
<CONCLUSION>
Real Madrid ranks higher than Barcelona.
</CONCLUSION>
<EVALUATE>
TEXT: A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & MorePoints(x, y) -> RankHigherThan(x, y))
TEXT: If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
FOL: all x. all y. (LaLigaSoccerTeam(x) & LaLigaSoccerTeam(y) & -MorePoints(x, y) & -MorePoints(y, x) & MorePointsInGameBetween(x, y) ->  RankHigherThan(x, y))
TEXT: Real Madrid and Barcelona are both La Liga soccer teams.
FOL: LaLigaSoccerTeam(RealMadrid) & LaLigaSoccerTeam(Barcelona)
TEXT: Real Madrid received more points than Barcelona.
FOL: MorePoints(RealMadrid, Barcelona)
TEXT: Neither Real Madrid nor Barcelona received more points from the games between them.
FOL: -MorePointsInGameBetween(RealMadrid, Barcelona) & -MorePointsInGameBetween(Barcelona, RealMadrid)
TEXT: Real Madrid ranks higher than Barcelona.
FOL: HigherRank(RealMadrid, Barcelona)
</EVALUATE>

<PREMISES>
A
l
l
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
 
s
p
e
n
d
 
m
o
s
t
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
s
 
a
r
e
 
p
r
o
f
e
s
s
i
o
n
a
l
 
a
t
h
l
e
t
e
s
.


N
o
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
 
s
p
e
n
d
 
t
h
e
 
m
a
j
o
r
i
t
y
 
o
f
 
t
h
e
i
r
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
.


A
l
l
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
s
 
a
r
e
 
f
u
l
l
-
t
i
m
e
 
s
c
i
e
n
t
i
s
t
s
.


A
m
y
 
s
p
e
n
d
s
 
t
h
e
 
m
o
s
t
 
t
i
m
e
 
o
n
 
s
p
o
r
t
s
,
 
o
r
 
A
m
y
 
i
s
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.


I
f
 
A
m
y
 
i
s
 
n
o
t
 
a
 
N
o
b
e
l
 
p
h
y
s
i
c
s
 
l
a
u
r
e
a
t
e
,
 
t
h
e
n
 
A
m
y
 
i
s
 
n
o
t
 
a
n
 
O
l
y
m
p
i
c
 
g
o
l
d
 
m
e
d
a
l
 
w
i
n
n
e
r
.
</PREMISES>
<CONCLUSION>
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
</CONCLUSION>
<EVALUATE>
TEXT: All professional athletes spend most of their time on sports.
FOL: all x. (ProfessionalAthlete(x) -> SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Olympic gold medal winners are professional athletes.
FOL: all x. (OlympicGoldMedalWinner(x) -> ProfessionalAthlete(x))
TEXT: No full-time scientists spend the majority of their time on sports.
FOL: all x. (FullTimeScientist(x) -> -SpendOn(x, MostOfTheirTime, Sports))
TEXT: All Nobel physics laureates are full-time scientists.
FOL: all x. (NobelPhysicsLaureate(x) -> FullTimeScientist(x))
TEXT: Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
FOL: SpendOn(Amy, MostOfTheirTime, Sports) | OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.
FOL: -NobelPhysicsLaureate(Amy) -> -OlympicGoldMedalWinner(Amy)
TEXT: If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.
FOL: -OlympicGoldMedalWinner(Amy) -> NobelLaureate(Amy)
</EVALUATE>

<PREMISES>
I
f
 
a
 
p
e
r
s
o
n
 
p
a
y
s
 
t
h
e
i
r
 
t
a
x
e
s
,
 
t
h
e
n
 
t
h
e
y
 
c
o
n
t
r
i
b
u
t
e
 
t
o
 
t
h
e
 
c
o
u
n
t
r
y
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
w
o
r
k
s
 
f
o
r
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
 
p
a
y
s
 
a
 
t
a
x
 
o
n
 
t
h
e
i
r
 
s
a
l
a
r
y
.
 


E
v
e
r
y
o
n
e
 
i
n
 
t
h
e
 
a
r
m
y
 
i
s
 
a
n
 
e
m
p
l
o
y
e
e
 
o
f
 
a
 
g
o
v
e
r
n
m
e
n
t
 
d
e
p
a
r
t
m
e
n
t
.


E
v
e
r
y
o
n
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
 
g
o
e
s
 
t
o
 
p
r
i
s
o
n
.
 


E
v
e
r
y
o
n
e
 
w
h
o
 
h
a
s
 
b
e
e
n
 
t
o
 
p
r
i
s
o
n
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
.


J
a
m
e
s
 
w
a
s
 
e
i
t
h
e
r
 
o
n
c
e
 
c
o
n
v
i
c
t
e
d
 
o
f
 
m
u
r
d
e
r
,
 
o
r
 
s
p
e
n
t
 
t
i
m
e
 
i
n
 
p
r
i
s
o
n
.


J
a
m
e
s
 
e
i
t
h
e
r
 
h
a
s
 
a
 
c
r
i
m
i
n
a
l
 
r
e
c
o
r
d
,
 
o
r
 
p
a
y
s
 
h
i
s
 
t
a
x
e
s
.
 
</PREMISES>
<CONCLUSION>
James does not contribute to the country.
</CONCLUSION>
<EVALUATE>
TEXT: If a person pays their taxes, then they contribute to the country.
FOL: all x. (Taxpayer(x) -> ContributeTo(x, Country))
TEXT: Everyone who works for a government department pays a tax on their salary.
FOL: all x. (WorkFor(x, GovernmentAgency) -> Taxpayer(x))
TEXT: Everyone in the army is an employee of a government department.
FOL: all x. (ServesIn(x, TheArmy) -> WorkFor(x, GovernmentAgency))
TEXT: Everyone convicted of murder goes to prison.
FOL: all x. (SentencedForMurder(x) -> Imprisoned(x))
TEXT: Everyone who has been to prison has a criminal record.
FOL: all x. (Imprisoned((x) -> Has(x, CriminalRecord))
TEXT: James was either once convicted of murder, or spent time in prison.
FOL: ((SentencedForMurder(James) & -Imprisoned(James)) | (-SentencedForMurder(James) & Imprisoned(James)))
TEXT: James either has a criminal record, or pays his taxes.
FOL: ((Has(James, CriminalRecord) & -Taxpayer(James)) | (-Has(James, CriminalRecord) & Taxpayer(James)))
TEXT: James does not contribute to the country.
FOL: ContributeToCountry(James)
</EVALUATE>

<PREMISES>
N
o
 
s
o
n
g
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
f
o
l
k
 
s
o
n
g
s
 
a
r
e
 
s
o
n
g
s
.
 


A
l
l
 
v
i
d
e
o
s
 
a
r
e
 
v
i
s
u
a
l
s
.
 


A
l
l
 
m
o
v
i
e
s
 
a
r
e
 
v
i
d
e
o
s
.


A
l
l
 
s
c
i
-
f
i
 
m
o
v
i
e
s
 
a
r
e
 
m
o
v
i
e
s
.


I
n
c
e
p
t
i
o
n
 
i
s
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.


M
a
c
 
i
s
 
n
e
i
t
h
e
r
 
a
 
f
o
l
k
 
s
o
n
g
 
n
o
r
 
a
 
s
c
i
-
f
i
 
m
o
v
i
e
.
</PREMISES>
<CONCLUSION>
Inception is a folk song.
</CONCLUSION>
<EVALUATE>
TEXT: No songs are visuals.
FOL: all x. (Song(x) -> -Visual(x))
TEXT: All folk songs are songs.
FOL: all x. (FolkSong(x) -> Song(x))
TEXT: All videos are visuals.
FOL: all x. (Video(x) -> Visual(x))
TEXT: All movies are videos.
FOL: all x. (Movie(x) -> Video(x))
TEXT: All sci-fi movies are movies.
FOL: all x. (ScifiMovie(x) -> Movie(x))
TEXT: Inception is a sci-fi movie.
FOL: ScifiMovie(Inception)
TEXT: Mac is neither a folk song nor a sci-fi movie.
FOL: -FolkSong(Mac) & -ScifiMovie(Mac)
TEXT: Inception is a folk song.
FOL: FolkSong(Inception)
</EVALUATE>

<PREMISES>
E
v
e
r
y
 
c
h
e
f
 
c
a
n
 
c
o
o
k
.


S
o
m
e
 
p
e
o
p
l
e
 
w
h
o
 
a
r
e
n
’
t
 
c
h
e
f
s
 
c
a
n
 
c
o
o
k
.


P
e
o
p
l
e
 
w
h
o
 
c
o
o
k
 
c
a
n
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
a
n
d
 
p
a
s
t
a
.


I
f
 
s
o
m
e
o
n
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
 
a
n
d
 
m
u
f
f
i
n
s
,
 
t
h
e
y
 
a
r
e
 
a
 
b
a
k
e
r
.


B
a
k
e
r
s
 
w
h
o
 
c
a
n
 
a
l
s
o
 
m
a
k
e
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
 
c
a
n
 
m
a
k
e
 
a
 
g
o
o
d
 
b
r
e
a
k
f
a
s
t
.


L
u
k
e
 
c
a
n
 
m
a
k
e
 
c
o
o
k
i
e
s
,
 
s
c
r
a
m
b
l
e
d
 
e
g
g
s
,
 
a
n
d
 
m
u
f
f
i
n
s
,
 
b
u
t
 
n
o
t
 
p
a
s
t
a
.
</PREMISES>
<CONCLUSION>
Luke is a chef.
</CONCLUSION>
<EVALUATE>
TEXT: Every chef can cook.
FOL: all x. (Chef(x) -> Can(x, Cook))
TEXT: Some people who aren’t chefs can cook.
FOL: exists x. (-Chef(x) & Can(x, Cook))
TEXT: People who cook can make scrambled eggs and pasta.
FOL: all x. (Can(x, Cook) -> (CanMake(x, ScrambledEggs) & CanMake(x, Pasta)))
TEXT: If someone can make cookies and muffins, they are a baker.
FOL: all x. (CanMake(x, Cookies) & CanMake(x, Muffins) -> Baker(x))
TEXT: Bakers who can also make scrambled eggs can make a good breakfast.
FOL: all x. ((Baker(x) & CanMake(x, ScrambledEggs)) -> CanMake(x, GoodBreakfast))
TEXT: Luke can make cookies, scrambled eggs, and muffins, but not pasta.
FOL: CanMake(Luke, Cookies) & (CanMake(Luke, ScrambledEggs) & CanMake(Luke, Muffins) & -CanMake(Luke, Pasta)
TEXT: Luke is a chef.
FOL: MakeGoodBreakfast(Luke)
</EVALUATE>

<PREMISES>
E
T
S
 
d
e
v
e
l
o
p
s
 
v
a
r
i
o
u
s
 
s
t
a
n
d
a
r
d
i
z
e
d
 
t
e
s
t
s
 
p
r
i
m
a
r
i
l
y
 
i
n
 
t
h
e
 
U
n
i
t
e
d
 
S
t
a
t
e
s
 
f
o
r
 
K
-
1
2
 
a
n
d
 
h
i
g
h
e
r
 
e
d
u
c
a
t
i
o
n
.
 


E
T
S
 
a
d
m
i
n
i
s
t
e
r
s
 
i
n
t
e
r
n
a
t
i
o
n
a
l
 
t
e
s
t
s
,
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
T
O
E
F
L
,
 
T
O
E
I
C
,
 
G
R
E
,
 
a
n
d
 
s
u
b
j
e
c
t
 
t
e
s
t
s
.


M
a
n
y
 
o
f
 
t
h
e
 
a
s
s
e
s
s
m
e
n
t
s
 
E
T
S
 
d
e
v
e
l
o
p
s
 
a
r
e
 
a
s
s
o
c
i
a
t
e
d
 
w
i
t
h
 
e
n
t
r
y
 
t
o
 
t
h
e
 
U
S
 
t
e
r
t
i
a
r
y
 
a
n
d
 
q
u
a
t
e
r
n
a
r
y
 
e
d
u
c
a
t
i
o
n
 
i
n
s
t
i
t
u
t
i
o
n
s
.
 


E
T
S
 
a
l
s
o
 
d
e
v
e
l
o
p
s
 
K
-
1
2
 
s
t
a
t
e
w
i
d
e
 
a
s
s
e
s
s
m
e
n
t
s
 
u
s
e
d
 
f
o
r
 
a
c
c
o
u
n
t
a
b
i
l
i
t
y
 
t
e
s
t
i
n
g
 
i
n
 
m
a
n
y
 
s
t
a
t
e
s
.
</PREMISES>
<CONCLUSION>
ETS doesn't administer tests internationally.
</CONCLUSION>
<EVALUATE>
TEXT: ETS develops various standardized tests primarily in the United States for K-12 and higher education.
FOL: exists x. exists y. (Develop(eTS, x) & Develop(eTS, y) & StandardizedTest(x) & StandardizedTest(y) & In(x, UnitedState) & In(y, UnitedState) & For(x, kOneTwoAndHigherEducation) & For(y, kOneTwoAndHigherEducation))
TEXT: ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
FOL: exists x. (Administer(eTS, x) & InternationalTest(x) & (TOEFL(x) | TOEIC(x) | GRE(x) | SubjectTest(x)))
TEXT: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.
FOL: exists x. (Develop(eTS, x) & AssociatedWith(x, EntryToUSEducationInstitution))
TEXT: ETS also develops K-12 statewide assessments used for accountability testing in many states.
FOL: exists x. (Develop(eTS, x) & StateWideAssesment(x) & UsedFor(x, AccountabilityTesting))
TEXT: ETS doesn't administer tests internationally.
FOL: exists x. (Develops(Ets, x) & For(x, k-OneTwoandhighereducation)) & exists x. (Develops(Ets, x) & AssociatedWith(x, Entrytouseducationinstitutions))
</EVALUATE>

<PREMISES>
D
a
v
e
e
d
 
D
i
g
g
s
 
i
s
 
a
n
 
a
c
t
o
r
 
a
n
d
 
f
i
l
m
 
p
r
o
d
u
c
e
r
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
t
w
o
 
r
o
l
e
s
 
i
n
 
t
h
e
 
m
u
s
i
c
a
l
 
H
a
m
i
l
t
o
n
 
o
n
 
B
r
o
a
d
w
a
y
.


O
n
e
 
o
f
 
t
h
e
 
a
c
t
o
r
s
 
f
r
o
m
 
H
a
m
i
l
t
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


T
h
e
 
a
c
t
o
r
 
p
l
a
y
i
n
g
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
 
w
o
n
 
t
h
e
 
b
e
s
t
 
a
c
t
o
r
 
a
w
a
r
d
.


D
a
v
e
e
d
 
D
i
g
g
s
 
p
l
a
y
e
d
 
T
h
o
m
a
s
 
J
e
f
f
e
r
s
o
n
.


M
u
s
i
c
a
l
s
 
o
n
 
B
r
o
a
d
w
a
y
 
a
r
e
 
n
o
t
 
f
i
l
m
s
.
</PREMISES>
<CONCLUSION>
Daveed Diggs won the best actor award.
</CONCLUSION>
<EVALUATE>
TEXT: Daveed Diggs is an actor and film producer.
FOL: Actor(DaveedDiggs) & FilmProducer(DaveedDiggs)
TEXT: Daveed Diggs played two roles in the musical Hamilton on Broadway.
FOL: exists x. exists y.(PlaysIn(DaveedDiggs, x, Hamilton) & (-(x=y)) & PlaysIn(DaveedDiggs, y, Hamilton)) & OnBroadway(Hamilton) & Musical(Hamilton)
TEXT: One of the actors from Hamilton won the best actor award.
FOL: exists x. exists y.(Actor(x) & PlaysIn(x, y, Hamilton) & Wins(x, BestActorAward))
TEXT: The actor playing Thomas Jefferson won the best actor award.
FOL: exists x. (Actor(x) & PlaysIn(x, ThomasJefferson, Hamilton) & Wins(x, BestActorAward))
TEXT: Daveed Diggs played Thomas Jefferson.
FOL: Plays(DaveedDiggs, ThomasJefferson)
TEXT: Musicals on Broadway are not films.
FOL: all x. ((Musical(x) & OnBroadway(x)) -> -Film(x))
TEXT: Daveed Diggs won the best actor award.
FOL: exists x. (BRICS(x) & Speaks(x, Hindi))
</EVALUATE>

<PREMISES>
The bald eagle chases the cow.
The bald eagle likes the rabbit.
The bald eagle visits the cow.
The cow is not young.
The mouse chases the rabbit.
The mouse likes the bald eagle.
The mouse likes the cow.
The mouse does not like the rabbit.
The rabbit chases the mouse.
The rabbit is kind.
The rabbit is young.
The rabbit likes the cow.
If something is round then it chases the rabbit.
If something chases the cow then it is young.
If the bald eagle likes the rabbit and the rabbit chases the cow then the bald eagle does not visit the cow.
If the bald eagle chases the rabbit then the rabbit is round.
If something is young and it likes the rabbit then it is green.
If something is green then it is round.
If the rabbit likes the bald eagle then the bald eagle is round.
If something chases the bald eagle then it likes the bald eagle.
If something is green and it likes the cow then it visits the rabbit.
</PREMISES>
<CONCLUSION>
The mouse likes the rabbit.
</CONCLUSION>
<EVALUATE>

Generation 1:
TEXT: The bald eagle chases the cow.
FOL: Chases(BaldEagle, Cow)
TEXT: The bald eagle likes the rabbit.
FOL: Likes(BaldEagle, Rabbit)
TEXT: The bald eagle visits the cow.
FOL: Visits(BaldEagle, Cow)
TEXT: The cow is not young.
FOL: -Young(Cow)
TEXT: The mouse chases the rabbit.
FOL: Chases(Mouse, Rabbit)
TEXT: The mouse likes the bald eagle.
FOL: Likes(Mouse, BaldEagle)
TEXT: The mouse likes the cow.
FOL: Likes(Mouse, Cow)
TEXT: The mouse does not like the rabbit.
FOL: -Likes(Mouse, Rabbit)
TEXT: The rabbit chases the mouse.
FOL: Chases(Rabbit, Mouse)
TEXT: The rabbit is kind.
FOL: Kind(Rabbit)
TEXT: The rabbit is young.
FOL: Young(Rabbit)
TEXT: The rabbit likes the cow.
FOL: Likes(Rabbit, Cow)
TEXT: If something is round then it chases the rabbit.
FOL: all x. (Round(x) -> Chases(x, Rabbit))
TEXT: If something chases the cow then it is young.
FOL: all x. (Chases(x, Cow) -> Young(x))
TEXT: If the bald eagle likes the rabbit and the rabbit chases the cow then the bald eagle does not visit the cow.
FOL: (Likes(BaldEagle, Rabbit) & Chases(Rabbit, Cow)) -> -Visits(BaldEagle, Cow)
TEXT: If the bald eagle chases the rabbit then the rabbit is round.
FOL: Chases(BaldEagle, Rabbit) -> Round(Rabbit)
TEXT: If something is young and it likes the rabbit then it is green.
FOL: all x. ((Young(x) & Likes(x, Rabbit)) -> Green(x))
TEXT: If something is green then it is round.
FOL: all x. (Green(x) -> Round(x))
TEXT: If the rabbit likes the bald eagle then the bald eagle is round.
FOL: Likes(Rabbit, BaldEagle) -> Round(BaldEagle)
TEXT: If something chases the bald eagle then it likes the bald eagle.
FOL: all x. (Chases(x, BaldEagle) -> Likes(x, BaldEagle))
TEXT: If something is green and it likes the cow then it visits the rabbit.
FOL: all x. ((Green(x) & Likes(x, Cow)) -> Visits(x, Rabbit))
TEXT: The mouse likes the rabbit.
FOL: Likes(Mouse, Rabbit)
Processed: False

Generation 2:
TEXT: The bald eagle chases the cow.
FOL: Chases(BaldEagle, Cow)
TEXT: The bald eagle likes the rabbit.
FOL: Likes(BaldEagle, Rabbit)
TEXT: The bald eagle visits the cow.
FOL: Visits(BaldEagle, Cow)
TEXT: The cow is not young.
FOL: -Young(Cow)
TEXT: The mouse chases the rabbit.
FOL: Chases(Mouse, Rabbit)
TEXT: The mouse likes the bald eagle.
FOL: Likes(Mouse, BaldEagle)
TEXT: The mouse likes the cow.
FOL: Likes(Mouse, Cow)
TEXT: The mouse does not like the rabbit.
FOL: -Likes(Mouse, Rabbit)
TEXT: The rabbit chases the mouse.
FOL: Chases(Rabbit, Mouse)
TEXT: The rabbit is kind.
FOL: Kind(Rabbit)
TEXT: The rabbit is young.
FOL: Young(Rabbit)
TEXT: The rabbit likes the cow.
FOL: Likes(Rabbit, Cow)
TEXT: If something is round then it chases the rabbit.
FOL: all x. (Round(x) -> Chases(x, Rabbit))
TEXT: If something chases the cow then it is young.
FOL: all x. (Chases(x, Cow) -> Young(x))
TEXT: If the bald eagle likes the rabbit and the rabbit chases the cow then the bald eagle does not visit the cow.
FOL: (Likes(BaldEagle, Rabbit) & Chases(Rabbit, Cow)) -> -Visits(BaldEagle, Cow)
TEXT: If the bald eagle chases the rabbit then the rabbit is round.
FOL: (Chases(BaldEagle, Rabbit) -> Round(Rabbit))
TEXT: If something is young and it likes the rabbit then it is green.
FOL: all x. (Young(x) & Likes(x, Rabbit) -> Green(x))
TEXT: If something is green then it is round.
FOL: all x. (Green(x) -> Round(x))
TEXT: If the rabbit likes the bald eagle then the bald eagle is round.
FOL: (Likes(Rabbit, BaldEagle) -> Round(BaldEagle))
TEXT: If something chases the bald eagle then it likes the bald eagle.
FOL: all x. (Chases(x, BaldEagle) -> Likes(x, BaldEagle))
TEXT: If something is green and it likes the cow then it visits the rabbit.
FOL: all x. (Green(x) & Likes(x, Cow) -> Visits(x, Rabbit))
TEXT: The mouse likes the rabbit.
FOL: Likes(Mouse, Rabbit)
Processed: False

Generation 3:
TEXT: The bald eagle chases the cow.
FOL: Chases(BaldEagle, Cow)
TEXT: The bald eagle likes the rabbit.
FOL: Likes(BaldEagle, Rabbit)
TEXT: The bald eagle visits the cow.
FOL: Visits(BaldEagle, Cow)
TEXT: The cow is not young.
FOL: -Young(Cow)
TEXT: The mouse chases the rabbit.
FOL: Chases(Mouse, Rabbit)
TEXT: The mouse likes the bald eagle.
FOL: Likes(Mouse, BaldEagle)
TEXT: The mouse likes the cow.
FOL: Likes(Mouse, Cow)
TEXT: The mouse does not like the rabbit.
FOL: -Likes(Mouse, Rabbit)
TEXT: The rabbit chases the mouse.
FOL: Chases(Rabbit, Mouse)
TEXT: The rabbit is kind.
FOL: Kind(Rabbit)
TEXT: The rabbit is young.
FOL: Young(Rabbit)
TEXT: The rabbit likes the cow.
FOL: Likes(Rabbit, Cow)
TEXT: If something is round then it chases the rabbit.
FOL: all x. (Round(x) -> Chases(x, Rabbit))
TEXT: If something chases the cow then it is young.
FOL: all x. (Chases(x, Cow) -> Young(x))
TEXT: If the bald eagle likes the rabbit and the rabbit chases the cow then the bald eagle does not visit the cow.
FOL: (Likes(BaldEagle, Rabbit) & Chases(Rabbit, Cow)) -> -Visits(BaldEagle, Cow)
TEXT: If the bald eagle chases the rabbit then the rabbit is round.
FOL: (Chases(BaldEagle, Rabbit) -> Round(Rabbit))
TEXT: If something is young and it likes the rabbit then it is green.
FOL: all x. ((Young(x) & Likes(x, Rabbit)) -> Green(x))
TEXT: If something is green then it is round.
FOL: all x. (Green(x) -> Round(x))
TEXT: If the rabbit likes the bald eagle then the bald eagle is round.
FOL: (Likes(Rabbit, BaldEagle) -> Round(BaldEagle))
TEXT: If something chases the bald eagle then it likes the bald eagle.
FOL: all x. (Chases(x, BaldEagle) -> Likes(x, BaldEagle))
TEXT: If something is green and it likes the cow then it visits the rabbit.
FOL: all x. ((Green(x) & Likes(x, Cow)) -> Visits(x, Rabbit))
TEXT: The mouse likes the rabbit.
FOL: Likes(Mouse, Rabbit)

Note: The last expression `Likes(Mouse, Rabbit)` contradicts the given premise `The mouse does not like the rabbit.` Thus, the conclusion "The mouse likes the rabbit" does not logically follow from the premises.
Processed: False

Reference: False
========================================

